#!/usr/sbin/lua

--[[
mktestdb V0.2

v0.2  add js test case file support but only support base mode
V0.1  init version
]]

--usage
local g_usage = [[
Usage: mktestdb [options] [srcdir]
make testcase database from testcase code by tags
Options:
	-o <databasefile>       Place the output database file into <databasefile>,
	                         If not specified,will use testdb.lua as default
	-f                      Output all case function on stdout if srcdir is specified
	-c                      Output all testcase items on stdout if srcdir is specified
	-l <databasefile>       Load a database file named <databasefile> as input,
	                         If <srcdir> is specified,this will be ignored
	-i <testReport>         Import test report file from <testReport>,the report is generated by testkit
	-d                      Compare testreport and testdb,output there diffs if -i is set

support tags:
//@CASEGROUP:main test function,MUST
//@DESCRIPTION:Description of this test
//@PRECONDITION:Precondition
//@INPUT:Inputs
//@EXPECTATION:Expectation output
//@CASE:Test Case Id,MUST,if not defined,will get form the following testcase function define
//@REMARK:remarks of the test case
//@EXECUTIONFLOW:Execution Flow

Each tag could appear more then once for one test case,and a new line will be added each time.

NOTICE:
Please NO empty lines and others between tags or between tag and testcase function define

Report bugs to <lihui@coship.com>.]]

local SRC_TYPE = {
	SRC_C 	= 1,
	SRC_JS 	= 2
}

--support items
local s_supportitems = {
	CASEGROUP		= true,
	DESCRIPTION 	= true,
	PRECONDITION	= true,
	INPUT			= true,
	EXPECTATION		= true,
	CASE			= true,
	RESULT			= true,
	EXECUTIONFLOW   = true,
	REMARK			= true
}

local s_outputfilename = "testdb.lua"
local s_inputsrcdir = nil
local s_printCaseFunc = false
local s_printTestCaseItem = false
local s_srcdbfile = nil
local s_testreportfile = nil
local s_comparedbreport = nil

--function parse arg
function parsearg()
	local index = 1

	while arg[index] do
		if arg[index] == "-o" then
			index = index + 1
			if not arg[index] then
				print("mktestdb:argument to '-o' is missing")
				os.exit()
			else
				s_outputfilename = arg[index]
			end
		elseif arg[index] == "-l" then
			index = index + 1
			if not arg[index] then
				print("mktestdb:argument to '-l' is missing")
				os.exit()
			else
				s_srcdbfile = arg[index]
			end
		elseif arg[index] == "-i" then
			index = index + 1
			if not arg[index] then
				print("mktestdb:argument to '-i' is missing")
				os.exit()
			else
				s_testreportfile = arg[index]
			end
		elseif arg[index] == "-f" then
			s_printCaseFunc = true
		elseif arg[index] == "-c" then
			s_printTestCaseItem = true
		elseif arg[index] == "--help" then
			print(g_usage)
			os.exit()
		elseif arg[index] == "-d" then
			s_comparedbreport = true
		elseif string.sub(arg[index],1,1) ~= "-" then
			s_inputsrcdir = arg[index]
		end

		index = index + 1
	end

	if not s_inputsrcdir and not s_srcdbfile then
		print("no input dir or db file")
		os.exit()
	end

	if not s_outputfilename then
		print("no output file")
		os.exit()
	end

	if s_inputsrcdir and string.sub(s_inputsrcdir,-1) == "/" then
		s_inputsrcdir = string.sub(s_inputsrcdir,1,-2)
	end
end

--dir browse function,to add subdir browse
--function is a file (not a dir)
function isfile(lsline)
	if string.sub(lsline, 1, 1) ~= '-' then return nil end
	local _,_,filename = string.find(lsline,"%s*([%w%p]+)$")
	return filename
end

--function is a directory line ("xxxx:")
function isdirectory(lsline)
	if string.sub(lsline,-1,-1) ~= ":" then return nil end
	return string.sub(lsline,1,-2)
end

--all files iterater
function allfiles (dir)
	local tempFileName = "files.tmp"
	local cmd = "ls -l -R "..dir.." > "..tempFileName
	os.remove(tempFileName)
	os.execute(cmd)
	local dirs = assert(io.open(tempFileName,"r"))
	local directory = nil

	return function ()
		while true do
			local line = dirs:read("*line")
			if not line then
				io.close(dirs)
				return nil
			end

			local filename = isfile(line)

			if not filename then --not a filename line,then test directory line
				directory = isdirectory(line) or directory
			end

			if filename then return filename,directory end
		end
	end
end

--function pasre src file
function parseSrcFile(testcasestable,filename,dir,srctype)
	local srcfile = assert(io.open(dir.."/"..filename,"r"))
        local linenum = 0
	while true do
		local line = srcfile:read("*line")
		linenum = linenum + 1
		if not line then break end

		local startpos = string.find(line,"//@")
		if startpos then
			local case = {}
			while true do
				local _,_,item,content = string.find(line,"//@(%a+):(.*)")
				if not item then break end

				if s_supportitems[item] then
					if string.sub(content,-1) == "\r" then
						content = string.sub(content,0,-2)
					end

					if case[item] then
						case[item] = case[item].."\n"..content
					else
						case[item] = content;
					end
				end

				line = srcfile:read("*line")
				linenum = linenum + 1
				if not line then break end
			end

			--print("FUNCTION LINE: "..line)
			if not case["CASE"] then

				local testcase = nil

				if srctype == SRC_TYPE.SRC_JS then
					_,_,testcase = string.find(line,"function%s*([%w%p]+)%s*%(%s*%)")
				else
					_,_,testcase = string.find(line,"[Bb][Oo][Oo][Ll]%s*([%w%p]+)%s*%(%s*[Vv][Oo][Ii][Dd]%s*%)")
				end

				--print("["..testcase.."]")

				if testcase then
					case["CASE"] = testcase
					if s_printCaseFunc then
						local _,_,func = string.find(line,"([%w%p%s]+%))")
						print(func..";")
					end
					if s_printTestCaseItem then print("{CS_TK_AUTOCASE("..testcase..")},") end
				end
			end

			if not case["CASEGROUP"] then
				print("Warning:CASEGROUP MUST be designated or not a tag at:")
				print("		"..dir.."/"..filename.."@ line "..linenum..":"..line)
			elseif not case["CASE"] then
				print("Warning:CASE MUST be designated or not a tag at:")
				print("		"..dir.."/"..filename.."@ line "..linenum..":"..line)
			else
				if not testcasestable[dir] then testcasestable[dir] = {} end
				table.insert(testcasestable[dir],case)
			end
		end
	end

	io.close(srcfile)
end

--serialize function,can work on table without any loop
function serialize (o,file)
	if type(o) == "number" then
		file:write(o)
	elseif type(o) == "string" then
		file:write(string.format("%q", o))
	elseif type(o) == "table" then
		file:write("{\n")
		for k,v in pairs(o) do
			file:write(" [")
			serialize(k,file)
			file:write("] = ")
			serialize(v,file)
			file:write(",\n")
		end
		file:write("}\n")
	else
		error("cannot serialize a " .. type(o))
	end
end

--generate test case database file,it is a lua src too
function generatetestcasedb(testcasees)

	local dbfile = assert(io.open(s_outputfilename,"w"))

	dbfile:write("testcases")

	serialize(testcasees,dbfile)

	dbfile:close()
end

--function testdb 2 table
local s_tablefromtestdb = nil
function testdb2table(srctable)
	s_tablefromtestdb = srctable
end


--function Import testReport to table
function addreport2table(casetable,testreportfile)
	local srcfile = assert(io.open(testreportfile,"r"))

	local helpdirtable = {}
	local helpindextable = {}
	for dir,subtable in pairs(casetable) do

		--print(dir)

		for index in ipairs(subtable) do
			--print(index)

			assert(subtable[index]["CASE"] ~= nil,"Case Id is MUST")
			assert(helpindextable[subtable[index]["CASE"]] == nil,"Case Id Redefined")

			helpindextable[subtable[index]["CASE"]] = index
			helpdirtable[subtable[index]["CASE"]] = dir

			--print(subtable[index]["CASE"])
		end
	end

	local reportwithoutcasetable = {}

	while true do
		local line = srcfile:read("*line")
		if not line then break end

		--print("line:"..line)
		_,_,case,tctype,result = string.find(line,"^([%w%p]+)%s+(.-)\t([%w%p]+)")	--%s*([%w]+)
		--print(case)
		--print(tctype)
		--print(result)

		if case and result and tctype then
			if helpindextable[case] then  --report with case
				local index = helpindextable[case]

				if index < 0 then
					print("Warning,case "..case.." Redefined!")
				else
					local dir = helpdirtable[case]
					assert(casetable[dir][index]["CASE"] == case)

					casetable[dir][index]["RESULT"] = result
					casetable[dir][index]["TYPE"] = tctype

					--print(case.." = "..result)

					helpindextable[case] = -1
				end
			else
				--report without case
				table.insert(reportwithoutcasetable,case)
			end
		end
	end

	if s_comparedbreport then
		print("These testcases in testReport without doc:")
		for index,case in ipairs(reportwithoutcasetable) do
			print("\t"..case)
		end
		print("")

		print("These testcases donot have report:")
		for case,index in pairs(helpindextable) do
			if index > 0 then
				print("\t"..case)
			end
		end
		print("")
	end
end

---------------------
----main function----
---------------------
--check arg
parsearg(arg)

local testcasees = {}

if s_inputsrcdir then
	--search all dirs and found all tags
	for file,dir in allfiles(s_inputsrcdir) do
		local _,_,extname = string.find(file,"%.(.+)$")
		if extname then
			extname = string.lower(extname)
			if extname == "cpp" or extname == "c" then
				parseSrcFile(testcasees,file,dir,SRC_TYPE.SRC_C)
			elseif extname == "js" or extname == "html" or extname == "htm" then
				parseSrcFile(testcasees,file,dir,SRC_TYPE.SRC_JS)
			end
		end
	end
elseif s_srcdbfile then
	--convert testdb 2 table s_tablefromtestdb
	testcases = testdb2table
	dofile(s_srcdbfile)

	testcasees = s_tablefromtestdb
else
	assert(s_inputsrcdir or s_srcdbfile)
end

--add test report file to testcases table
if s_testreportfile then
	addreport2table(testcasees,s_testreportfile)
end

--output the testcasees table to file
generatetestcasedb(testcasees)



