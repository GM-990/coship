
/*
 *@version 1.0.0 2009/08/13 完成初始版本
 */
/* --------------------------------------------------------------------
注意：
1.在需要与用户交互的测试用例中，可以：
	a. 使用CSTKWaitAnyKey等待用户输入任意按键
	b. 使用CSTKWaitYes等待用户输入YES
2.测试用例函数命名：CSTC_测试用例ID，"测试用例ID"定义在测试用例文档中
-----------------------------------------------------------------------*/
#include "cs_sockettestcase.h"
#include "cs_testkit.h"
#include "udi2_socket.h"
#include "udi2_error.h"
#include "udi2_typedef.h"
#include "udi2_os.h"
#include "cs_tcpip.h"
#include "udi2_ipcfg.h"
#include "udiplus_os.h"
#include "udi2_sockerror.h"
#include "udi2_bluetooth.h"


#ifndef PACKET_SIZE
#define PACKET_SIZE     4096
#endif 

#ifndef CSICMP_ECHOREPLY
#define CSICMP_ECHOREPLY		0	/* Echo Reply			*/
#endif

#ifndef CSICMP_ECHO
#define CSICMP_ECHO		       8	 /* Echo	*/
#endif

#define SOCKET_TEST_STACK_SIZE 64*1024

// 可以创建的socket个数
#define SOCKET_MAX_SOCKET_CNT  128
// 发送大数据时，一次发送的数据长度
#define SOCK_TEST_SEND_LEN 4096

static char g_unReachedIp[16] = {0};					/*合法的IP地址，但是此IP地址不可达*/
static char g_szServIp[16] = {0};   					/*PC机IP地址，此时PC作为服务端*/
static char g_szClientIp[16] = {0};	 				/*PC机IP地址，此时PC作为客户端*/
static char g_szStbIp[16] = {0};  					/*机顶盒IP地址*/
static char g_szGateWay[16] = {0};  					/*机顶盒网关*/
static char g_szMask[16] = {0};  						/*机顶盒掩码*/
static int  g_nClientPort = 50000;				/*机顶盒作为客户端时端口号*/
static int  g_nServPort  = 26000;				/*PC机作为服务端时端口号*/
static int  g_nStbPort  = 51000; 				/*机顶盒端口号*/
static int 	g_nSaitionServer = 28;              /*测试甩信时机顶盒做为服务端的专用端口号*/

/* Minimum ICMP Header */
typedef struct {
  unsigned char     type;      /* type of message 	*/
  unsigned char     code;      /* type sub-code 	*/
  unsigned short    cksum;     /* checksum 			*/
  unsigned short    id;
  unsigned short    seq;
  unsigned int        tstart;
}SIcmpHeaderTest;



/* internet header */
typedef struct {
    unsigned char     ip_hlv;     /* header length & version field */
#define CS_IPHDRLEN_MASK    0x0f    /* mask for header length */
#define CS_IPVER_MASK       0xf0    /* mask for ip version */
#define CS_IPVER_IPV4       0x40    /* IPv4 version */
#define CS_IPVERSION    4              /* current IP version */
    unsigned char     ip_tos;     /* type of service */
#define CS_IPTOS_LOWDELAY      0x10    /* minimize delay */
#define CS_IPTOS_THROUGHPUT    0x08    /* maximize throughput */
#define CS_IPTOS_RELIABILITY   0x04    /* maximize reliability */
    unsigned short    ip_len;     /* total length */
    unsigned short    ip_id;      /* identification */
    unsigned short    ip_off;     /* fragment offset field */
#define CS_IPOFF_DF            0x4000  /* dont fragment flag */
#define CS_IPOFF_MF            0x2000  /* more fragment flag */
#define CS_IPOFF_MASK          0x1fff  /* mask for fragmenting bits */
    unsigned char     ip_ttl;     /* time to live */
    unsigned char     ip_p;       /* protocol */
    unsigned short    ip_sum;     /* checksum */
    unsigned int       ip_src;     /* source address */
    unsigned int       ip_dst;     /* destination address */
} SIpHeaderTest;


/**@brief ipv6  保存时间信息*/
typedef struct {
    int m_onoff;     ///< 置为0或者1，1表示启动，0表示不启动
    int m_linger;    ///<  m_onoff设置为1时，m_linger该值表示秒值，单位:秒
}Linger_S;

static int CSTC_iPing(char *pPingStr, char*pBackStr,unsigned int backstrlen,unsigned int timeout);


static  char s_aucRecvBuf[16*1024] = {0};
static  char s_aucSendBuf[] = {
   /*       0*/ 0x42, 0x4d, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 
	 /*       8*/ 0x00, 0x00, 0x06, 0x01, 0x00, 0x00, 0x28, 0x00, 
	 /*      16*/ 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 
	 /*      24*/ 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 
	 /*      32*/ 0x00, 0x00, 0x02, 0x09, 0x00, 0x00, 0x12, 0x0b, 
	 /*      40*/ 0x00, 0x00, 0x12, 0x0b, 0x00, 0x00, 0x34, 0x00, 
	 /*      48*/ 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*      56*/ 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 
	 /*      64*/ 0x00, 0xff, 0xe3, 0x5b, 0x00, 0xff, 0xa6, 0x43, 
	 /*      72*/ 0x00, 0xff, 0x69, 0x2a, 0x00, 0xff, 0x49, 0x1d, 
	 /*      80*/ 0x00, 0xff, 0x0e, 0x05, 0x00, 0xff, 0x1f, 0x0c, 
	 /*      88*/ 0x00, 0xff, 0x15, 0x08, 0x00, 0xff, 0x10, 0x06, 
	 /*      96*/ 0x00, 0xff, 0xf4, 0x62, 0x00, 0xff, 0xcd, 0x52, 
	 /*     104*/ 0x00, 0xff, 0xc9, 0x50, 0x00, 0xff, 0xc5, 0x4f, 
	 /*     112*/ 0x00, 0xff, 0xc3, 0x4e, 0x00, 0xff, 0xbf, 0x4c, 
	 /*     120*/ 0x00, 0xff, 0xb7, 0x49, 0x00, 0xff, 0xab, 0x45, 
	 /*     128*/ 0x00, 0xff, 0xa7, 0x43, 0x00, 0xff, 0xa2, 0x41, 
	 /*     136*/ 0x00, 0xff, 0x99, 0x3d, 0x00, 0xff, 0x94, 0x3c, 
	 /*     144*/ 0x00, 0xff, 0x87, 0x36, 0x00, 0xff, 0x86, 0x36, 
	 /*     152*/ 0x00, 0xff, 0x83, 0x35, 0x00, 0xff, 0x81, 0x33, 
	 /*     160*/ 0x00, 0xff, 0x7e, 0x33, 0x00, 0xff, 0x7b, 0x31, 
	 /*     168*/ 0x00, 0xff, 0x76, 0x2f, 0x00, 0xff, 0x6c, 0x2b, 
	 /*     176*/ 0x00, 0xff, 0x67, 0x2a, 0x00, 0xff, 0x5a, 0x24, 
	 /*     184*/ 0x00, 0xff, 0x55, 0x22, 0x00, 0xff, 0x52, 0x21, 
	 /*     192*/ 0x00, 0xff, 0x4c, 0x1e, 0x00, 0xff, 0x44, 0x1b, 
	 /*     200*/ 0x00, 0xff, 0x43, 0x1b, 0x00, 0xff, 0x3e, 0x19, 
	 /*     208*/ 0x00, 0xff, 0x3a, 0x17, 0x00, 0xff, 0x37, 0x16, 
	 /*     216*/ 0x00, 0xff, 0x32, 0x14, 0x00, 0xff, 0x2e, 0x13, 
	 /*     224*/ 0x00, 0xff, 0x2d, 0x12, 0x00, 0xff, 0x28, 0x10, 
	 /*     232*/ 0x00, 0xff, 0x26, 0x0f, 0x00, 0xff, 0x20, 0x0d, 
	 /*     240*/ 0x00, 0xff, 0x1c, 0x0b, 0x00, 0xff, 0x1b, 0x0b, 
	 /*     248*/ 0x00, 0xff, 0x09, 0x04, 0x00, 0xff, 0x04, 0x02, 
	 /*     256*/ 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
	 /*     264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     272*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     280*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     288*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     296*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     304*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     312*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     320*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     328*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 
	 /*     336*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     344*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     352*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     360*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     368*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     376*/ 0x00, 0x00, 0x00, 0x00, 0x27, 0x20, 0x20, 0x27, 
	 /*     384*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     392*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     400*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     408*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     416*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     424*/ 0x00, 0x00, 0x00, 0x2b, 0x18, 0x18, 0x18, 0x19, 
	 /*     432*/ 0x2b, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     440*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     448*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     456*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     464*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     472*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     480*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     488*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     496*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     504*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     512*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     520*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     528*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     536*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     544*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     552*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     568*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     576*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     584*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     608*/ 0x28, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     616*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     624*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     632*/ 0x00, 0x00, 0x07, 0x2e, 0x07, 0xff, 0x00, 0x00, 
	 /*     640*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x18, 
	 /*     656*/ 0x04, 0x1d, 0x09, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*     664*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     672*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     680*/ 0x00, 0x07, 0x06, 0x05, 0x21, 0x30, 0x00, 0x00, 
	 /*     688*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x19, 0x04, 
	 /*     704*/ 0x04, 0x04, 0x1d, 0x09, 0x00, 0xff, 0x00, 0x00, 
	 /*     712*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     720*/ 0x27, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     728*/ 0x07, 0x06, 0x1f, 0x05, 0x05, 0x21, 0x07, 0x00, 
	 /*     736*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x14, 0x04, 
	 /*     752*/ 0x04, 0x04, 0x14, 0x1d, 0x09, 0xff, 0x00, 0x00, 
	 /*     760*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     768*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
	 /*     776*/ 0x06, 0x05, 0x05, 0x1f, 0x05, 0x1f, 0x2e, 0x00, 
	 /*     784*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x1d, 0x04, 
	 /*     800*/ 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 0x00, 
	 /*     808*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     816*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x07, 0x06, 
	 /*     824*/ 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 0x31, 0x00, 
	 /*     832*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1c, 
	 /*     848*/ 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 
	 /*     856*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     864*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x07, 0x06, 0x1f, 
	 /*     872*/ 0x05, 0x05, 0x05, 0x05, 0x06, 0x07, 0x00, 0x00, 
	 /*     880*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     896*/ 0x1d, 0x04, 0x04, 0x04, 0x04, 0x14, 0x1d, 0x09, 
	 /*     904*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     912*/ 0x29, 0xff, 0x00, 0x00, 0x07, 0x06, 0x1f, 0x05, 
	 /*     920*/ 0x1f, 0x05, 0x1f, 0x06, 0x07, 0xff, 0x00, 0x00, 
	 /*     928*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     944*/ 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 
	 /*     952*/ 0x09, 0xff, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     960*/ 0x29, 0xff, 0x00, 0x07, 0x06, 0x05, 0x05, 0x05, 
	 /*     968*/ 0x05, 0x05, 0x06, 0x07, 0x00, 0xff, 0x00, 0x00, 
	 /*     976*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     992*/ 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 
	 /*    1000*/ 0x1d, 0x09, 0x00, 0x28, 0x18, 0x17, 0x17, 0x18, 
	 /*    1008*/ 0x27, 0xff, 0x07, 0x06, 0x05, 0x05, 0x1f, 0x05, 
	 /*    1016*/ 0x1f, 0x06, 0x07, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1024*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1032*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1040*/ 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 
	 /*    1048*/ 0x04, 0x1d, 0x09, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*    1056*/ 0x29, 0x31, 0x06, 0x1f, 0x05, 0x1f, 0x05, 0x05, 
	 /*    1064*/ 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1072*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1080*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1088*/ 0x00, 0x00, 0x00, 0x09, 0x1d, 0x14, 0x04, 0x04, 
	 /*    1096*/ 0x04, 0x04, 0x1e, 0x08, 0x05, 0x1b, 0x1b, 0x1f, 
	 /*    1104*/ 0x30, 0x24, 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 
	 /*    1112*/ 0x07, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1120*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1128*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1136*/ 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 
	 /*    1144*/ 0x04, 0x04, 0x1c, 0x32, 0x31, 0x30, 0x30, 0x31, 
	 /*    1152*/ 0x32, 0x23, 0x1f, 0x1f, 0x05, 0x1f, 0x06, 0x07, 
	 /*    1160*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1168*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1176*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1184*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 
	 /*    1192*/ 0x04, 0x16, 0x28, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1200*/ 0x00, 0x2e, 0x1f, 0x05, 0x1f, 0x06, 0x07, 0x00, 
	 /*    1208*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1216*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1224*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1232*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1e, 
	 /*    1240*/ 0x1c, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1248*/ 0x00, 0x00, 0x2e, 0x23, 0x24, 0x31, 0x00, 0x00, 
	 /*    1256*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1272*/ 0x07, 0x25, 0x22, 0x23, 0x23, 0x23, 0x23, 0x22, 
	 /*    1280*/ 0x23, 0x22, 0x06, 0x23, 0x22, 0x23, 0x23, 0x2c, 
	 /*    1288*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1296*/ 0x00, 0x00, 0x00, 0x32, 0x0a, 0x30, 0x30, 0x30, 
	 /*    1304*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x09, 
	 /*    1312*/ 0x30, 0x30, 0x30, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1320*/ 0x22, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x0e, 
	 /*    1328*/ 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x0f, 0x15, 
	 /*    1336*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1344*/ 0x00, 0x00, 0x00, 0x32, 0x27, 0x06, 0x06, 0x24, 
	 /*    1352*/ 0x06, 0x24, 0x06, 0x06, 0x06, 0x24, 0x06, 0x06, 
	 /*    1360*/ 0x06, 0x24, 0x24, 0x2f, 0x00, 0xff, 0x00, 0x00, 
	 /*    1368*/ 0x1a, 0x0f, 0x10, 0x0f, 0x10, 0x10, 0x10, 0x0f, 
	 /*    1376*/ 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x11, 
	 /*    1384*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1392*/ 0x00, 0x00, 0x00, 0x07, 0x24, 0x06, 0x06, 0x06, 
	 /*    1400*/ 0x06, 0x23, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1408*/ 0x06, 0x23, 0x23, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1416*/ 0x1a, 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x10, 0x10, 
	 /*    1424*/ 0x0f, 0x10, 0x10, 0x10, 0x0f, 0x10, 0x10, 0x11, 
	 /*    1432*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1440*/ 0x00, 0x00, 0x00, 0x07, 0x25, 0x06, 0x06, 0x06, 
	 /*    1448*/ 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1456*/ 0x06, 0x06, 0x06, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1464*/ 0x21, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x10, 
	 /*    1472*/ 0x0f, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0e, 0x16, 
	 /*    1480*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1488*/ 0x00, 0x00, 0x00, 0x00, 0x28, 0x06, 0x06, 0x06, 
	 /*    1496*/ 0x06, 0x06, 0x24, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1504*/ 0x24, 0x06, 0x06, 0x08, 0x00, 0xff, 0x00, 0x00, 
	 /*    1512*/ 0x07, 0x24, 0x23, 0x06, 0x23, 0x23, 0x23, 0x23, 
	 /*    1520*/ 0x22, 0x23, 0x23, 0x06, 0x23, 0x23, 0x23, 0x2b, 
	 /*    1528*/ 0x31, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1536*/ 0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x30, 0x30, 
	 /*    1544*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
	 /*    1552*/ 0x30, 0x30, 0x09, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1568*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x16, 
	 /*    1576*/ 0x14, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1584*/ 0x00, 0x00, 0x07, 0x2e, 0x08, 0xff, 0x00, 0x00, 
	 /*    1592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1608*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1616*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x13, 0x03, 
	 /*    1624*/ 0x03, 0x0c, 0x26, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1632*/ 0x00, 0x07, 0x2c, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    1640*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1656*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1664*/ 0x00, 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 
	 /*    1672*/ 0x03, 0x03, 0x14, 0x32, 0x09, 0x28, 0x28, 0x09, 
	 /*    1680*/ 0x00, 0x2e, 0x2a, 0x2b, 0x2b, 0x2b, 0x2e, 0x32, 
	 /*    1688*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1704*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1712*/ 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 
	 /*    1720*/ 0x03, 0x03, 0x16, 0x27, 0x0d, 0x0b, 0x0b, 0x0d, 
	 /*    1728*/ 0x29, 0x30, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2e, 
	 /*    1736*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1752*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1760*/ 0x00, 0x00, 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 
	 /*    1768*/ 0x03, 0x13, 0x2f, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1776*/ 0x1f, 0xff, 0x08, 0x2b, 0x2b, 0x2c, 0x2b, 0x2b, 
	 /*    1784*/ 0x08, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1800*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1808*/ 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 
	 /*    1816*/ 0x04, 0x08, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1824*/ 0x05, 0xff, 0x32, 0x08, 0x2b, 0x2b, 0x2b, 0x2b, 
	 /*    1832*/ 0x2b, 0x2e, 0x32, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1848*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1856*/ 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x13, 
	 /*    1864*/ 0x08, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1872*/ 0x05, 0xff, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 0x2c, 
	 /*    1880*/ 0x2b, 0x2b, 0x08, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1896*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
	 /*    1904*/ 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 
	 /*    1912*/ 0x00, 0xff, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1920*/ 0x1f, 0xff, 0x00, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 
	 /*    1928*/ 0x2c, 0x2a, 0x2b, 0x2e, 0x32, 0xff, 0x00, 0x00, 
	 /*    1936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1944*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 
	 /*    1952*/ 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 
	 /*    1960*/ 0x00, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1968*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x32, 0x08, 0x2a, 
	 /*    1976*/ 0x2b, 0x2a, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 0x00, 
	 /*    1984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1992*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x04, 0x03, 
	 /*    2000*/ 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 0x00, 
	 /*    2008*/ 0x00, 0x00, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    2016*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x00, 0x32, 0x08, 
	 /*    2024*/ 0x2b, 0x2b, 0x2a, 0x2c, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    2032*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    2040*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x03, 0x03, 
	    /*       0*/ 0x42, 0x4d, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 
	 /*       8*/ 0x00, 0x00, 0x06, 0x01, 0x00, 0x00, 0x28, 0x00, 
	 /*      16*/ 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 
	 /*      24*/ 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 
	 /*      32*/ 0x00, 0x00, 0x02, 0x09, 0x00, 0x00, 0x12, 0x0b, 
	 /*      40*/ 0x00, 0x00, 0x12, 0x0b, 0x00, 0x00, 0x34, 0x00, 
	 /*      48*/ 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*      56*/ 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 
	 /*      64*/ 0x00, 0xff, 0xe3, 0x5b, 0x00, 0xff, 0xa6, 0x43, 
	 /*      72*/ 0x00, 0xff, 0x69, 0x2a, 0x00, 0xff, 0x49, 0x1d, 
	 /*      80*/ 0x00, 0xff, 0x0e, 0x05, 0x00, 0xff, 0x1f, 0x0c, 
	 /*      88*/ 0x00, 0xff, 0x15, 0x08, 0x00, 0xff, 0x10, 0x06, 
	 /*      96*/ 0x00, 0xff, 0xf4, 0x62, 0x00, 0xff, 0xcd, 0x52, 
	 /*     104*/ 0x00, 0xff, 0xc9, 0x50, 0x00, 0xff, 0xc5, 0x4f, 
	 /*     112*/ 0x00, 0xff, 0xc3, 0x4e, 0x00, 0xff, 0xbf, 0x4c, 
	 /*     120*/ 0x00, 0xff, 0xb7, 0x49, 0x00, 0xff, 0xab, 0x45, 
	 /*     128*/ 0x00, 0xff, 0xa7, 0x43, 0x00, 0xff, 0xa2, 0x41, 
	 /*     136*/ 0x00, 0xff, 0x99, 0x3d, 0x00, 0xff, 0x94, 0x3c, 
	 /*     144*/ 0x00, 0xff, 0x87, 0x36, 0x00, 0xff, 0x86, 0x36, 
	 /*     152*/ 0x00, 0xff, 0x83, 0x35, 0x00, 0xff, 0x81, 0x33, 
	 /*     160*/ 0x00, 0xff, 0x7e, 0x33, 0x00, 0xff, 0x7b, 0x31, 
	 /*     168*/ 0x00, 0xff, 0x76, 0x2f, 0x00, 0xff, 0x6c, 0x2b, 
	 /*     176*/ 0x00, 0xff, 0x67, 0x2a, 0x00, 0xff, 0x5a, 0x24, 
	 /*     184*/ 0x00, 0xff, 0x55, 0x22, 0x00, 0xff, 0x52, 0x21, 
	 /*     192*/ 0x00, 0xff, 0x4c, 0x1e, 0x00, 0xff, 0x44, 0x1b, 
	 /*     200*/ 0x00, 0xff, 0x43, 0x1b, 0x00, 0xff, 0x3e, 0x19, 
	 /*     208*/ 0x00, 0xff, 0x3a, 0x17, 0x00, 0xff, 0x37, 0x16, 
	 /*     216*/ 0x00, 0xff, 0x32, 0x14, 0x00, 0xff, 0x2e, 0x13, 
	 /*     224*/ 0x00, 0xff, 0x2d, 0x12, 0x00, 0xff, 0x28, 0x10, 
	 /*     232*/ 0x00, 0xff, 0x26, 0x0f, 0x00, 0xff, 0x20, 0x0d, 
	 /*     240*/ 0x00, 0xff, 0x1c, 0x0b, 0x00, 0xff, 0x1b, 0x0b, 
	 /*     248*/ 0x00, 0xff, 0x09, 0x04, 0x00, 0xff, 0x04, 0x02, 
	 /*     256*/ 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
	 /*     264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     272*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     280*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     288*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     296*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     304*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     312*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     320*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     328*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 
	 /*     336*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     344*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     352*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     360*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     368*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     376*/ 0x00, 0x00, 0x00, 0x00, 0x27, 0x20, 0x20, 0x27, 
	 /*     384*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     392*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     400*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     408*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     416*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     424*/ 0x00, 0x00, 0x00, 0x2b, 0x18, 0x18, 0x18, 0x19, 
	 /*     432*/ 0x2b, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     440*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     448*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     456*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     464*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     472*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     480*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     488*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     496*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     504*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     512*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     520*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     528*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     536*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     544*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     552*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     568*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     576*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     584*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     608*/ 0x28, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     616*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     624*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     632*/ 0x00, 0x00, 0x07, 0x2e, 0x07, 0xff, 0x00, 0x00, 
	 /*     640*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x18, 
	 /*     656*/ 0x04, 0x1d, 0x09, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*     664*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     672*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     680*/ 0x00, 0x07, 0x06, 0x05, 0x21, 0x30, 0x00, 0x00, 
	 /*     688*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x19, 0x04, 
	 /*     704*/ 0x04, 0x04, 0x1d, 0x09, 0x00, 0xff, 0x00, 0x00, 
	 /*     712*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     720*/ 0x27, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     728*/ 0x07, 0x06, 0x1f, 0x05, 0x05, 0x21, 0x07, 0x00, 
	 /*     736*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x14, 0x04, 
	 /*     752*/ 0x04, 0x04, 0x14, 0x1d, 0x09, 0xff, 0x00, 0x00, 
	 /*     760*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     768*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
	 /*     776*/ 0x06, 0x05, 0x05, 0x1f, 0x05, 0x1f, 0x2e, 0x00, 
	 /*     784*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x1d, 0x04, 
	 /*     800*/ 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 0x00, 
	 /*     808*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     816*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x07, 0x06, 
	 /*     824*/ 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 0x31, 0x00, 
	 /*     832*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1c, 
	 /*     848*/ 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 
	 /*     856*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     864*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x07, 0x06, 0x1f, 
	 /*     872*/ 0x05, 0x05, 0x05, 0x05, 0x06, 0x07, 0x00, 0x00, 
	 /*     880*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     896*/ 0x1d, 0x04, 0x04, 0x04, 0x04, 0x14, 0x1d, 0x09, 
	 /*     904*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     912*/ 0x29, 0xff, 0x00, 0x00, 0x07, 0x06, 0x1f, 0x05, 
	 /*     920*/ 0x1f, 0x05, 0x1f, 0x06, 0x07, 0xff, 0x00, 0x00, 
	 /*     928*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     944*/ 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 
	 /*     952*/ 0x09, 0xff, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     960*/ 0x29, 0xff, 0x00, 0x07, 0x06, 0x05, 0x05, 0x05, 
	 /*     968*/ 0x05, 0x05, 0x06, 0x07, 0x00, 0xff, 0x00, 0x00, 
	 /*     976*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     992*/ 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 
	 /*    1000*/ 0x1d, 0x09, 0x00, 0x28, 0x18, 0x17, 0x17, 0x18, 
	 /*    1008*/ 0x27, 0xff, 0x07, 0x06, 0x05, 0x05, 0x1f, 0x05, 
	 /*    1016*/ 0x1f, 0x06, 0x07, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1024*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1032*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1040*/ 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 
	 /*    1048*/ 0x04, 0x1d, 0x09, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*    1056*/ 0x29, 0x31, 0x06, 0x1f, 0x05, 0x1f, 0x05, 0x05, 
	 /*    1064*/ 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1072*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1080*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1088*/ 0x00, 0x00, 0x00, 0x09, 0x1d, 0x14, 0x04, 0x04, 
	 /*    1096*/ 0x04, 0x04, 0x1e, 0x08, 0x05, 0x1b, 0x1b, 0x1f, 
	 /*    1104*/ 0x30, 0x24, 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 
	 /*    1112*/ 0x07, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1120*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1128*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1136*/ 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 
	 /*    1144*/ 0x04, 0x04, 0x1c, 0x32, 0x31, 0x30, 0x30, 0x31, 
	 /*    1152*/ 0x32, 0x23, 0x1f, 0x1f, 0x05, 0x1f, 0x06, 0x07, 
	 /*    1160*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1168*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1176*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1184*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 
	 /*    1192*/ 0x04, 0x16, 0x28, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1200*/ 0x00, 0x2e, 0x1f, 0x05, 0x1f, 0x06, 0x07, 0x00, 
	 /*    1208*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1216*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1224*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1232*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1e, 
	 /*    1240*/ 0x1c, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1248*/ 0x00, 0x00, 0x2e, 0x23, 0x24, 0x31, 0x00, 0x00, 
	 /*    1256*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1272*/ 0x07, 0x25, 0x22, 0x23, 0x23, 0x23, 0x23, 0x22, 
	 /*    1280*/ 0x23, 0x22, 0x06, 0x23, 0x22, 0x23, 0x23, 0x2c, 
	 /*    1288*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1296*/ 0x00, 0x00, 0x00, 0x32, 0x0a, 0x30, 0x30, 0x30, 
	 /*    1304*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x09, 
	 /*    1312*/ 0x30, 0x30, 0x30, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1320*/ 0x22, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x0e, 
	 /*    1328*/ 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x0f, 0x15, 
	 /*    1336*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1344*/ 0x00, 0x00, 0x00, 0x32, 0x27, 0x06, 0x06, 0x24, 
	 /*    1352*/ 0x06, 0x24, 0x06, 0x06, 0x06, 0x24, 0x06, 0x06, 
	 /*    1360*/ 0x06, 0x24, 0x24, 0x2f, 0x00, 0xff, 0x00, 0x00, 
	 /*    1368*/ 0x1a, 0x0f, 0x10, 0x0f, 0x10, 0x10, 0x10, 0x0f, 
	 /*    1376*/ 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x11, 
	 /*    1384*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1392*/ 0x00, 0x00, 0x00, 0x07, 0x24, 0x06, 0x06, 0x06, 
	 /*    1400*/ 0x06, 0x23, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1408*/ 0x06, 0x23, 0x23, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1416*/ 0x1a, 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x10, 0x10, 
	 /*    1424*/ 0x0f, 0x10, 0x10, 0x10, 0x0f, 0x10, 0x10, 0x11, 
	 /*    1432*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1440*/ 0x00, 0x00, 0x00, 0x07, 0x25, 0x06, 0x06, 0x06, 
	 /*    1448*/ 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1456*/ 0x06, 0x06, 0x06, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1464*/ 0x21, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x10, 
	 /*    1472*/ 0x0f, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0e, 0x16, 
	 /*    1480*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1488*/ 0x00, 0x00, 0x00, 0x00, 0x28, 0x06, 0x06, 0x06, 
	 /*    1496*/ 0x06, 0x06, 0x24, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1504*/ 0x24, 0x06, 0x06, 0x08, 0x00, 0xff, 0x00, 0x00, 
	 /*    1512*/ 0x07, 0x24, 0x23, 0x06, 0x23, 0x23, 0x23, 0x23, 
	 /*    1520*/ 0x22, 0x23, 0x23, 0x06, 0x23, 0x23, 0x23, 0x2b, 
	 /*    1528*/ 0x31, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1536*/ 0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x30, 0x30, 
	 /*    1544*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
	 /*    1552*/ 0x30, 0x30, 0x09, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1568*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x16, 
	 /*    1576*/ 0x14, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1584*/ 0x00, 0x00, 0x07, 0x2e, 0x08, 0xff, 0x00, 0x00, 
	 /*    1592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1608*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1616*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x13, 0x03, 
	 /*    1624*/ 0x03, 0x0c, 0x26, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1632*/ 0x00, 0x07, 0x2c, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    1640*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1656*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1664*/ 0x00, 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 
	 /*    1672*/ 0x03, 0x03, 0x14, 0x32, 0x09, 0x28, 0x28, 0x09, 
	 /*    1680*/ 0x00, 0x2e, 0x2a, 0x2b, 0x2b, 0x2b, 0x2e, 0x32, 
	 /*    1688*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1704*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1712*/ 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 
	 /*    1720*/ 0x03, 0x03, 0x16, 0x27, 0x0d, 0x0b, 0x0b, 0x0d, 
	 /*    1728*/ 0x29, 0x30, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2e, 
	 /*    1736*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1752*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1760*/ 0x00, 0x00, 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 
	 /*    1768*/ 0x03, 0x13, 0x2f, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1776*/ 0x1f, 0xff, 0x08, 0x2b, 0x2b, 0x2c, 0x2b, 0x2b, 
	 /*    1784*/ 0x08, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1800*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1808*/ 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 
	 /*    1816*/ 0x04, 0x08, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1824*/ 0x05, 0xff, 0x32, 0x08, 0x2b, 0x2b, 0x2b, 0x2b, 
	 /*    1832*/ 0x2b, 0x2e, 0x32, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1848*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1856*/ 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x13, 
	 /*    1864*/ 0x08, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1872*/ 0x05, 0xff, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 0x2c, 
	 /*    1880*/ 0x2b, 0x2b, 0x08, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1896*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
	 /*    1904*/ 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 
	 /*    1912*/ 0x00, 0xff, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1920*/ 0x1f, 0xff, 0x00, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 
	 /*    1928*/ 0x2c, 0x2a, 0x2b, 0x2e, 0x32, 0xff, 0x00, 0x00, 
	 /*    1936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1944*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 
	 /*    1952*/ 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 
	 /*    1960*/ 0x00, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1968*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x32, 0x08, 0x2a, 
	 /*    1976*/ 0x2b, 0x2a, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 0x00, 
	 /*    1984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1992*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x04, 0x03, 
	 /*    2000*/ 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 0x00, 
	 /*    2008*/ 0x00, 0x00, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    2016*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x00, 0x32, 0x08, 
	 /*    2024*/ 0x2b, 0x2b, 0x2a, 0x2c, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    2032*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    2040*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x03, 0x03, 
	    /*       0*/ 0x42, 0x4d, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 
	 /*       8*/ 0x00, 0x00, 0x06, 0x01, 0x00, 0x00, 0x28, 0x00, 
	 /*      16*/ 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 
	 /*      24*/ 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 
	 /*      32*/ 0x00, 0x00, 0x02, 0x09, 0x00, 0x00, 0x12, 0x0b, 
	 /*      40*/ 0x00, 0x00, 0x12, 0x0b, 0x00, 0x00, 0x34, 0x00, 
	 /*      48*/ 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*      56*/ 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 
	 /*      64*/ 0x00, 0xff, 0xe3, 0x5b, 0x00, 0xff, 0xa6, 0x43, 
	 /*      72*/ 0x00, 0xff, 0x69, 0x2a, 0x00, 0xff, 0x49, 0x1d, 
	 /*      80*/ 0x00, 0xff, 0x0e, 0x05, 0x00, 0xff, 0x1f, 0x0c, 
	 /*      88*/ 0x00, 0xff, 0x15, 0x08, 0x00, 0xff, 0x10, 0x06, 
	 /*      96*/ 0x00, 0xff, 0xf4, 0x62, 0x00, 0xff, 0xcd, 0x52, 
	 /*     104*/ 0x00, 0xff, 0xc9, 0x50, 0x00, 0xff, 0xc5, 0x4f, 
	 /*     112*/ 0x00, 0xff, 0xc3, 0x4e, 0x00, 0xff, 0xbf, 0x4c, 
	 /*     120*/ 0x00, 0xff, 0xb7, 0x49, 0x00, 0xff, 0xab, 0x45, 
	 /*     128*/ 0x00, 0xff, 0xa7, 0x43, 0x00, 0xff, 0xa2, 0x41, 
	 /*     136*/ 0x00, 0xff, 0x99, 0x3d, 0x00, 0xff, 0x94, 0x3c, 
	 /*     144*/ 0x00, 0xff, 0x87, 0x36, 0x00, 0xff, 0x86, 0x36, 
	 /*     152*/ 0x00, 0xff, 0x83, 0x35, 0x00, 0xff, 0x81, 0x33, 
	 /*     160*/ 0x00, 0xff, 0x7e, 0x33, 0x00, 0xff, 0x7b, 0x31, 
	 /*     168*/ 0x00, 0xff, 0x76, 0x2f, 0x00, 0xff, 0x6c, 0x2b, 
	 /*     176*/ 0x00, 0xff, 0x67, 0x2a, 0x00, 0xff, 0x5a, 0x24, 
	 /*     184*/ 0x00, 0xff, 0x55, 0x22, 0x00, 0xff, 0x52, 0x21, 
	 /*     192*/ 0x00, 0xff, 0x4c, 0x1e, 0x00, 0xff, 0x44, 0x1b, 
	 /*     200*/ 0x00, 0xff, 0x43, 0x1b, 0x00, 0xff, 0x3e, 0x19, 
	 /*     208*/ 0x00, 0xff, 0x3a, 0x17, 0x00, 0xff, 0x37, 0x16, 
	 /*     216*/ 0x00, 0xff, 0x32, 0x14, 0x00, 0xff, 0x2e, 0x13, 
	 /*     224*/ 0x00, 0xff, 0x2d, 0x12, 0x00, 0xff, 0x28, 0x10, 
	 /*     232*/ 0x00, 0xff, 0x26, 0x0f, 0x00, 0xff, 0x20, 0x0d, 
	 /*     240*/ 0x00, 0xff, 0x1c, 0x0b, 0x00, 0xff, 0x1b, 0x0b, 
	 /*     248*/ 0x00, 0xff, 0x09, 0x04, 0x00, 0xff, 0x04, 0x02, 
	 /*     256*/ 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
	 /*     264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     272*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     280*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     288*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     296*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     304*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     312*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     320*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     328*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 
	 /*     336*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     344*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     352*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     360*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     368*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     376*/ 0x00, 0x00, 0x00, 0x00, 0x27, 0x20, 0x20, 0x27, 
	 /*     384*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     392*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     400*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     408*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     416*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     424*/ 0x00, 0x00, 0x00, 0x2b, 0x18, 0x18, 0x18, 0x19, 
	 /*     432*/ 0x2b, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     440*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     448*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     456*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     464*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     472*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     480*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     488*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     496*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     504*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     512*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     520*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     528*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     536*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     544*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     552*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     568*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     576*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     584*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     608*/ 0x28, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     616*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     624*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     632*/ 0x00, 0x00, 0x07, 0x2e, 0x07, 0xff, 0x00, 0x00, 
	 /*     640*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x18, 
	 /*     656*/ 0x04, 0x1d, 0x09, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*     664*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     672*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     680*/ 0x00, 0x07, 0x06, 0x05, 0x21, 0x30, 0x00, 0x00, 
	 /*     688*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x19, 0x04, 
	 /*     704*/ 0x04, 0x04, 0x1d, 0x09, 0x00, 0xff, 0x00, 0x00, 
	 /*     712*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     720*/ 0x27, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     728*/ 0x07, 0x06, 0x1f, 0x05, 0x05, 0x21, 0x07, 0x00, 
	 /*     736*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x14, 0x04, 
	 /*     752*/ 0x04, 0x04, 0x14, 0x1d, 0x09, 0xff, 0x00, 0x00, 
	 /*     760*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     768*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
	 /*     776*/ 0x06, 0x05, 0x05, 0x1f, 0x05, 0x1f, 0x2e, 0x00, 
	 /*     784*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x1d, 0x04, 
	 /*     800*/ 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 0x00, 
	 /*     808*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     816*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x07, 0x06, 
	 /*     824*/ 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 0x31, 0x00, 
	 /*     832*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1c, 
	 /*     848*/ 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 
	 /*     856*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     864*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x07, 0x06, 0x1f, 
	 /*     872*/ 0x05, 0x05, 0x05, 0x05, 0x06, 0x07, 0x00, 0x00, 
	 /*     880*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     896*/ 0x1d, 0x04, 0x04, 0x04, 0x04, 0x14, 0x1d, 0x09, 
	 /*     904*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     912*/ 0x29, 0xff, 0x00, 0x00, 0x07, 0x06, 0x1f, 0x05, 
	 /*     920*/ 0x1f, 0x05, 0x1f, 0x06, 0x07, 0xff, 0x00, 0x00, 
	 /*     928*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     944*/ 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 
	 /*     952*/ 0x09, 0xff, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     960*/ 0x29, 0xff, 0x00, 0x07, 0x06, 0x05, 0x05, 0x05, 
	 /*     968*/ 0x05, 0x05, 0x06, 0x07, 0x00, 0xff, 0x00, 0x00, 
	 /*     976*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     992*/ 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 
	 /*    1000*/ 0x1d, 0x09, 0x00, 0x28, 0x18, 0x17, 0x17, 0x18, 
	 /*    1008*/ 0x27, 0xff, 0x07, 0x06, 0x05, 0x05, 0x1f, 0x05, 
	 /*    1016*/ 0x1f, 0x06, 0x07, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1024*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1032*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1040*/ 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 
	 /*    1048*/ 0x04, 0x1d, 0x09, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*    1056*/ 0x29, 0x31, 0x06, 0x1f, 0x05, 0x1f, 0x05, 0x05, 
	 /*    1064*/ 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1072*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1080*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1088*/ 0x00, 0x00, 0x00, 0x09, 0x1d, 0x14, 0x04, 0x04, 
	 /*    1096*/ 0x04, 0x04, 0x1e, 0x08, 0x05, 0x1b, 0x1b, 0x1f, 
	 /*    1104*/ 0x30, 0x24, 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 
	 /*    1112*/ 0x07, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1120*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1128*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1136*/ 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 
	 /*    1144*/ 0x04, 0x04, 0x1c, 0x32, 0x31, 0x30, 0x30, 0x31, 
	 /*    1152*/ 0x32, 0x23, 0x1f, 0x1f, 0x05, 0x1f, 0x06, 0x07, 
	 /*    1160*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1168*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1176*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1184*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 
	 /*    1192*/ 0x04, 0x16, 0x28, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1200*/ 0x00, 0x2e, 0x1f, 0x05, 0x1f, 0x06, 0x07, 0x00, 
	 /*    1208*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1216*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1224*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1232*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1e, 
	 /*    1240*/ 0x1c, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1248*/ 0x00, 0x00, 0x2e, 0x23, 0x24, 0x31, 0x00, 0x00, 
	 /*    1256*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1272*/ 0x07, 0x25, 0x22, 0x23, 0x23, 0x23, 0x23, 0x22, 
	 /*    1280*/ 0x23, 0x22, 0x06, 0x23, 0x22, 0x23, 0x23, 0x2c, 
	 /*    1288*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1296*/ 0x00, 0x00, 0x00, 0x32, 0x0a, 0x30, 0x30, 0x30, 
	 /*    1304*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x09, 
	 /*    1312*/ 0x30, 0x30, 0x30, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1320*/ 0x22, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x0e, 
	 /*    1328*/ 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x0f, 0x15, 
	 /*    1336*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1344*/ 0x00, 0x00, 0x00, 0x32, 0x27, 0x06, 0x06, 0x24, 
	 /*    1352*/ 0x06, 0x24, 0x06, 0x06, 0x06, 0x24, 0x06, 0x06, 
	 /*    1360*/ 0x06, 0x24, 0x24, 0x2f, 0x00, 0xff, 0x00, 0x00, 
	 /*    1368*/ 0x1a, 0x0f, 0x10, 0x0f, 0x10, 0x10, 0x10, 0x0f, 
	 /*    1376*/ 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x11, 
	 /*    1384*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1392*/ 0x00, 0x00, 0x00, 0x07, 0x24, 0x06, 0x06, 0x06, 
	 /*    1400*/ 0x06, 0x23, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1408*/ 0x06, 0x23, 0x23, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1416*/ 0x1a, 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x10, 0x10, 
	 /*    1424*/ 0x0f, 0x10, 0x10, 0x10, 0x0f, 0x10, 0x10, 0x11, 
	 /*    1432*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1440*/ 0x00, 0x00, 0x00, 0x07, 0x25, 0x06, 0x06, 0x06, 
	 /*    1448*/ 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1456*/ 0x06, 0x06, 0x06, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1464*/ 0x21, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x10, 
	 /*    1472*/ 0x0f, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0e, 0x16, 
	 /*    1480*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1488*/ 0x00, 0x00, 0x00, 0x00, 0x28, 0x06, 0x06, 0x06, 
	 /*    1496*/ 0x06, 0x06, 0x24, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1504*/ 0x24, 0x06, 0x06, 0x08, 0x00, 0xff, 0x00, 0x00, 
	 /*    1512*/ 0x07, 0x24, 0x23, 0x06, 0x23, 0x23, 0x23, 0x23, 
	 /*    1520*/ 0x22, 0x23, 0x23, 0x06, 0x23, 0x23, 0x23, 0x2b, 
	 /*    1528*/ 0x31, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1536*/ 0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x30, 0x30, 
	 /*    1544*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
	 /*    1552*/ 0x30, 0x30, 0x09, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1568*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x16, 
	 /*    1576*/ 0x14, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1584*/ 0x00, 0x00, 0x07, 0x2e, 0x08, 0xff, 0x00, 0x00, 
	 /*    1592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1608*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1616*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x13, 0x03, 
	 /*    1624*/ 0x03, 0x0c, 0x26, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1632*/ 0x00, 0x07, 0x2c, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    1640*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1656*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1664*/ 0x00, 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 
	 /*    1672*/ 0x03, 0x03, 0x14, 0x32, 0x09, 0x28, 0x28, 0x09, 
	 /*    1680*/ 0x00, 0x2e, 0x2a, 0x2b, 0x2b, 0x2b, 0x2e, 0x32, 
	 /*    1688*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1704*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1712*/ 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 
	 /*    1720*/ 0x03, 0x03, 0x16, 0x27, 0x0d, 0x0b, 0x0b, 0x0d, 
	 /*    1728*/ 0x29, 0x30, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2e, 
	 /*    1736*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1752*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1760*/ 0x00, 0x00, 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 
	 /*    1768*/ 0x03, 0x13, 0x2f, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1776*/ 0x1f, 0xff, 0x08, 0x2b, 0x2b, 0x2c, 0x2b, 0x2b, 
	 /*    1784*/ 0x08, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1800*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1808*/ 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 
	 /*    1816*/ 0x04, 0x08, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1824*/ 0x05, 0xff, 0x32, 0x08, 0x2b, 0x2b, 0x2b, 0x2b, 
	 /*    1832*/ 0x2b, 0x2e, 0x32, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1848*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1856*/ 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x13, 
	 /*    1864*/ 0x08, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1872*/ 0x05, 0xff, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 0x2c, 
	 /*    1880*/ 0x2b, 0x2b, 0x08, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1896*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
	 /*    1904*/ 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 
	 /*    1912*/ 0x00, 0xff, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1920*/ 0x1f, 0xff, 0x00, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 
	 /*    1928*/ 0x2c, 0x2a, 0x2b, 0x2e, 0x32, 0xff, 0x00, 0x00, 
	 /*    1936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1944*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 
	 /*    1952*/ 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 
	 /*    1960*/ 0x00, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1968*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x32, 0x08, 0x2a, 
	 /*    1976*/ 0x2b, 0x2a, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 0x00, 
	 /*    1984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1992*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x04, 0x03, 
	 /*    2000*/ 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 0x00, 
	 /*    2008*/ 0x00, 0x00, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    2016*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x00, 0x32, 0x08, 
	 /*    2024*/ 0x2b, 0x2b, 0x2a, 0x2c, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    2032*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    2040*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x03, 0x03, 
	    /*       0*/ 0x42, 0x4d, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 
	 /*       8*/ 0x00, 0x00, 0x06, 0x01, 0x00, 0x00, 0x28, 0x00, 
	 /*      16*/ 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 
	 /*      24*/ 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 
	 /*      32*/ 0x00, 0x00, 0x02, 0x09, 0x00, 0x00, 0x12, 0x0b, 
	 /*      40*/ 0x00, 0x00, 0x12, 0x0b, 0x00, 0x00, 0x34, 0x00, 
	 /*      48*/ 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*      56*/ 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 
	 /*      64*/ 0x00, 0xff, 0xe3, 0x5b, 0x00, 0xff, 0xa6, 0x43, 
	 /*      72*/ 0x00, 0xff, 0x69, 0x2a, 0x00, 0xff, 0x49, 0x1d, 
	 /*      80*/ 0x00, 0xff, 0x0e, 0x05, 0x00, 0xff, 0x1f, 0x0c, 
	 /*      88*/ 0x00, 0xff, 0x15, 0x08, 0x00, 0xff, 0x10, 0x06, 
	 /*      96*/ 0x00, 0xff, 0xf4, 0x62, 0x00, 0xff, 0xcd, 0x52, 
	 /*     104*/ 0x00, 0xff, 0xc9, 0x50, 0x00, 0xff, 0xc5, 0x4f, 
	 /*     112*/ 0x00, 0xff, 0xc3, 0x4e, 0x00, 0xff, 0xbf, 0x4c, 
	 /*     120*/ 0x00, 0xff, 0xb7, 0x49, 0x00, 0xff, 0xab, 0x45, 
	 /*     128*/ 0x00, 0xff, 0xa7, 0x43, 0x00, 0xff, 0xa2, 0x41, 
	 /*     136*/ 0x00, 0xff, 0x99, 0x3d, 0x00, 0xff, 0x94, 0x3c, 
	 /*     144*/ 0x00, 0xff, 0x87, 0x36, 0x00, 0xff, 0x86, 0x36, 
	 /*     152*/ 0x00, 0xff, 0x83, 0x35, 0x00, 0xff, 0x81, 0x33, 
	 /*     160*/ 0x00, 0xff, 0x7e, 0x33, 0x00, 0xff, 0x7b, 0x31, 
	 /*     168*/ 0x00, 0xff, 0x76, 0x2f, 0x00, 0xff, 0x6c, 0x2b, 
	 /*     176*/ 0x00, 0xff, 0x67, 0x2a, 0x00, 0xff, 0x5a, 0x24, 
	 /*     184*/ 0x00, 0xff, 0x55, 0x22, 0x00, 0xff, 0x52, 0x21, 
	 /*     192*/ 0x00, 0xff, 0x4c, 0x1e, 0x00, 0xff, 0x44, 0x1b, 
	 /*     200*/ 0x00, 0xff, 0x43, 0x1b, 0x00, 0xff, 0x3e, 0x19, 
	 /*     208*/ 0x00, 0xff, 0x3a, 0x17, 0x00, 0xff, 0x37, 0x16, 
	 /*     216*/ 0x00, 0xff, 0x32, 0x14, 0x00, 0xff, 0x2e, 0x13, 
	 /*     224*/ 0x00, 0xff, 0x2d, 0x12, 0x00, 0xff, 0x28, 0x10, 
	 /*     232*/ 0x00, 0xff, 0x26, 0x0f, 0x00, 0xff, 0x20, 0x0d, 
	 /*     240*/ 0x00, 0xff, 0x1c, 0x0b, 0x00, 0xff, 0x1b, 0x0b, 
	 /*     248*/ 0x00, 0xff, 0x09, 0x04, 0x00, 0xff, 0x04, 0x02, 
	 /*     256*/ 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
	 /*     264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     272*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     280*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     288*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     296*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     304*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     312*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     320*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     328*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 
	 /*     336*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     344*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     352*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     360*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     368*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     376*/ 0x00, 0x00, 0x00, 0x00, 0x27, 0x20, 0x20, 0x27, 
	 /*     384*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     392*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     400*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     408*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     416*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     424*/ 0x00, 0x00, 0x00, 0x2b, 0x18, 0x18, 0x18, 0x19, 
	 /*     432*/ 0x2b, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     440*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     448*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     456*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     464*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     472*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     480*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     488*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     496*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     504*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     512*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     520*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     528*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     536*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     544*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     552*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     568*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     576*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     584*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     608*/ 0x28, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     616*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     624*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     632*/ 0x00, 0x00, 0x07, 0x2e, 0x07, 0xff, 0x00, 0x00, 
	 /*     640*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x18, 
	 /*     656*/ 0x04, 0x1d, 0x09, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*     664*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     672*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     680*/ 0x00, 0x07, 0x06, 0x05, 0x21, 0x30, 0x00, 0x00, 
	 /*     688*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x19, 0x04, 
	 /*     704*/ 0x04, 0x04, 0x1d, 0x09, 0x00, 0xff, 0x00, 0x00, 
	 /*     712*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     720*/ 0x27, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     728*/ 0x07, 0x06, 0x1f, 0x05, 0x05, 0x21, 0x07, 0x00, 
	 /*     736*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x14, 0x04, 
	 /*     752*/ 0x04, 0x04, 0x14, 0x1d, 0x09, 0xff, 0x00, 0x00, 
	 /*     760*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     768*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
	 /*     776*/ 0x06, 0x05, 0x05, 0x1f, 0x05, 0x1f, 0x2e, 0x00, 
	 /*     784*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x1d, 0x04, 
	 /*     800*/ 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 0x00, 
	 /*     808*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     816*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x07, 0x06, 
	 /*     824*/ 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 0x31, 0x00, 
	 /*     832*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1c, 
	 /*     848*/ 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 
	 /*     856*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     864*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x07, 0x06, 0x1f, 
	 /*     872*/ 0x05, 0x05, 0x05, 0x05, 0x06, 0x07, 0x00, 0x00, 
	 /*     880*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     896*/ 0x1d, 0x04, 0x04, 0x04, 0x04, 0x14, 0x1d, 0x09, 
	 /*     904*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     912*/ 0x29, 0xff, 0x00, 0x00, 0x07, 0x06, 0x1f, 0x05, 
	 /*     920*/ 0x1f, 0x05, 0x1f, 0x06, 0x07, 0xff, 0x00, 0x00, 
	 /*     928*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     944*/ 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 
	 /*     952*/ 0x09, 0xff, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     960*/ 0x29, 0xff, 0x00, 0x07, 0x06, 0x05, 0x05, 0x05, 
	 /*     968*/ 0x05, 0x05, 0x06, 0x07, 0x00, 0xff, 0x00, 0x00, 
	 /*     976*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     992*/ 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 
	 /*    1000*/ 0x1d, 0x09, 0x00, 0x28, 0x18, 0x17, 0x17, 0x18, 
	 /*    1008*/ 0x27, 0xff, 0x07, 0x06, 0x05, 0x05, 0x1f, 0x05, 
	 /*    1016*/ 0x1f, 0x06, 0x07, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1024*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1032*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1040*/ 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 
	 /*    1048*/ 0x04, 0x1d, 0x09, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*    1056*/ 0x29, 0x31, 0x06, 0x1f, 0x05, 0x1f, 0x05, 0x05, 
	 /*    1064*/ 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1072*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1080*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1088*/ 0x00, 0x00, 0x00, 0x09, 0x1d, 0x14, 0x04, 0x04, 
	 /*    1096*/ 0x04, 0x04, 0x1e, 0x08, 0x05, 0x1b, 0x1b, 0x1f, 
	 /*    1104*/ 0x30, 0x24, 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 
	 /*    1112*/ 0x07, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1120*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1128*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1136*/ 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 
	 /*    1144*/ 0x04, 0x04, 0x1c, 0x32, 0x31, 0x30, 0x30, 0x31, 
	 /*    1152*/ 0x32, 0x23, 0x1f, 0x1f, 0x05, 0x1f, 0x06, 0x07, 
	 /*    1160*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1168*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1176*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1184*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 
	 /*    1192*/ 0x04, 0x16, 0x28, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1200*/ 0x00, 0x2e, 0x1f, 0x05, 0x1f, 0x06, 0x07, 0x00, 
	 /*    1208*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1216*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1224*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1232*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1e, 
	 /*    1240*/ 0x1c, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1248*/ 0x00, 0x00, 0x2e, 0x23, 0x24, 0x31, 0x00, 0x00, 
	 /*    1256*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1272*/ 0x07, 0x25, 0x22, 0x23, 0x23, 0x23, 0x23, 0x22, 
	 /*    1280*/ 0x23, 0x22, 0x06, 0x23, 0x22, 0x23, 0x23, 0x2c, 
	 /*    1288*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1296*/ 0x00, 0x00, 0x00, 0x32, 0x0a, 0x30, 0x30, 0x30, 
	 /*    1304*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x09, 
	 /*    1312*/ 0x30, 0x30, 0x30, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1320*/ 0x22, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x0e, 
	 /*    1328*/ 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x0f, 0x15, 
	 /*    1336*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1344*/ 0x00, 0x00, 0x00, 0x32, 0x27, 0x06, 0x06, 0x24, 
	 /*    1352*/ 0x06, 0x24, 0x06, 0x06, 0x06, 0x24, 0x06, 0x06, 
	 /*    1360*/ 0x06, 0x24, 0x24, 0x2f, 0x00, 0xff, 0x00, 0x00, 
	 /*    1368*/ 0x1a, 0x0f, 0x10, 0x0f, 0x10, 0x10, 0x10, 0x0f, 
	 /*    1376*/ 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x11, 
	 /*    1384*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1392*/ 0x00, 0x00, 0x00, 0x07, 0x24, 0x06, 0x06, 0x06, 
	 /*    1400*/ 0x06, 0x23, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1408*/ 0x06, 0x23, 0x23, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1416*/ 0x1a, 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x10, 0x10, 
	 /*    1424*/ 0x0f, 0x10, 0x10, 0x10, 0x0f, 0x10, 0x10, 0x11, 
	 /*    1432*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1440*/ 0x00, 0x00, 0x00, 0x07, 0x25, 0x06, 0x06, 0x06, 
	 /*    1448*/ 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1456*/ 0x06, 0x06, 0x06, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1464*/ 0x21, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x10, 
	 /*    1472*/ 0x0f, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0e, 0x16, 
	 /*    1480*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1488*/ 0x00, 0x00, 0x00, 0x00, 0x28, 0x06, 0x06, 0x06, 
	 /*    1496*/ 0x06, 0x06, 0x24, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1504*/ 0x24, 0x06, 0x06, 0x08, 0x00, 0xff, 0x00, 0x00, 
	 /*    1512*/ 0x07, 0x24, 0x23, 0x06, 0x23, 0x23, 0x23, 0x23, 
	 /*    1520*/ 0x22, 0x23, 0x23, 0x06, 0x23, 0x23, 0x23, 0x2b, 
	 /*    1528*/ 0x31, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1536*/ 0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x30, 0x30, 
	 /*    1544*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
	 /*    1552*/ 0x30, 0x30, 0x09, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1568*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x16, 
	 /*    1576*/ 0x14, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1584*/ 0x00, 0x00, 0x07, 0x2e, 0x08, 0xff, 0x00, 0x00, 
	 /*    1592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1608*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1616*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x13, 0x03, 
	 /*    1624*/ 0x03, 0x0c, 0x26, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1632*/ 0x00, 0x07, 0x2c, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    1640*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1656*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1664*/ 0x00, 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 
	 /*    1672*/ 0x03, 0x03, 0x14, 0x32, 0x09, 0x28, 0x28, 0x09, 
	 /*    1680*/ 0x00, 0x2e, 0x2a, 0x2b, 0x2b, 0x2b, 0x2e, 0x32, 
	 /*    1688*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1704*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1712*/ 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 
	 /*    1720*/ 0x03, 0x03, 0x16, 0x27, 0x0d, 0x0b, 0x0b, 0x0d, 
	 /*    1728*/ 0x29, 0x30, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2e, 
	 /*    1736*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1752*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1760*/ 0x00, 0x00, 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 
	 /*    1768*/ 0x03, 0x13, 0x2f, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1776*/ 0x1f, 0xff, 0x08, 0x2b, 0x2b, 0x2c, 0x2b, 0x2b, 
	 /*    1784*/ 0x08, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1800*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1808*/ 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 
	 /*    1816*/ 0x04, 0x08, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1824*/ 0x05, 0xff, 0x32, 0x08, 0x2b, 0x2b, 0x2b, 0x2b, 
	 /*    1832*/ 0x2b, 0x2e, 0x32, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1848*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1856*/ 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x13, 
	 /*    1864*/ 0x08, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1872*/ 0x05, 0xff, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 0x2c, 
	 /*    1880*/ 0x2b, 0x2b, 0x08, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1896*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
	 /*    1904*/ 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 
	 /*    1912*/ 0x00, 0xff, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1920*/ 0x1f, 0xff, 0x00, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 
	 /*    1928*/ 0x2c, 0x2a, 0x2b, 0x2e, 0x32, 0xff, 0x00, 0x00, 
	 /*    1936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1944*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 
	 /*    1952*/ 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 
	 /*    1960*/ 0x00, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1968*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x32, 0x08, 0x2a, 
	 /*    1976*/ 0x2b, 0x2a, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 0x00, 
	 /*    1984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1992*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x04, 0x03, 
	 /*    2000*/ 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 0x00, 
	 /*    2008*/ 0x00, 0x00, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    2016*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x00, 0x32, 0x08, 
	 /*    2024*/ 0x2b, 0x2b, 0x2a, 0x2c, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    2032*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    2040*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x03, 0x03, 
	    /*       0*/ 0x42, 0x4d, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 
	 /*       8*/ 0x00, 0x00, 0x06, 0x01, 0x00, 0x00, 0x28, 0x00, 
	 /*      16*/ 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 
	 /*      24*/ 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 
	 /*      32*/ 0x00, 0x00, 0x02, 0x09, 0x00, 0x00, 0x12, 0x0b, 
	 /*      40*/ 0x00, 0x00, 0x12, 0x0b, 0x00, 0x00, 0x34, 0x00, 
	 /*      48*/ 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*      56*/ 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 
	 /*      64*/ 0x00, 0xff, 0xe3, 0x5b, 0x00, 0xff, 0xa6, 0x43, 
	 /*      72*/ 0x00, 0xff, 0x69, 0x2a, 0x00, 0xff, 0x49, 0x1d, 
	 /*      80*/ 0x00, 0xff, 0x0e, 0x05, 0x00, 0xff, 0x1f, 0x0c, 
	 /*      88*/ 0x00, 0xff, 0x15, 0x08, 0x00, 0xff, 0x10, 0x06, 
	 /*      96*/ 0x00, 0xff, 0xf4, 0x62, 0x00, 0xff, 0xcd, 0x52, 
	 /*     104*/ 0x00, 0xff, 0xc9, 0x50, 0x00, 0xff, 0xc5, 0x4f, 
	 /*     112*/ 0x00, 0xff, 0xc3, 0x4e, 0x00, 0xff, 0xbf, 0x4c, 
	 /*     120*/ 0x00, 0xff, 0xb7, 0x49, 0x00, 0xff, 0xab, 0x45, 
	 /*     128*/ 0x00, 0xff, 0xa7, 0x43, 0x00, 0xff, 0xa2, 0x41, 
	 /*     136*/ 0x00, 0xff, 0x99, 0x3d, 0x00, 0xff, 0x94, 0x3c, 
	 /*     144*/ 0x00, 0xff, 0x87, 0x36, 0x00, 0xff, 0x86, 0x36, 
	 /*     152*/ 0x00, 0xff, 0x83, 0x35, 0x00, 0xff, 0x81, 0x33, 
	 /*     160*/ 0x00, 0xff, 0x7e, 0x33, 0x00, 0xff, 0x7b, 0x31, 
	 /*     168*/ 0x00, 0xff, 0x76, 0x2f, 0x00, 0xff, 0x6c, 0x2b, 
	 /*     176*/ 0x00, 0xff, 0x67, 0x2a, 0x00, 0xff, 0x5a, 0x24, 
	 /*     184*/ 0x00, 0xff, 0x55, 0x22, 0x00, 0xff, 0x52, 0x21, 
	 /*     192*/ 0x00, 0xff, 0x4c, 0x1e, 0x00, 0xff, 0x44, 0x1b, 
	 /*     200*/ 0x00, 0xff, 0x43, 0x1b, 0x00, 0xff, 0x3e, 0x19, 
	 /*     208*/ 0x00, 0xff, 0x3a, 0x17, 0x00, 0xff, 0x37, 0x16, 
	 /*     216*/ 0x00, 0xff, 0x32, 0x14, 0x00, 0xff, 0x2e, 0x13, 
	 /*     224*/ 0x00, 0xff, 0x2d, 0x12, 0x00, 0xff, 0x28, 0x10, 
	 /*     232*/ 0x00, 0xff, 0x26, 0x0f, 0x00, 0xff, 0x20, 0x0d, 
	 /*     240*/ 0x00, 0xff, 0x1c, 0x0b, 0x00, 0xff, 0x1b, 0x0b, 
	 /*     248*/ 0x00, 0xff, 0x09, 0x04, 0x00, 0xff, 0x04, 0x02, 
	 /*     256*/ 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
	 /*     264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     272*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     280*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     288*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     296*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     304*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     312*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     320*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     328*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 
	 /*     336*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     344*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     352*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     360*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     368*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     376*/ 0x00, 0x00, 0x00, 0x00, 0x27, 0x20, 0x20, 0x27, 
	 /*     384*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     392*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     400*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     408*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     416*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     424*/ 0x00, 0x00, 0x00, 0x2b, 0x18, 0x18, 0x18, 0x19, 
	 /*     432*/ 0x2b, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     440*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     448*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     456*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     464*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     472*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     480*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     488*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     496*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     504*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     512*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     520*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     528*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     536*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     544*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     552*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     568*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     576*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     584*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     608*/ 0x28, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     616*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     624*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     632*/ 0x00, 0x00, 0x07, 0x2e, 0x07, 0xff, 0x00, 0x00, 
	 /*     640*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x18, 
	 /*     656*/ 0x04, 0x1d, 0x09, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*     664*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     672*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     680*/ 0x00, 0x07, 0x06, 0x05, 0x21, 0x30, 0x00, 0x00, 
	 /*     688*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x19, 0x04, 
	 /*     704*/ 0x04, 0x04, 0x1d, 0x09, 0x00, 0xff, 0x00, 0x00, 
	 /*     712*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     720*/ 0x27, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     728*/ 0x07, 0x06, 0x1f, 0x05, 0x05, 0x21, 0x07, 0x00, 
	 /*     736*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x14, 0x04, 
	 /*     752*/ 0x04, 0x04, 0x14, 0x1d, 0x09, 0xff, 0x00, 0x00, 
	 /*     760*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     768*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
	 /*     776*/ 0x06, 0x05, 0x05, 0x1f, 0x05, 0x1f, 0x2e, 0x00, 
	 /*     784*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x1d, 0x04, 
	 /*     800*/ 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 0x00, 
	 /*     808*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     816*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x07, 0x06, 
	 /*     824*/ 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 0x31, 0x00, 
	 /*     832*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1c, 
	 /*     848*/ 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 
	 /*     856*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     864*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x07, 0x06, 0x1f, 
	 /*     872*/ 0x05, 0x05, 0x05, 0x05, 0x06, 0x07, 0x00, 0x00, 
	 /*     880*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     896*/ 0x1d, 0x04, 0x04, 0x04, 0x04, 0x14, 0x1d, 0x09, 
	 /*     904*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     912*/ 0x29, 0xff, 0x00, 0x00, 0x07, 0x06, 0x1f, 0x05, 
	 /*     920*/ 0x1f, 0x05, 0x1f, 0x06, 0x07, 0xff, 0x00, 0x00, 
	 /*     928*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     944*/ 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 
	 /*     952*/ 0x09, 0xff, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     960*/ 0x29, 0xff, 0x00, 0x07, 0x06, 0x05, 0x05, 0x05, 
	 /*     968*/ 0x05, 0x05, 0x06, 0x07, 0x00, 0xff, 0x00, 0x00, 
	 /*     976*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     992*/ 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 
	 /*    1000*/ 0x1d, 0x09, 0x00, 0x28, 0x18, 0x17, 0x17, 0x18, 
	 /*    1008*/ 0x27, 0xff, 0x07, 0x06, 0x05, 0x05, 0x1f, 0x05, 
	 /*    1016*/ 0x1f, 0x06, 0x07, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1024*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1032*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1040*/ 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 
	 /*    1048*/ 0x04, 0x1d, 0x09, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*    1056*/ 0x29, 0x31, 0x06, 0x1f, 0x05, 0x1f, 0x05, 0x05, 
	 /*    1064*/ 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1072*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1080*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1088*/ 0x00, 0x00, 0x00, 0x09, 0x1d, 0x14, 0x04, 0x04, 
	 /*    1096*/ 0x04, 0x04, 0x1e, 0x08, 0x05, 0x1b, 0x1b, 0x1f, 
	 /*    1104*/ 0x30, 0x24, 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 
	 /*    1112*/ 0x07, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1120*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1128*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1136*/ 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 
	 /*    1144*/ 0x04, 0x04, 0x1c, 0x32, 0x31, 0x30, 0x30, 0x31, 
	 /*    1152*/ 0x32, 0x23, 0x1f, 0x1f, 0x05, 0x1f, 0x06, 0x07, 
	 /*    1160*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1168*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1176*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1184*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 
	 /*    1192*/ 0x04, 0x16, 0x28, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1200*/ 0x00, 0x2e, 0x1f, 0x05, 0x1f, 0x06, 0x07, 0x00, 
	 /*    1208*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1216*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1224*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1232*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1e, 
	 /*    1240*/ 0x1c, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1248*/ 0x00, 0x00, 0x2e, 0x23, 0x24, 0x31, 0x00, 0x00, 
	 /*    1256*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1272*/ 0x07, 0x25, 0x22, 0x23, 0x23, 0x23, 0x23, 0x22, 
	 /*    1280*/ 0x23, 0x22, 0x06, 0x23, 0x22, 0x23, 0x23, 0x2c, 
	 /*    1288*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1296*/ 0x00, 0x00, 0x00, 0x32, 0x0a, 0x30, 0x30, 0x30, 
	 /*    1304*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x09, 
	 /*    1312*/ 0x30, 0x30, 0x30, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1320*/ 0x22, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x0e, 
	 /*    1328*/ 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x0f, 0x15, 
	 /*    1336*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1344*/ 0x00, 0x00, 0x00, 0x32, 0x27, 0x06, 0x06, 0x24, 
	 /*    1352*/ 0x06, 0x24, 0x06, 0x06, 0x06, 0x24, 0x06, 0x06, 
	 /*    1360*/ 0x06, 0x24, 0x24, 0x2f, 0x00, 0xff, 0x00, 0x00, 
	 /*    1368*/ 0x1a, 0x0f, 0x10, 0x0f, 0x10, 0x10, 0x10, 0x0f, 
	 /*    1376*/ 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x11, 
	 /*    1384*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1392*/ 0x00, 0x00, 0x00, 0x07, 0x24, 0x06, 0x06, 0x06, 
	 /*    1400*/ 0x06, 0x23, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1408*/ 0x06, 0x23, 0x23, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1416*/ 0x1a, 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x10, 0x10, 
	 /*    1424*/ 0x0f, 0x10, 0x10, 0x10, 0x0f, 0x10, 0x10, 0x11, 
	 /*    1432*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1440*/ 0x00, 0x00, 0x00, 0x07, 0x25, 0x06, 0x06, 0x06, 
	 /*    1448*/ 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1456*/ 0x06, 0x06, 0x06, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1464*/ 0x21, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x10, 
	 /*    1472*/ 0x0f, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0e, 0x16, 
	 /*    1480*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1488*/ 0x00, 0x00, 0x00, 0x00, 0x28, 0x06, 0x06, 0x06, 
	 /*    1496*/ 0x06, 0x06, 0x24, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1504*/ 0x24, 0x06, 0x06, 0x08, 0x00, 0xff, 0x00, 0x00, 
	 /*    1512*/ 0x07, 0x24, 0x23, 0x06, 0x23, 0x23, 0x23, 0x23, 
	 /*    1520*/ 0x22, 0x23, 0x23, 0x06, 0x23, 0x23, 0x23, 0x2b, 
	 /*    1528*/ 0x31, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1536*/ 0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x30, 0x30, 
	 /*    1544*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
	 /*    1552*/ 0x30, 0x30, 0x09, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1568*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x16, 
	 /*    1576*/ 0x14, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1584*/ 0x00, 0x00, 0x07, 0x2e, 0x08, 0xff, 0x00, 0x00, 
	 /*    1592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1608*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1616*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x13, 0x03, 
	 /*    1624*/ 0x03, 0x0c, 0x26, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1632*/ 0x00, 0x07, 0x2c, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    1640*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1656*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1664*/ 0x00, 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 
	 /*    1672*/ 0x03, 0x03, 0x14, 0x32, 0x09, 0x28, 0x28, 0x09, 
	 /*    1680*/ 0x00, 0x2e, 0x2a, 0x2b, 0x2b, 0x2b, 0x2e, 0x32, 
	 /*    1688*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1704*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1712*/ 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 
	 /*    1720*/ 0x03, 0x03, 0x16, 0x27, 0x0d, 0x0b, 0x0b, 0x0d, 
	 /*    1728*/ 0x29, 0x30, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2e, 
	 /*    1736*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1752*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1760*/ 0x00, 0x00, 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 
	 /*    1768*/ 0x03, 0x13, 0x2f, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1776*/ 0x1f, 0xff, 0x08, 0x2b, 0x2b, 0x2c, 0x2b, 0x2b, 
	 /*    1784*/ 0x08, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1800*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1808*/ 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 
	 /*    1816*/ 0x04, 0x08, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1824*/ 0x05, 0xff, 0x32, 0x08, 0x2b, 0x2b, 0x2b, 0x2b, 
	 /*    1832*/ 0x2b, 0x2e, 0x32, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1848*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1856*/ 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x13, 
	 /*    1864*/ 0x08, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1872*/ 0x05, 0xff, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 0x2c, 
	 /*    1880*/ 0x2b, 0x2b, 0x08, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1896*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
	 /*    1904*/ 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 
	 /*    1912*/ 0x00, 0xff, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1920*/ 0x1f, 0xff, 0x00, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 
	 /*    1928*/ 0x2c, 0x2a, 0x2b, 0x2e, 0x32, 0xff, 0x00, 0x00, 
	 /*    1936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1944*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 
	 /*    1952*/ 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 
	 /*    1960*/ 0x00, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1968*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x32, 0x08, 0x2a, 
	 /*    1976*/ 0x2b, 0x2a, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 0x00, 
	 /*    1984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1992*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x04, 0x03, 
	 /*    2000*/ 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 0x00, 
	 /*    2008*/ 0x00, 0x00, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    2016*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x00, 0x32, 0x08, 
	 /*    2024*/ 0x2b, 0x2b, 0x2a, 0x2c, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    2032*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    2040*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x03, 0x03, 
	    /*       0*/ 0x42, 0x4d, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 
	 /*       8*/ 0x00, 0x00, 0x06, 0x01, 0x00, 0x00, 0x28, 0x00, 
	 /*      16*/ 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 
	 /*      24*/ 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 
	 /*      32*/ 0x00, 0x00, 0x02, 0x09, 0x00, 0x00, 0x12, 0x0b, 
	 /*      40*/ 0x00, 0x00, 0x12, 0x0b, 0x00, 0x00, 0x34, 0x00, 
	 /*      48*/ 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*      56*/ 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 
	 /*      64*/ 0x00, 0xff, 0xe3, 0x5b, 0x00, 0xff, 0xa6, 0x43, 
	 /*      72*/ 0x00, 0xff, 0x69, 0x2a, 0x00, 0xff, 0x49, 0x1d, 
	 /*      80*/ 0x00, 0xff, 0x0e, 0x05, 0x00, 0xff, 0x1f, 0x0c, 
	 /*      88*/ 0x00, 0xff, 0x15, 0x08, 0x00, 0xff, 0x10, 0x06, 
	 /*      96*/ 0x00, 0xff, 0xf4, 0x62, 0x00, 0xff, 0xcd, 0x52, 
	 /*     104*/ 0x00, 0xff, 0xc9, 0x50, 0x00, 0xff, 0xc5, 0x4f, 
	 /*     112*/ 0x00, 0xff, 0xc3, 0x4e, 0x00, 0xff, 0xbf, 0x4c, 
	 /*     120*/ 0x00, 0xff, 0xb7, 0x49, 0x00, 0xff, 0xab, 0x45, 
	 /*     128*/ 0x00, 0xff, 0xa7, 0x43, 0x00, 0xff, 0xa2, 0x41, 
	 /*     136*/ 0x00, 0xff, 0x99, 0x3d, 0x00, 0xff, 0x94, 0x3c, 
	 /*     144*/ 0x00, 0xff, 0x87, 0x36, 0x00, 0xff, 0x86, 0x36, 
	 /*     152*/ 0x00, 0xff, 0x83, 0x35, 0x00, 0xff, 0x81, 0x33, 
	 /*     160*/ 0x00, 0xff, 0x7e, 0x33, 0x00, 0xff, 0x7b, 0x31, 
	 /*     168*/ 0x00, 0xff, 0x76, 0x2f, 0x00, 0xff, 0x6c, 0x2b, 
	 /*     176*/ 0x00, 0xff, 0x67, 0x2a, 0x00, 0xff, 0x5a, 0x24, 
	 /*     184*/ 0x00, 0xff, 0x55, 0x22, 0x00, 0xff, 0x52, 0x21, 
	 /*     192*/ 0x00, 0xff, 0x4c, 0x1e, 0x00, 0xff, 0x44, 0x1b, 
	 /*     200*/ 0x00, 0xff, 0x43, 0x1b, 0x00, 0xff, 0x3e, 0x19, 
	 /*     208*/ 0x00, 0xff, 0x3a, 0x17, 0x00, 0xff, 0x37, 0x16, 
	 /*     216*/ 0x00, 0xff, 0x32, 0x14, 0x00, 0xff, 0x2e, 0x13, 
	 /*     224*/ 0x00, 0xff, 0x2d, 0x12, 0x00, 0xff, 0x28, 0x10, 
	 /*     232*/ 0x00, 0xff, 0x26, 0x0f, 0x00, 0xff, 0x20, 0x0d, 
	 /*     240*/ 0x00, 0xff, 0x1c, 0x0b, 0x00, 0xff, 0x1b, 0x0b, 
	 /*     248*/ 0x00, 0xff, 0x09, 0x04, 0x00, 0xff, 0x04, 0x02, 
	 /*     256*/ 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
	 /*     264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     272*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     280*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     288*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     296*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     304*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     312*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     320*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     328*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 
	 /*     336*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     344*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     352*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     360*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     368*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     376*/ 0x00, 0x00, 0x00, 0x00, 0x27, 0x20, 0x20, 0x27, 
	 /*     384*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     392*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     400*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     408*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     416*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     424*/ 0x00, 0x00, 0x00, 0x2b, 0x18, 0x18, 0x18, 0x19, 
	 /*     432*/ 0x2b, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     440*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     448*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     456*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     464*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     472*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     480*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     488*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     496*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     504*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     512*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     520*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     528*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     536*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     544*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     552*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     568*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     576*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     584*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     608*/ 0x28, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     616*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     624*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     632*/ 0x00, 0x00, 0x07, 0x2e, 0x07, 0xff, 0x00, 0x00, 
	 /*     640*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x18, 
	 /*     656*/ 0x04, 0x1d, 0x09, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*     664*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     672*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     680*/ 0x00, 0x07, 0x06, 0x05, 0x21, 0x30, 0x00, 0x00, 
	 /*     688*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x19, 0x04, 
	 /*     704*/ 0x04, 0x04, 0x1d, 0x09, 0x00, 0xff, 0x00, 0x00, 
	 /*     712*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     720*/ 0x27, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     728*/ 0x07, 0x06, 0x1f, 0x05, 0x05, 0x21, 0x07, 0x00, 
	 /*     736*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x14, 0x04, 
	 /*     752*/ 0x04, 0x04, 0x14, 0x1d, 0x09, 0xff, 0x00, 0x00, 
	 /*     760*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     768*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
	 /*     776*/ 0x06, 0x05, 0x05, 0x1f, 0x05, 0x1f, 0x2e, 0x00, 
	 /*     784*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x1d, 0x04, 
	 /*     800*/ 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 0x00, 
	 /*     808*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     816*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x07, 0x06, 
	 /*     824*/ 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 0x31, 0x00, 
	 /*     832*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1c, 
	 /*     848*/ 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 
	 /*     856*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     864*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x07, 0x06, 0x1f, 
	 /*     872*/ 0x05, 0x05, 0x05, 0x05, 0x06, 0x07, 0x00, 0x00, 
	 /*     880*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     896*/ 0x1d, 0x04, 0x04, 0x04, 0x04, 0x14, 0x1d, 0x09, 
	 /*     904*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     912*/ 0x29, 0xff, 0x00, 0x00, 0x07, 0x06, 0x1f, 0x05, 
	 /*     920*/ 0x1f, 0x05, 0x1f, 0x06, 0x07, 0xff, 0x00, 0x00, 
	 /*     928*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     944*/ 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 
	 /*     952*/ 0x09, 0xff, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     960*/ 0x29, 0xff, 0x00, 0x07, 0x06, 0x05, 0x05, 0x05, 
	 /*     968*/ 0x05, 0x05, 0x06, 0x07, 0x00, 0xff, 0x00, 0x00, 
	 /*     976*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     992*/ 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 
	 /*    1000*/ 0x1d, 0x09, 0x00, 0x28, 0x18, 0x17, 0x17, 0x18, 
	 /*    1008*/ 0x27, 0xff, 0x07, 0x06, 0x05, 0x05, 0x1f, 0x05, 
	 /*    1016*/ 0x1f, 0x06, 0x07, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1024*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1032*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1040*/ 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 
	 /*    1048*/ 0x04, 0x1d, 0x09, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*    1056*/ 0x29, 0x31, 0x06, 0x1f, 0x05, 0x1f, 0x05, 0x05, 
	 /*    1064*/ 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1072*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1080*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1088*/ 0x00, 0x00, 0x00, 0x09, 0x1d, 0x14, 0x04, 0x04, 
	 /*    1096*/ 0x04, 0x04, 0x1e, 0x08, 0x05, 0x1b, 0x1b, 0x1f, 
	 /*    1104*/ 0x30, 0x24, 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 
	 /*    1112*/ 0x07, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1120*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1128*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1136*/ 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 
	 /*    1144*/ 0x04, 0x04, 0x1c, 0x32, 0x31, 0x30, 0x30, 0x31, 
	 /*    1152*/ 0x32, 0x23, 0x1f, 0x1f, 0x05, 0x1f, 0x06, 0x07, 
	 /*    1160*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1168*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1176*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1184*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 
	 /*    1192*/ 0x04, 0x16, 0x28, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1200*/ 0x00, 0x2e, 0x1f, 0x05, 0x1f, 0x06, 0x07, 0x00, 
	 /*    1208*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1216*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1224*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1232*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1e, 
	 /*    1240*/ 0x1c, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1248*/ 0x00, 0x00, 0x2e, 0x23, 0x24, 0x31, 0x00, 0x00, 
	 /*    1256*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1272*/ 0x07, 0x25, 0x22, 0x23, 0x23, 0x23, 0x23, 0x22, 
	 /*    1280*/ 0x23, 0x22, 0x06, 0x23, 0x22, 0x23, 0x23, 0x2c, 
	 /*    1288*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1296*/ 0x00, 0x00, 0x00, 0x32, 0x0a, 0x30, 0x30, 0x30, 
	 /*    1304*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x09, 
	 /*    1312*/ 0x30, 0x30, 0x30, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1320*/ 0x22, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x0e, 
	 /*    1328*/ 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x0f, 0x15, 
	 /*    1336*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1344*/ 0x00, 0x00, 0x00, 0x32, 0x27, 0x06, 0x06, 0x24, 
	 /*    1352*/ 0x06, 0x24, 0x06, 0x06, 0x06, 0x24, 0x06, 0x06, 
	 /*    1360*/ 0x06, 0x24, 0x24, 0x2f, 0x00, 0xff, 0x00, 0x00, 
	 /*    1368*/ 0x1a, 0x0f, 0x10, 0x0f, 0x10, 0x10, 0x10, 0x0f, 
	 /*    1376*/ 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x11, 
	 /*    1384*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1392*/ 0x00, 0x00, 0x00, 0x07, 0x24, 0x06, 0x06, 0x06, 
	 /*    1400*/ 0x06, 0x23, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1408*/ 0x06, 0x23, 0x23, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1416*/ 0x1a, 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x10, 0x10, 
	 /*    1424*/ 0x0f, 0x10, 0x10, 0x10, 0x0f, 0x10, 0x10, 0x11, 
	 /*    1432*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1440*/ 0x00, 0x00, 0x00, 0x07, 0x25, 0x06, 0x06, 0x06, 
	 /*    1448*/ 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1456*/ 0x06, 0x06, 0x06, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1464*/ 0x21, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x10, 
	 /*    1472*/ 0x0f, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0e, 0x16, 
	 /*    1480*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1488*/ 0x00, 0x00, 0x00, 0x00, 0x28, 0x06, 0x06, 0x06, 
	 /*    1496*/ 0x06, 0x06, 0x24, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1504*/ 0x24, 0x06, 0x06, 0x08, 0x00, 0xff, 0x00, 0x00, 
	 /*    1512*/ 0x07, 0x24, 0x23, 0x06, 0x23, 0x23, 0x23, 0x23, 
	 /*    1520*/ 0x22, 0x23, 0x23, 0x06, 0x23, 0x23, 0x23, 0x2b, 
	 /*    1528*/ 0x31, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1536*/ 0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x30, 0x30, 
	 /*    1544*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
	 /*    1552*/ 0x30, 0x30, 0x09, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1568*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x16, 
	 /*    1576*/ 0x14, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1584*/ 0x00, 0x00, 0x07, 0x2e, 0x08, 0xff, 0x00, 0x00, 
	 /*    1592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1608*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1616*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x13, 0x03, 
	 /*    1624*/ 0x03, 0x0c, 0x26, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1632*/ 0x00, 0x07, 0x2c, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    1640*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1656*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1664*/ 0x00, 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 
	 /*    1672*/ 0x03, 0x03, 0x14, 0x32, 0x09, 0x28, 0x28, 0x09, 
	 /*    1680*/ 0x00, 0x2e, 0x2a, 0x2b, 0x2b, 0x2b, 0x2e, 0x32, 
	 /*    1688*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1704*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1712*/ 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 
	 /*    1720*/ 0x03, 0x03, 0x16, 0x27, 0x0d, 0x0b, 0x0b, 0x0d, 
	 /*    1728*/ 0x29, 0x30, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2e, 
	 /*    1736*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1752*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1760*/ 0x00, 0x00, 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 
	 /*    1768*/ 0x03, 0x13, 0x2f, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1776*/ 0x1f, 0xff, 0x08, 0x2b, 0x2b, 0x2c, 0x2b, 0x2b, 
	 /*    1784*/ 0x08, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1800*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1808*/ 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 
	 /*    1816*/ 0x04, 0x08, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1824*/ 0x05, 0xff, 0x32, 0x08, 0x2b, 0x2b, 0x2b, 0x2b, 
	 /*    1832*/ 0x2b, 0x2e, 0x32, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1848*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1856*/ 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x13, 
	 /*    1864*/ 0x08, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1872*/ 0x05, 0xff, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 0x2c, 
	 /*    1880*/ 0x2b, 0x2b, 0x08, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1896*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
	 /*    1904*/ 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 
	 /*    1912*/ 0x00, 0xff, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1920*/ 0x1f, 0xff, 0x00, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 
	 /*    1928*/ 0x2c, 0x2a, 0x2b, 0x2e, 0x32, 0xff, 0x00, 0x00, 
	 /*    1936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1944*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 
	 /*    1952*/ 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 
	 /*    1960*/ 0x00, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1968*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x32, 0x08, 0x2a, 
	 /*    1976*/ 0x2b, 0x2a, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 0x00, 
	 /*    1984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1992*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x04, 0x03, 
	 /*    2000*/ 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 0x00, 
	 /*    2008*/ 0x00, 0x00, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    2016*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x00, 0x32, 0x08, 
	 /*    2024*/ 0x2b, 0x2b, 0x2a, 0x2c, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    2032*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    2040*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x03, 0x03, 
	    /*       0*/ 0x42, 0x4d, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 
	 /*       8*/ 0x00, 0x00, 0x06, 0x01, 0x00, 0x00, 0x28, 0x00, 
	 /*      16*/ 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 
	 /*      24*/ 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 
	 /*      32*/ 0x00, 0x00, 0x02, 0x09, 0x00, 0x00, 0x12, 0x0b, 
	 /*      40*/ 0x00, 0x00, 0x12, 0x0b, 0x00, 0x00, 0x34, 0x00, 
	 /*      48*/ 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*      56*/ 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 
	 /*      64*/ 0x00, 0xff, 0xe3, 0x5b, 0x00, 0xff, 0xa6, 0x43, 
	 /*      72*/ 0x00, 0xff, 0x69, 0x2a, 0x00, 0xff, 0x49, 0x1d, 
	 /*      80*/ 0x00, 0xff, 0x0e, 0x05, 0x00, 0xff, 0x1f, 0x0c, 
	 /*      88*/ 0x00, 0xff, 0x15, 0x08, 0x00, 0xff, 0x10, 0x06, 
	 /*      96*/ 0x00, 0xff, 0xf4, 0x62, 0x00, 0xff, 0xcd, 0x52, 
	 /*     104*/ 0x00, 0xff, 0xc9, 0x50, 0x00, 0xff, 0xc5, 0x4f, 
	 /*     112*/ 0x00, 0xff, 0xc3, 0x4e, 0x00, 0xff, 0xbf, 0x4c, 
	 /*     120*/ 0x00, 0xff, 0xb7, 0x49, 0x00, 0xff, 0xab, 0x45, 
	 /*     128*/ 0x00, 0xff, 0xa7, 0x43, 0x00, 0xff, 0xa2, 0x41, 
	 /*     136*/ 0x00, 0xff, 0x99, 0x3d, 0x00, 0xff, 0x94, 0x3c, 
	 /*     144*/ 0x00, 0xff, 0x87, 0x36, 0x00, 0xff, 0x86, 0x36, 
	 /*     152*/ 0x00, 0xff, 0x83, 0x35, 0x00, 0xff, 0x81, 0x33, 
	 /*     160*/ 0x00, 0xff, 0x7e, 0x33, 0x00, 0xff, 0x7b, 0x31, 
	 /*     168*/ 0x00, 0xff, 0x76, 0x2f, 0x00, 0xff, 0x6c, 0x2b, 
	 /*     176*/ 0x00, 0xff, 0x67, 0x2a, 0x00, 0xff, 0x5a, 0x24, 
	 /*     184*/ 0x00, 0xff, 0x55, 0x22, 0x00, 0xff, 0x52, 0x21, 
	 /*     192*/ 0x00, 0xff, 0x4c, 0x1e, 0x00, 0xff, 0x44, 0x1b, 
	 /*     200*/ 0x00, 0xff, 0x43, 0x1b, 0x00, 0xff, 0x3e, 0x19, 
	 /*     208*/ 0x00, 0xff, 0x3a, 0x17, 0x00, 0xff, 0x37, 0x16, 
	 /*     216*/ 0x00, 0xff, 0x32, 0x14, 0x00, 0xff, 0x2e, 0x13, 
	 /*     224*/ 0x00, 0xff, 0x2d, 0x12, 0x00, 0xff, 0x28, 0x10, 
	 /*     232*/ 0x00, 0xff, 0x26, 0x0f, 0x00, 0xff, 0x20, 0x0d, 
	 /*     240*/ 0x00, 0xff, 0x1c, 0x0b, 0x00, 0xff, 0x1b, 0x0b, 
	 /*     248*/ 0x00, 0xff, 0x09, 0x04, 0x00, 0xff, 0x04, 0x02, 
	 /*     256*/ 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
	 /*     264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     272*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     280*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     288*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     296*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     304*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     312*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     320*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     328*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 
	 /*     336*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     344*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     352*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     360*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     368*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     376*/ 0x00, 0x00, 0x00, 0x00, 0x27, 0x20, 0x20, 0x27, 
	 /*     384*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     392*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     400*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     408*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     416*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     424*/ 0x00, 0x00, 0x00, 0x2b, 0x18, 0x18, 0x18, 0x19, 
	 /*     432*/ 0x2b, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     440*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     448*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     456*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     464*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     472*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     480*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     488*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     496*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     504*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     512*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     520*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     528*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     536*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     544*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     552*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     568*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     576*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     584*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     608*/ 0x28, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     616*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     624*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     632*/ 0x00, 0x00, 0x07, 0x2e, 0x07, 0xff, 0x00, 0x00, 
	 /*     640*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x18, 
	 /*     656*/ 0x04, 0x1d, 0x09, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*     664*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     672*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     680*/ 0x00, 0x07, 0x06, 0x05, 0x21, 0x30, 0x00, 0x00, 
	 /*     688*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x19, 0x04, 
	 /*     704*/ 0x04, 0x04, 0x1d, 0x09, 0x00, 0xff, 0x00, 0x00, 
	 /*     712*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     720*/ 0x27, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     728*/ 0x07, 0x06, 0x1f, 0x05, 0x05, 0x21, 0x07, 0x00, 
	 /*     736*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x14, 0x04, 
	 /*     752*/ 0x04, 0x04, 0x14, 0x1d, 0x09, 0xff, 0x00, 0x00, 
	 /*     760*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     768*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
	 /*     776*/ 0x06, 0x05, 0x05, 0x1f, 0x05, 0x1f, 0x2e, 0x00, 
	 /*     784*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x1d, 0x04, 
	 /*     800*/ 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 0x00, 
	 /*     808*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     816*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x07, 0x06, 
	 /*     824*/ 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 0x31, 0x00, 
	 /*     832*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1c, 
	 /*     848*/ 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 
	 /*     856*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     864*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x07, 0x06, 0x1f, 
	 /*     872*/ 0x05, 0x05, 0x05, 0x05, 0x06, 0x07, 0x00, 0x00, 
	 /*     880*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     896*/ 0x1d, 0x04, 0x04, 0x04, 0x04, 0x14, 0x1d, 0x09, 
	 /*     904*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     912*/ 0x29, 0xff, 0x00, 0x00, 0x07, 0x06, 0x1f, 0x05, 
	 /*     920*/ 0x1f, 0x05, 0x1f, 0x06, 0x07, 0xff, 0x00, 0x00, 
	 /*     928*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     944*/ 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 
	 /*     952*/ 0x09, 0xff, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     960*/ 0x29, 0xff, 0x00, 0x07, 0x06, 0x05, 0x05, 0x05, 
	 /*     968*/ 0x05, 0x05, 0x06, 0x07, 0x00, 0xff, 0x00, 0x00, 
	 /*     976*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     992*/ 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 
	 /*    1000*/ 0x1d, 0x09, 0x00, 0x28, 0x18, 0x17, 0x17, 0x18, 
	 /*    1008*/ 0x27, 0xff, 0x07, 0x06, 0x05, 0x05, 0x1f, 0x05, 
	 /*    1016*/ 0x1f, 0x06, 0x07, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1024*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1032*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1040*/ 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 
	 /*    1048*/ 0x04, 0x1d, 0x09, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*    1056*/ 0x29, 0x31, 0x06, 0x1f, 0x05, 0x1f, 0x05, 0x05, 
	 /*    1064*/ 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1072*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1080*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1088*/ 0x00, 0x00, 0x00, 0x09, 0x1d, 0x14, 0x04, 0x04, 
	 /*    1096*/ 0x04, 0x04, 0x1e, 0x08, 0x05, 0x1b, 0x1b, 0x1f, 
	 /*    1104*/ 0x30, 0x24, 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 
	 /*    1112*/ 0x07, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1120*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1128*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1136*/ 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 
	 /*    1144*/ 0x04, 0x04, 0x1c, 0x32, 0x31, 0x30, 0x30, 0x31, 
	 /*    1152*/ 0x32, 0x23, 0x1f, 0x1f, 0x05, 0x1f, 0x06, 0x07, 
	 /*    1160*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1168*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1176*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1184*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 
	 /*    1192*/ 0x04, 0x16, 0x28, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1200*/ 0x00, 0x2e, 0x1f, 0x05, 0x1f, 0x06, 0x07, 0x00, 
	 /*    1208*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1216*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1224*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1232*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1e, 
	 /*    1240*/ 0x1c, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1248*/ 0x00, 0x00, 0x2e, 0x23, 0x24, 0x31, 0x00, 0x00, 
	 /*    1256*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1272*/ 0x07, 0x25, 0x22, 0x23, 0x23, 0x23, 0x23, 0x22, 
	 /*    1280*/ 0x23, 0x22, 0x06, 0x23, 0x22, 0x23, 0x23, 0x2c, 
	 /*    1288*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1296*/ 0x00, 0x00, 0x00, 0x32, 0x0a, 0x30, 0x30, 0x30, 
	 /*    1304*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x09, 
	 /*    1312*/ 0x30, 0x30, 0x30, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1320*/ 0x22, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x0e, 
	 /*    1328*/ 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x0f, 0x15, 
	 /*    1336*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1344*/ 0x00, 0x00, 0x00, 0x32, 0x27, 0x06, 0x06, 0x24, 
	 /*    1352*/ 0x06, 0x24, 0x06, 0x06, 0x06, 0x24, 0x06, 0x06, 
	 /*    1360*/ 0x06, 0x24, 0x24, 0x2f, 0x00, 0xff, 0x00, 0x00, 
	 /*    1368*/ 0x1a, 0x0f, 0x10, 0x0f, 0x10, 0x10, 0x10, 0x0f, 
	 /*    1376*/ 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x11, 
	 /*    1384*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1392*/ 0x00, 0x00, 0x00, 0x07, 0x24, 0x06, 0x06, 0x06, 
	 /*    1400*/ 0x06, 0x23, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1408*/ 0x06, 0x23, 0x23, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1416*/ 0x1a, 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x10, 0x10, 
	 /*    1424*/ 0x0f, 0x10, 0x10, 0x10, 0x0f, 0x10, 0x10, 0x11, 
	 /*    1432*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1440*/ 0x00, 0x00, 0x00, 0x07, 0x25, 0x06, 0x06, 0x06, 
	 /*    1448*/ 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1456*/ 0x06, 0x06, 0x06, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1464*/ 0x21, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x10, 
	 /*    1472*/ 0x0f, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0e, 0x16, 
	 /*    1480*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1488*/ 0x00, 0x00, 0x00, 0x00, 0x28, 0x06, 0x06, 0x06, 
	 /*    1496*/ 0x06, 0x06, 0x24, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1504*/ 0x24, 0x06, 0x06, 0x08, 0x00, 0xff, 0x00, 0x00, 
	 /*    1512*/ 0x07, 0x24, 0x23, 0x06, 0x23, 0x23, 0x23, 0x23, 
	 /*    1520*/ 0x22, 0x23, 0x23, 0x06, 0x23, 0x23, 0x23, 0x2b, 
	 /*    1528*/ 0x31, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1536*/ 0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x30, 0x30, 
	 /*    1544*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
	 /*    1552*/ 0x30, 0x30, 0x09, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1568*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x16, 
	 /*    1576*/ 0x14, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1584*/ 0x00, 0x00, 0x07, 0x2e, 0x08, 0xff, 0x00, 0x00, 
	 /*    1592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1608*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1616*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x13, 0x03, 
	 /*    1624*/ 0x03, 0x0c, 0x26, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1632*/ 0x00, 0x07, 0x2c, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    1640*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1656*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1664*/ 0x00, 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 
	 /*    1672*/ 0x03, 0x03, 0x14, 0x32, 0x09, 0x28, 0x28, 0x09, 
	 /*    1680*/ 0x00, 0x2e, 0x2a, 0x2b, 0x2b, 0x2b, 0x2e, 0x32, 
	 /*    1688*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1704*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1712*/ 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 
	 /*    1720*/ 0x03, 0x03, 0x16, 0x27, 0x0d, 0x0b, 0x0b, 0x0d, 
	 /*    1728*/ 0x29, 0x30, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2e, 
	 /*    1736*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1752*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1760*/ 0x00, 0x00, 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 
	 /*    1768*/ 0x03, 0x13, 0x2f, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1776*/ 0x1f, 0xff, 0x08, 0x2b, 0x2b, 0x2c, 0x2b, 0x2b, 
	 /*    1784*/ 0x08, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1800*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1808*/ 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 
	 /*    1816*/ 0x04, 0x08, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1824*/ 0x05, 0xff, 0x32, 0x08, 0x2b, 0x2b, 0x2b, 0x2b, 
	 /*    1832*/ 0x2b, 0x2e, 0x32, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1848*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1856*/ 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x13, 
	 /*    1864*/ 0x08, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1872*/ 0x05, 0xff, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 0x2c, 
	 /*    1880*/ 0x2b, 0x2b, 0x08, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1896*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
	 /*    1904*/ 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 
	 /*    1912*/ 0x00, 0xff, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1920*/ 0x1f, 0xff, 0x00, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 
	 /*    1928*/ 0x2c, 0x2a, 0x2b, 0x2e, 0x32, 0xff, 0x00, 0x00, 
	 /*    1936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1944*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 
	 /*    1952*/ 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 
	 /*    1960*/ 0x00, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1968*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x32, 0x08, 0x2a, 
	 /*    1976*/ 0x2b, 0x2a, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 0x00, 
	 /*    1984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1992*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x04, 0x03, 
	 /*    2000*/ 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 0x00, 
	 /*    2008*/ 0x00, 0x00, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    2016*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x00, 0x32, 0x08, 
	 /*    2024*/ 0x2b, 0x2b, 0x2a, 0x2c, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    2032*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    2040*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x03, 0x03, 
	    /*       0*/ 0x42, 0x4d, 0x08, 0x0a, 0x00, 0x00, 0x00, 0x00, 
	 /*       8*/ 0x00, 0x00, 0x06, 0x01, 0x00, 0x00, 0x28, 0x00, 
	 /*      16*/ 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x30, 0x00, 
	 /*      24*/ 0x00, 0x00, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 
	 /*      32*/ 0x00, 0x00, 0x02, 0x09, 0x00, 0x00, 0x12, 0x0b, 
	 /*      40*/ 0x00, 0x00, 0x12, 0x0b, 0x00, 0x00, 0x34, 0x00, 
	 /*      48*/ 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*      56*/ 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x66, 
	 /*      64*/ 0x00, 0xff, 0xe3, 0x5b, 0x00, 0xff, 0xa6, 0x43, 
	 /*      72*/ 0x00, 0xff, 0x69, 0x2a, 0x00, 0xff, 0x49, 0x1d, 
	 /*      80*/ 0x00, 0xff, 0x0e, 0x05, 0x00, 0xff, 0x1f, 0x0c, 
	 /*      88*/ 0x00, 0xff, 0x15, 0x08, 0x00, 0xff, 0x10, 0x06, 
	 /*      96*/ 0x00, 0xff, 0xf4, 0x62, 0x00, 0xff, 0xcd, 0x52, 
	 /*     104*/ 0x00, 0xff, 0xc9, 0x50, 0x00, 0xff, 0xc5, 0x4f, 
	 /*     112*/ 0x00, 0xff, 0xc3, 0x4e, 0x00, 0xff, 0xbf, 0x4c, 
	 /*     120*/ 0x00, 0xff, 0xb7, 0x49, 0x00, 0xff, 0xab, 0x45, 
	 /*     128*/ 0x00, 0xff, 0xa7, 0x43, 0x00, 0xff, 0xa2, 0x41, 
	 /*     136*/ 0x00, 0xff, 0x99, 0x3d, 0x00, 0xff, 0x94, 0x3c, 
	 /*     144*/ 0x00, 0xff, 0x87, 0x36, 0x00, 0xff, 0x86, 0x36, 
	 /*     152*/ 0x00, 0xff, 0x83, 0x35, 0x00, 0xff, 0x81, 0x33, 
	 /*     160*/ 0x00, 0xff, 0x7e, 0x33, 0x00, 0xff, 0x7b, 0x31, 
	 /*     168*/ 0x00, 0xff, 0x76, 0x2f, 0x00, 0xff, 0x6c, 0x2b, 
	 /*     176*/ 0x00, 0xff, 0x67, 0x2a, 0x00, 0xff, 0x5a, 0x24, 
	 /*     184*/ 0x00, 0xff, 0x55, 0x22, 0x00, 0xff, 0x52, 0x21, 
	 /*     192*/ 0x00, 0xff, 0x4c, 0x1e, 0x00, 0xff, 0x44, 0x1b, 
	 /*     200*/ 0x00, 0xff, 0x43, 0x1b, 0x00, 0xff, 0x3e, 0x19, 
	 /*     208*/ 0x00, 0xff, 0x3a, 0x17, 0x00, 0xff, 0x37, 0x16, 
	 /*     216*/ 0x00, 0xff, 0x32, 0x14, 0x00, 0xff, 0x2e, 0x13, 
	 /*     224*/ 0x00, 0xff, 0x2d, 0x12, 0x00, 0xff, 0x28, 0x10, 
	 /*     232*/ 0x00, 0xff, 0x26, 0x0f, 0x00, 0xff, 0x20, 0x0d, 
	 /*     240*/ 0x00, 0xff, 0x1c, 0x0b, 0x00, 0xff, 0x1b, 0x0b, 
	 /*     248*/ 0x00, 0xff, 0x09, 0x04, 0x00, 0xff, 0x04, 0x02, 
	 /*     256*/ 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
	 /*     264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     272*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     280*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     288*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     296*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     304*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     312*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     320*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     328*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 
	 /*     336*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     344*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     352*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     360*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     368*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     376*/ 0x00, 0x00, 0x00, 0x00, 0x27, 0x20, 0x20, 0x27, 
	 /*     384*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     392*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     400*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     408*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     416*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     424*/ 0x00, 0x00, 0x00, 0x2b, 0x18, 0x18, 0x18, 0x19, 
	 /*     432*/ 0x2b, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     440*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     448*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     456*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     464*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     472*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     480*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     488*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     496*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     504*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     512*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     520*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     528*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     536*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     544*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     552*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     568*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     576*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     584*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     608*/ 0x28, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     616*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     624*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     632*/ 0x00, 0x00, 0x07, 0x2e, 0x07, 0xff, 0x00, 0x00, 
	 /*     640*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2c, 0x18, 
	 /*     656*/ 0x04, 0x1d, 0x09, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*     664*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     672*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     680*/ 0x00, 0x07, 0x06, 0x05, 0x21, 0x30, 0x00, 0x00, 
	 /*     688*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x19, 0x04, 
	 /*     704*/ 0x04, 0x04, 0x1d, 0x09, 0x00, 0xff, 0x00, 0x00, 
	 /*     712*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     720*/ 0x27, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     728*/ 0x07, 0x06, 0x1f, 0x05, 0x05, 0x21, 0x07, 0x00, 
	 /*     736*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x14, 0x04, 
	 /*     752*/ 0x04, 0x04, 0x14, 0x1d, 0x09, 0xff, 0x00, 0x00, 
	 /*     760*/ 0x00, 0x00, 0x00, 0x27, 0x18, 0x17, 0x18, 0x18, 
	 /*     768*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 
	 /*     776*/ 0x06, 0x05, 0x05, 0x1f, 0x05, 0x1f, 0x2e, 0x00, 
	 /*     784*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0a, 0x1d, 0x04, 
	 /*     800*/ 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 0x00, 
	 /*     808*/ 0x00, 0x00, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     816*/ 0x29, 0xff, 0x00, 0x00, 0x00, 0x00, 0x07, 0x06, 
	 /*     824*/ 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 0x31, 0x00, 
	 /*     832*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1c, 
	 /*     848*/ 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 0x09, 0x00, 
	 /*     856*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*     864*/ 0x28, 0xff, 0x00, 0x00, 0x00, 0x07, 0x06, 0x1f, 
	 /*     872*/ 0x05, 0x05, 0x05, 0x05, 0x06, 0x07, 0x00, 0x00, 
	 /*     880*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 
	 /*     896*/ 0x1d, 0x04, 0x04, 0x04, 0x04, 0x14, 0x1d, 0x09, 
	 /*     904*/ 0x00, 0xff, 0x00, 0x29, 0x18, 0x17, 0x18, 0x18, 
	 /*     912*/ 0x29, 0xff, 0x00, 0x00, 0x07, 0x06, 0x1f, 0x05, 
	 /*     920*/ 0x1f, 0x05, 0x1f, 0x06, 0x07, 0xff, 0x00, 0x00, 
	 /*     928*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     944*/ 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 0x1d, 
	 /*     952*/ 0x09, 0xff, 0x00, 0x29, 0x18, 0x17, 0x17, 0x18, 
	 /*     960*/ 0x29, 0xff, 0x00, 0x07, 0x06, 0x05, 0x05, 0x05, 
	 /*     968*/ 0x05, 0x05, 0x06, 0x07, 0x00, 0xff, 0x00, 0x00, 
	 /*     976*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*     992*/ 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 0x04, 
	 /*    1000*/ 0x1d, 0x09, 0x00, 0x28, 0x18, 0x17, 0x17, 0x18, 
	 /*    1008*/ 0x27, 0xff, 0x07, 0x06, 0x05, 0x05, 0x1f, 0x05, 
	 /*    1016*/ 0x1f, 0x06, 0x07, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1024*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1032*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1040*/ 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 0x04, 0x04, 
	 /*    1048*/ 0x04, 0x1d, 0x09, 0x29, 0x18, 0x18, 0x18, 0x18, 
	 /*    1056*/ 0x29, 0x31, 0x06, 0x1f, 0x05, 0x1f, 0x05, 0x05, 
	 /*    1064*/ 0x06, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1072*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1080*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1088*/ 0x00, 0x00, 0x00, 0x09, 0x1d, 0x14, 0x04, 0x04, 
	 /*    1096*/ 0x04, 0x04, 0x1e, 0x08, 0x05, 0x1b, 0x1b, 0x1f, 
	 /*    1104*/ 0x30, 0x24, 0x05, 0x05, 0x05, 0x05, 0x1f, 0x06, 
	 /*    1112*/ 0x07, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1120*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1128*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1136*/ 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 0x04, 
	 /*    1144*/ 0x04, 0x04, 0x1c, 0x32, 0x31, 0x30, 0x30, 0x31, 
	 /*    1152*/ 0x32, 0x23, 0x1f, 0x1f, 0x05, 0x1f, 0x06, 0x07, 
	 /*    1160*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1168*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1176*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1184*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1d, 0x04, 
	 /*    1192*/ 0x04, 0x16, 0x28, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1200*/ 0x00, 0x2e, 0x1f, 0x05, 0x1f, 0x06, 0x07, 0x00, 
	 /*    1208*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1216*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1224*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1232*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1e, 
	 /*    1240*/ 0x1c, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1248*/ 0x00, 0x00, 0x2e, 0x23, 0x24, 0x31, 0x00, 0x00, 
	 /*    1256*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1264*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1272*/ 0x07, 0x25, 0x22, 0x23, 0x23, 0x23, 0x23, 0x22, 
	 /*    1280*/ 0x23, 0x22, 0x06, 0x23, 0x22, 0x23, 0x23, 0x2c, 
	 /*    1288*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1296*/ 0x00, 0x00, 0x00, 0x32, 0x0a, 0x30, 0x30, 0x30, 
	 /*    1304*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x09, 
	 /*    1312*/ 0x30, 0x30, 0x30, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1320*/ 0x22, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x0e, 
	 /*    1328*/ 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x0f, 0x15, 
	 /*    1336*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1344*/ 0x00, 0x00, 0x00, 0x32, 0x27, 0x06, 0x06, 0x24, 
	 /*    1352*/ 0x06, 0x24, 0x06, 0x06, 0x06, 0x24, 0x06, 0x06, 
	 /*    1360*/ 0x06, 0x24, 0x24, 0x2f, 0x00, 0xff, 0x00, 0x00, 
	 /*    1368*/ 0x1a, 0x0f, 0x10, 0x0f, 0x10, 0x10, 0x10, 0x0f, 
	 /*    1376*/ 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x0f, 0x0f, 0x11, 
	 /*    1384*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1392*/ 0x00, 0x00, 0x00, 0x07, 0x24, 0x06, 0x06, 0x06, 
	 /*    1400*/ 0x06, 0x23, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1408*/ 0x06, 0x23, 0x23, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1416*/ 0x1a, 0x10, 0x10, 0x0f, 0x10, 0x0f, 0x10, 0x10, 
	 /*    1424*/ 0x0f, 0x10, 0x10, 0x10, 0x0f, 0x10, 0x10, 0x11, 
	 /*    1432*/ 0x2c, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1440*/ 0x00, 0x00, 0x00, 0x07, 0x25, 0x06, 0x06, 0x06, 
	 /*    1448*/ 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1456*/ 0x06, 0x06, 0x06, 0x2b, 0x00, 0xff, 0x00, 0x00, 
	 /*    1464*/ 0x21, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0f, 0x10, 
	 /*    1472*/ 0x0f, 0x0f, 0x0f, 0x10, 0x10, 0x0f, 0x0e, 0x16, 
	 /*    1480*/ 0x0a, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1488*/ 0x00, 0x00, 0x00, 0x00, 0x28, 0x06, 0x06, 0x06, 
	 /*    1496*/ 0x06, 0x06, 0x24, 0x06, 0x06, 0x06, 0x06, 0x06, 
	 /*    1504*/ 0x24, 0x06, 0x06, 0x08, 0x00, 0xff, 0x00, 0x00, 
	 /*    1512*/ 0x07, 0x24, 0x23, 0x06, 0x23, 0x23, 0x23, 0x23, 
	 /*    1520*/ 0x22, 0x23, 0x23, 0x06, 0x23, 0x23, 0x23, 0x2b, 
	 /*    1528*/ 0x31, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1536*/ 0x00, 0x00, 0x00, 0x00, 0x07, 0x08, 0x30, 0x30, 
	 /*    1544*/ 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 
	 /*    1552*/ 0x30, 0x30, 0x09, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1560*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1568*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x16, 
	 /*    1576*/ 0x14, 0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1584*/ 0x00, 0x00, 0x07, 0x2e, 0x08, 0xff, 0x00, 0x00, 
	 /*    1592*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1600*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1608*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1616*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x2e, 0x13, 0x03, 
	 /*    1624*/ 0x03, 0x0c, 0x26, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1632*/ 0x00, 0x07, 0x2c, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    1640*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1648*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1656*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1664*/ 0x00, 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 
	 /*    1672*/ 0x03, 0x03, 0x14, 0x32, 0x09, 0x28, 0x28, 0x09, 
	 /*    1680*/ 0x00, 0x2e, 0x2a, 0x2b, 0x2b, 0x2b, 0x2e, 0x32, 
	 /*    1688*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1696*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1704*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1712*/ 0x00, 0x00, 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 
	 /*    1720*/ 0x03, 0x03, 0x16, 0x27, 0x0d, 0x0b, 0x0b, 0x0d, 
	 /*    1728*/ 0x29, 0x30, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b, 0x2e, 
	 /*    1736*/ 0x32, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1744*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1752*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1760*/ 0x00, 0x00, 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 
	 /*    1768*/ 0x03, 0x13, 0x2f, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1776*/ 0x1f, 0xff, 0x08, 0x2b, 0x2b, 0x2c, 0x2b, 0x2b, 
	 /*    1784*/ 0x08, 0x32, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1792*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1800*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1808*/ 0x00, 0x2e, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 
	 /*    1816*/ 0x04, 0x08, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1824*/ 0x05, 0xff, 0x32, 0x08, 0x2b, 0x2b, 0x2b, 0x2b, 
	 /*    1832*/ 0x2b, 0x2e, 0x32, 0x00, 0x00, 0xff, 0x00, 0x00, 
	 /*    1840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1848*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1856*/ 0x08, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x13, 
	 /*    1864*/ 0x08, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1872*/ 0x05, 0xff, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 0x2c, 
	 /*    1880*/ 0x2b, 0x2b, 0x08, 0x32, 0x00, 0xff, 0x00, 0x00, 
	 /*    1888*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1896*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 
	 /*    1904*/ 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 
	 /*    1912*/ 0x00, 0xff, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    1920*/ 0x1f, 0xff, 0x00, 0x00, 0x32, 0x2e, 0x2b, 0x2b, 
	 /*    1928*/ 0x2c, 0x2a, 0x2b, 0x2e, 0x32, 0xff, 0x00, 0x00, 
	 /*    1936*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1944*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 
	 /*    1952*/ 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 
	 /*    1960*/ 0x00, 0xff, 0x00, 0x05, 0x02, 0x02, 0x02, 0x02, 
	 /*    1968*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x32, 0x08, 0x2a, 
	 /*    1976*/ 0x2b, 0x2a, 0x2b, 0x2b, 0x2e, 0x32, 0x00, 0x00, 
	 /*    1984*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    1992*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x04, 0x03, 
	 /*    2000*/ 0x03, 0x03, 0x03, 0x03, 0x04, 0x08, 0x00, 0x00, 
	 /*    2008*/ 0x00, 0x00, 0x00, 0x1f, 0x02, 0x02, 0x02, 0x02, 
	 /*    2016*/ 0x05, 0xff, 0x00, 0x00, 0x00, 0x00, 0x32, 0x08, 
	 /*    2024*/ 0x2b, 0x2b, 0x2a, 0x2c, 0x2b, 0x2e, 0x32, 0x00, 
	 /*    2032*/ 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	 /*    2040*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x22, 0x03, 0x03
	 };
	 
static char s_acEthName[16] = {0};	

/* Win_Tcpip工具工作协议类型 */
typedef enum
{
	SOCKET_PROTOCOL_TCP,
	SOCKET_PROTOCOL_UDP,
	SOCKET_PROTOCOL_MAX,
}ProtocolType_E;

/* Win_Tcpip工具工作模式 */
typedef enum
{
	WINTCPIP_MODE_SERVER,
	WINTCPIP_MODE_CLIENT,
	WINTCPIP_MODE_MAX,
}WintcpipMode_E;

typedef struct
{
	ProtocolType_E eProtocolType;  /* 协议类型(tcp/udp) */
	WintcpipMode_E eWintcpipMode;  /* 模式(server/client) */
	unsigned int uBufLen;  /* 发送或接收缓存 */
	WORD wClientPort;  /* 客户或对端端口 */
	WORD wServerPortForClient;  /* 服务端端口 */
	WORD wServerPort;  /* 服务端口 */
	unsigned int uWindowSize;  /* 窗口大小 */
	unsigned int uSendDelayTime;  /* 发送延时 */
	CSUDI_BOOL bTcpShortConnect;  /* 是否进行tcp短连接测试 */
	CSUDI_BOOL bDualDataTransport;  /* 是否双向数据传输 */
}WintcpipConfig_S;

/*根据具体用例需求配置Win_Tcpip工具参数*/
static CSUDI_BOOL SOCKET_iInitWintcpip(WintcpipConfig_S *psConfig)
{
	CSUDI_BOOL bRet = CSUDI_TRUE;

	if (psConfig == NULL)
	{
		CSTCPrint("psConfig is NULL\n");
		return CSUDI_FALSE;
	}

	CSTCPrint("请启动Win_Tcpip.exe ,配置步骤如下:\n");
	if(SOCKET_PROTOCOL_TCP == psConfig->eProtocolType)
	{
		if(WINTCPIP_MODE_SERVER == psConfig->eWintcpipMode)
		{
			CSTCPrint("选择TCP,服务器模式\n");
			CSTCPrint("接收缓存设置为: %d\n", psConfig->uBufLen);
			CSTCPrint("服务端口设置为: %d\n", psConfig->wServerPort);
		}
		else if(WINTCPIP_MODE_CLIENT == psConfig->eWintcpipMode)
		{
			CSTCPrint("选择TCP,客户端模式\n");
			CSTCPrint("服务器端IP设置为:%s\n", g_szStbIp);
			CSTCPrint("发送缓存设置为: %d\n", psConfig->uBufLen);
			CSTCPrint("服务端端口设置为: %d\n", psConfig->wServerPortForClient);
		}
		else
		{
			bRet = CSUDI_FALSE;
		}
	}
	else if(SOCKET_PROTOCOL_UDP == psConfig->eProtocolType)
	{
		if(WINTCPIP_MODE_SERVER == psConfig->eWintcpipMode)
		{
			CSTCPrint("选择UDP,服务器模式\n");
			CSTCPrint("接收缓存设置为: %d\n", psConfig->uBufLen);
			CSTCPrint("服务端口设置为: %d\n", psConfig->wServerPort);
			CSTCPrint("对端口设置为: %d\n", psConfig->wClientPort);
		}
		else if(WINTCPIP_MODE_CLIENT == psConfig->eWintcpipMode)
		{
			CSTCPrint("选择UDP,客户端模式\n");
			CSTCPrint("服务器端IP设置为:%s\n", g_szStbIp);
			CSTCPrint("发送缓存设置为: %d\n", psConfig->uBufLen);
			CSTCPrint("本地端口设置为: %d\n", psConfig->wClientPort);
			CSTCPrint("服务端端口设置为: %d\n", psConfig->wServerPortForClient);
		}
		else
		{
			bRet = CSUDI_FALSE;
		}
	}
	else
	{
		bRet = CSUDI_FALSE;
	}

	if(psConfig->uWindowSize != 0)
	{
		CSTCPrint("窗口大小设置为: %d\n", psConfig->uWindowSize);
	}
	if(psConfig->bTcpShortConnect)
	{
		CSTCPrint("选中TCP短连接测试\n");
	}
	if(psConfig->bDualDataTransport)
	{
		CSTCPrint("选中双向数据传输\n");
	}

	CSTCPrint("其他输入框中的数据默认，单击创建线程\n");
	CSTKWaitAnyKey();

	return bRet;
}


static CSUDI_BOOL SOCKET_InitCfg()
{
	CSUDI_BOOL bRet = CSUDI_TRUE;

	CSTCPrint("=============SetupSocket===========\n");
	if(CS_TK_CONFIG_SUCCESS == CSTKGetConfigInfo("SOCKET","UNREACHED_IP",g_unReachedIp,sizeof(g_unReachedIp)))
	{
		CSTCPrint("UNREACHED_IP is %s\n",g_unReachedIp);
	}
	else
	{
		bRet = CSUDI_FALSE;
		CSTCPrint("get [SOCKET] UNREACHED_IP failed\n");
	}

	if(CS_TK_CONFIG_SUCCESS == CSTKGetConfigInfo("SOCKET","PC_IP",g_szServIp,sizeof(g_szServIp)))
	{
		CSTCPrint("PC_IP is %s\n", g_szServIp);
		memcpy(g_szClientIp, g_szServIp, sizeof(g_szServIp));
	}
	else
	{
		bRet = CSUDI_FALSE;
		CSTCPrint("get [SOCKET] PC_IP failed\n");
	}

	if(CS_TK_CONFIG_SUCCESS == CSTKGetConfigInfo("SOCKET","BOX_IP",g_szStbIp,sizeof(g_szStbIp)))
	{
		CSTCPrint("BOX_IP is %s\n",g_szStbIp);
	}
	else
	{
		bRet = CSUDI_FALSE;
		CSTCPrint("get [SOCKET] BOX_IP failed\n");
	}

	if(CS_TK_CONFIG_SUCCESS == CSTKGetConfigInfo("SOCKET","BOX_GETEWAY",g_szGateWay,sizeof(g_szGateWay)))
	{
		CSTCPrint("BOX_GETEWAY is %s\n",g_szGateWay);
	}
	else
	{
		bRet = CSUDI_FALSE;
		CSTCPrint("get [SOCKET] BOX_GETEWAY failed\n");
	}

	if(CS_TK_CONFIG_SUCCESS == CSTKGetConfigInfo("SOCKET","BOX_MASK",g_szMask,sizeof(g_szMask)))
	{
		CSTCPrint("BOX_MASK is %s\n",g_szMask);
	}
	else
	{
		bRet = CSUDI_FALSE;
		CSTCPrint("get [SOCKET] BOX_MASK failed\n");
	}

	if (CS_TK_CONFIG_SUCCESS == 
		CSTKGetConfigInfo("IPCFG", "CS_LAN0_NAME", s_acEthName, sizeof(s_acEthName)))
	{
		CSTCPrint("Ethname is %s\n", s_acEthName);
	}
	else
	{
		bRet = CSUDI_FALSE;
		CSTCPrint("get [IPCFG] CS_LAN0_NAME failed\n");
	}
	
	if(CSUDI_SUCCESS == CSUDIIPCFGSetIpInfo(s_acEthName, g_szStbIp, g_szMask, g_szGateWay))
	{
		CSTCPrint("SetIpInfo is Success!!!\n");
	}
	else
	{
		bRet = CSUDI_FALSE;
		CSTCPrint("[%s] CSUDIIPCFGSetIpInfo failed\n", __FUNCTION__);
	}

	return bRet;

}

CSUDI_BOOL CSTC_SOCKET_Init(void)
{
	//在本测试用例集执行前调用
	SOCKET_InitCfg();
	return CSUDI_TRUE;
}

CSUDI_BOOL CSTC_SOCKET_UnInit(void)
{
	//在本测试用例集执行后调用
	//SOCKET_iInitCfg();
	return CSUDI_TRUE;
}

/**********************************************************************
The function for select module test
**********************************************************************/
void SOCKET_Select6Thread1Entry(void *pvParam)
{
	unsigned char i = 0;
	WintcpipConfig_S sConfig;

	CSTCPrint("请等待至少十分钟后进行操作！\n");
	CSTCPrint("等待...\n");

	// 等待10分钟
	for (i = 0; i < 10; ++i)
	{
		CSUDIOSThreadSleep(60000);
		CSTCPrint("已等待%d分钟\n", i+1);
	}
	
	memset(&sConfig, 0, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_CLIENT;
	sConfig.uBufLen = 1460;
	sConfig.wServerPortForClient = 53000;
	SOCKET_iInitWintcpip(&sConfig);
}


//**********************************************************************************//
//******************************Begin Test  CSUDISOCKSocket*******************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:正确创建一个基于IPv4的流式套接字
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = CSUDI_AF_INET
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = 0
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建套接字，返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0001(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}


//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:正确创建一个基于IPv4数据报的套接字
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = CSUDI_AF_INET
//@INPUT:2、nType = CSUDI_SOCK_DGRAM
//@INPUT:3、nProtocol = 0
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0)创建套接字，返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0002(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}


//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:正确创建一个数据包类型的套接字
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = CSUDI_PF_PACKET
//@INPUT:2、nType = CSUDI_SOCK_PACKET
//@INPUT:3、nProtocol = CSUDI_ETH_P_ALL
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_PF_PACKET,CSUDI_SOCK_PACKET,CSUDI_ETH_P_ALL)创建套接字，返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0003(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_PF_PACKET;
	int nType = CSUDI_SOCK_PACKET;

	nSockRet = CSUDISOCKSocket(nDomain,nType,CSUDI_ETH_P_ALL);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}


//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:正确创建一个CSUDI_PF_PACKET协议族的监听所有数据包的原始套接字
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = CSUDI_PF_PACKET
//@INPUT:2、nType = CSUDI_SOCK_RAW
//@INPUT:3、nProtocol = CSUDI_ETH_P_ALL
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_PF_PACKET,CSUDI_SOCK_RAW,CSUDI_ETH_P_ALL)创建套接字，返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0004(void)
{
	unsigned short ushHtonsRet = 0;
	int nSockRet = -1;
	int nDomain = CSUDI_PF_PACKET;
	int nType = CSUDI_SOCK_RAW;

	ushHtonsRet = CSUDI_ETH_P_ALL;
	nSockRet = CSUDISOCKSocket(nDomain,nType,ushHtonsRet);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}



//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:正确创建一个CSUDI_PF_PACKET协议族的监听ARP包的原始套接字
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = CSUDI_PF_PACKET
//@INPUT:2、nType = CSUDI_SOCK_RAW
//@INPUT:3、nProtocol = CSUDI_ETH_P_ARP
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_PF_PACKET,CSUDI_SOCK_RAW,CSUDI_ETH_P_ARP)创建套接字，返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0005(void)
{
	//unsigned short ushHtonsRet = 0;
	int nSockRet = -1;
	int nDomain = CSUDI_PF_PACKET;
	int nType = CSUDI_SOCK_RAW;

	//ushHtonsRet = CSUDI_ETH_P_ARP;
	nSockRet = CSUDISOCKSocket(nDomain,nType,CSUDI_ETH_P_ARP);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}


//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:正确创建一个CSUDI_AF_INET协议族的监听TCP的原始套接字
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = CSUDI_AF_INET
//@INPUT:2、nType = CSUDI_SOCK_RAW
//@INPUT:3、nProtocol = CSUDI_IPPROTO_TCP
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_PF_PACKET,CSUDI_SOCK_RAW,CSUDI_IPPROTO_TCP)创建套接字，返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0006(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_RAW;
	int nProtocol = CSUDI_IPPROTO_TCP;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}


//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:正确创建一个CSUDI_AF_INET协议族的监听ICMP的原始套接字
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = CSUDI_AF_INET
//@INPUT:2、nType = CSUDI_SOCK_RAW
//@INPUT:3、nProtocol = CSUDI_IPPROTO_ICMP
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_PF_PACKET,CSUDI_SOCK_RAW,CSUDI_IPPROTO_ICMP)创建套接字，返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0007(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_RAW;
	int nProtocol = CSUDI_IPPROTO_ICMP;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}



//@CASEGROUP:CSUDISOCKTCPIPSocket
//@DESCRIPTION:错误协议族导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = 1000
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = 0
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(1000,CSUDI_SOCK_STREAM,0)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0008(void)
{   
	int nSockRet = -1;
	int nDomain = 1000;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:错误协议族导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain =  -1 
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = 0
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(-1,CSUDI_SOCK_STREAM,0)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0009(void)
{   
	int nSockRet = -1;
	int nDomain = -1;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:错误协议族导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = 0x7fffffff
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = 0
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(0x7fffffff,CSUDI_SOCK_STREAM,0)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0010(void)
{   
	int nSockRet = -1;
	int nDomain = 0x7fffffff;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}


//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:错误套接字类型导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = CSUDI_AF_INET
//@INPUT:2、nType = -1
//@INPUT:3、nProtocol = 0
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,-1,0)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0011(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = -1;
	int nProtocol = 0;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:错误套接字类型导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = CSUDI_AF_INET
//@INPUT:2、nType = 0x7fffffff
//@INPUT:3、nProtocol = 0
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,0x7fffffff,0)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0012(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = 0x7fffffff;
	int nProtocol = 0;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:错误套接字类型导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = CSUDI_AF_INET
//@INPUT:2、nType = 0
//@INPUT:3、nProtocol = 0
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,0,0)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0013(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = 0;
	int nProtocol = 0;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:错误协议类型导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = CSUDI_AF_INET
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = -1
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,-1)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0014(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = -1;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:错误协议类型导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = CSUDI_AF_INET
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = 0x7fffffff
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0x7fffffff)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0015(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0x7fffffff;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:协议栈初始化成功后连续创建20个CSUDI_SOCK_STREAM类型套接字
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = CSUDI_AF_INET
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = 0
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、循环调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)20次创建套接字
//@EXECUTIONFLOW: 2、循环调用CSUDISOCKClose(nFd)20次关闭套接字
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0016(void)
{   
	int nSockRet[20] = {-1};
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	int i = 0;

	for (i=0;i<20;i++)
	{
		nSockRet[i] = CSUDISOCKSocket(nDomain,nType,nProtocol);
		CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet[i],"步骤1失败");	
	}
	CSTK_FATAL_POINT
	for (i=0;i<20;i++)	
	{
		if(nSockRet[i] != -1 )
		{
			CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet[i]),"关闭套接字失败");
		}
	}	
	return CSUDI_TRUE; 
}


//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:协议栈初始化成功后连续成功创建128个CSUDI_SOCK_STREAM类型套接字
//@PRECONDITION: 协议栈已经初始化成功
//@INPUT:1、nDomain = CSUDI_AF_INET
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = 0
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、循环调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)128次创建套接字
//@EXECUTIONFLOW: 2、循环调用CSUDISOCKClose(nFd)128次关闭套接字
CSUDI_BOOL CSTC_SOCKET_IT_Socket_0017(void)
{   
	int nSockRet[SOCKET_MAX_SOCKET_CNT] = {-1};
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	int i = 0;

	memset(nSockRet, -1, sizeof(nSockRet));
	for (i=0;i<SOCKET_MAX_SOCKET_CNT;i++)
	{
		nSockRet[i] = CSUDISOCKSocket(nDomain,nType,nProtocol);
		CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet[i],"步骤1失败");	
	}
	CSTK_FATAL_POINT
	for (i=0;i<SOCKET_MAX_SOCKET_CNT;i++)	
	{
		if(nSockRet[i] != -1 )
		{
			CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet[i]),"关闭套接字失败");
		}
	}	
	return CSUDI_TRUE; 
}


//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:正确创建一个基于蓝牙的流式套接字
//@PRECONDITION: 协议栈已经初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@INPUT:1、nDomain = CSUDI_AF_BLUETOOTH
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = CSUDI_BTPROTO_RFCOMM
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM)创建套接字，返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Socket_0018(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}



//@CASEGROUP:CSUDISOCKTCPIPSocket
//@DESCRIPTION:错误协议族导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@INPUT:1、nDomain = 1000
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = CSUDI_BTPROTO_RFCOMM
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(1000,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Socket_0019(void)
{   
	int nSockRet = -1;
	int nDomain = 1000;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}


//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:错误协议族导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@INPUT:1、nDomain =  -1 
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = CSUDI_BTPROTO_RFCOMM
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(-1,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Socket_0020(void)
{   
	int nSockRet = -1;
	int nDomain = -1;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:错误协议族导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@INPUT:1、nDomain = 0x7fffffff
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = CSUDI_BTPROTO_RFCOMM
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(0x7fffffff,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Socket_0021(void)
{   
	int nSockRet = -1;
	int nDomain = 0x7fffffff;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:错误套接字类型导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@INPUT:1、nDomain = CSUDI_AF_BLUETOOTH
//@INPUT:2、nType = -1
//@INPUT:3、nProtocol = CSUDI_BTPROTO_RFCOMM
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,-1,CSUDI_BTPROTO_RFCOMM)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Socket_0022(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = -1;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:错误套接字类型导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@INPUT:1、nDomain = CSUDI_AF_BLUETOOTH
//@INPUT:2、nType = 0x7fffffff
//@INPUT:3、nProtocol = CSUDI_BTPROTO_RFCOMM
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,0x7fffffff,CSUDI_BTPROTO_RFCOMM)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Socket_0023(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = 0x7fffffff;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:错误套接字类型导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@INPUT:1、nDomain = CSUDI_AF_BLUETOOTH
//@INPUT:2、nType = 0
//@INPUT:3、nProtocol = CSUDI_BTPROTO_RFCOMM
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,0,CSUDI_BTPROTO_RFCOMM)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Socket_0024(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = 0;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:错误协议类型导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@INPUT:1、nDomain = CSUDI_AF_BLUETOOTH
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = -1
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,-1)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Socket_0025(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = -1;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:错误协议类型导致套接字创建失败
//@PRECONDITION: 协议栈已经初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@INPUT:1、nDomain = CSUDI_AF_BLUETOOTH
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = 0x7fffffff
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,0x7fffffff)创建套接字
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Socket_0026(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0x7fffffff;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nSockRet,"步骤1失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:协议栈初始化成功后连续创建20个CSUDI_SOCK_STREAM类型套接字
//@PRECONDITION: 协议栈已经初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@INPUT:1、nDomain = CSUDI_AF_BLUETOOTH
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = CSUDI_BTPROTO_RFCOMM
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、循环调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM)20次创建套接字
//@EXECUTIONFLOW: 2、循环调用CSUDISOCKClose(nFd)20次关闭套接字
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Socket_0027(void)
{   
	int nSockRet[20];
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;
	int i = 0;

	memset(nSockRet, -1, sizeof(nSockRet));
	for (i=0;i<20;i++)
	{
		nSockRet[i] = CSUDISOCKSocket(nDomain,nType,nProtocol);
		CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet[i],"步骤1失败");	
	}
	CSTK_FATAL_POINT
	for (i=0;i<20;i++)	
	{
		if(nSockRet[i] != -1 )
		{
			CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet[i]),"关闭套接字失败");
		}
	}	
	return CSUDI_TRUE; 
}


//@CASEGROUP:CSUDISOCKSocket
//@DESCRIPTION:协议栈初始化成功后连续创建128个CSUDI_SOCK_STREAM类型套接字
//@PRECONDITION: 协议栈已经初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@INPUT:1、nDomain = CSUDI_AF_BLUETOOTH
//@INPUT:2、nType = CSUDI_SOCK_STREAM
//@INPUT:3、nProtocol = CSUDI_BTPROTO_RFCOMM
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、循环调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM)128次创建套接字
//@EXECUTIONFLOW: 2、循环调用CSUDISOCKClose(nFd)128次关闭套接字
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Socket_0028(void)
{   
	int nSockRet[SOCKET_MAX_SOCKET_CNT];
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;
	int i = 0;

	memset(nSockRet, -1, sizeof(nSockRet));
	for (i=0;i<SOCKET_MAX_SOCKET_CNT;i++)
	{
		nSockRet[i] = CSUDISOCKSocket(nDomain,nType,nProtocol);
		CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet[i],"步骤1失败");	
	}
	CSTK_FATAL_POINT
	for (i=0;i<SOCKET_MAX_SOCKET_CNT;i++)	
	{
		if(nSockRet[i] != -1 )
		{
			CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet[i]),"关闭套接字失败");
		}
	}	
	return CSUDI_TRUE; 
}
//**********************************************************************************//
//*******************************End  Test  CSUDISOCKSocket*******************************//
//**********************************************************************************//

//**********************************************************************************//
//********************************Begin  Test  CSUDISOCKBind ******************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:套接字与本地主机绑定成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以创建IPv4流式套接字
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nClientPort);sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Bind_0001(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sClientAddr;
	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons( g_nClientPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 	
}


//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:套接字与本地主机(端口号为0)绑定成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以创建IPv4流式套接字
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(0);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定，成功返回0
//@EXECUTIONFLOW: 2、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Bind_0002(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sClientAddr;
	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons( 0);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	

}


//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:套接字与本地主机(端口号为65535)绑定成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(65535);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回0
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Bind_0003(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sClientAddr;
	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons(65535);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	

}



//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:一个套接字与一个主机地址(IP 和端口号前后两次均相同)绑定两次导致套接字与本地主机第二次绑定失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nClientPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定，失败返回-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Bind_0004(void)
{   
	int nSockOneRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sClientAddr;
	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons(g_nClientPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockOneRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockOneRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_S)),"步骤3失败");
	CSTK_FATAL_POINT
	if(nSockOneRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockOneRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:两个套接字与同一个主机地址绑定导致第二个套接字与本地主机绑定失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nClientPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式的套接字，成功返回值为nFd1
//@EXECUTIONFLOW: 2、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式的套接字，成功返回值为nFd2
//@EXECUTIONFLOW: 3、调用CSUDISOCKBind (nFd1, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定成功，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKBind (nFd2, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定失败，失败返回-1
//@EXECUTIONFLOW: 5、调用CSUDISOCKClose(nFd1)关闭套接字，成功返回0
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd2)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Bind_0005(void)
{   
	int nSockOneRet = -1;
	int nSockTwoRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sClientAddr;
	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons(g_nClientPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockOneRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	nSockTwoRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockOneRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKBind(nSockTwoRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_S)),"步骤3失败");
	CSTK_FATAL_POINT
	if(nSockOneRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockOneRet),"关闭套接字1失败");
	}
	if(nSockTwoRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockTwoRet),"关闭套接字2失败");
	}
	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:地址族为0与本机地址绑定成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = 0;sin_port = CSUDISOCKHtons(g_nClientPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}
//@INPUT:3、uLen = sizeof( CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Bind_0006(void)
{   
	int nSockOneRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sClientAddr;
	sClientAddr.sin_family = CSUDI_AF_UNSPEC;
	sClientAddr.sin_port = CSUDISOCKHtons(g_nClientPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockOneRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockOneRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockOneRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockOneRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:地址族取最大值时套接字与本地主机绑定成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_MAX;sin_port = CSUDISOCKHtons(g_nClientPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_S))将本地主机端口与套接字绑定，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Bind_0007(void)
{   
	int nSockOneRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sClientAddr;
	sClientAddr.sin_family = CSUDI_AF_MAX;
	sClientAddr.sin_port = CSUDISOCKHtons(g_nClientPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockOneRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockOneRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockOneRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockOneRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:地址族越界时(sin_family=33)套接字与本地主机依然绑定成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_MAX+1;sin_port = CSUDISOCKHtons(g_nClientPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Bind_0008(void)
{   
	int nSockOneRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sClientAddr;
	sClientAddr.sin_family = CSUDI_AF_MAX+1;
	sClientAddr.sin_port = CSUDISOCKHtons(g_nClientPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockOneRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockOneRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockOneRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockOneRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:地址族越界时(sin_family=50)套接字与本地主机依然绑定成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_IN_S类型的结构体{sin_family = 50;sin_port = CSUDISOCKHtons(g_nClientPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Bind_0009(void)
{   
	int nSockOneRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sClientAddr;
	sClientAddr.sin_family = 50;
	sClientAddr.sin_port = CSUDISOCKHtons(g_nClientPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockOneRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockOneRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockOneRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockOneRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:IP地址非本地主机地址导致套接字与本地主机绑定失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nClientPort);sin_addr.s_addr =CSUDISOCKInet_addr(g_szClientIp)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定，失败返回-1
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Bind_0010(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	int nRet;
	
	CSUDISockAddr_IN_S sClientAddr;
	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons(g_nClientPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szClientIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == (nRet=CSUDISOCKBind(nSockRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_S))),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:一个套接字同时与一台主机的两个不同端口绑定失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_IN_S类型的结构体
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定,返回成功{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nClientPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定,返回成功{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nClientPort+2);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，失败返回-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Bind_0011(void)
{   
	int nSockOneRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sClientAddr;
	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons(g_nClientPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockOneRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockOneRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");

	sClientAddr.sin_port = CSUDISOCKHtons(g_nClientPort+2);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_S)),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockOneRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockOneRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:蓝牙套接字与本地主机绑定成功
//@PRECONDITION:1、协议栈初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@PRECONDITION:2、可以创建蓝牙流式套接字
//@INPUT:1、nFd 为创建蓝牙流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_RC_S类型的结构体:{addressFamily = CSUDI_AF_BLUETOOTH;port = (unsigned char)g_nSaitionServer & 0xFF;btAddr = *CSUDI_BDADDR_ANY}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM) 创建一个蓝牙流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Bind_0012(void)
{	
	int nSockRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;

	CSUDISockAddr_RC_S sClientAddr = {0};
	sClientAddr.addressFamily = CSUDI_AF_BLUETOOTH;
	sClientAddr.port = (unsigned char)g_nSaitionServer & 0xFF;
	sClientAddr.btAddr = *CSUDI_BDADDR_ANY;

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_RC_S)),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 	
}


//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:套接字与本地主机(端口号为0)绑定成功
//@PRECONDITION:1、协议栈初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@PRECONDITION:2、可以创建蓝牙流式套接字
//@INPUT:1、nFd 为创建蓝牙流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_RC_S类型的结构体:{addressFamily = CSUDI_AF_BLUETOOTH;port = (unsigned char)0 & 0xFF;btAddr = *CSUDI_BDADDR_ANY}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM) 创建一个蓝牙流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定，成功返回0
//@EXECUTIONFLOW: 2、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Bind_0013(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;

	CSUDISockAddr_RC_S sClientAddr = {0};
	sClientAddr.addressFamily = CSUDI_AF_BLUETOOTH;
	sClientAddr.port = (unsigned char)0 & 0xFF;
	sClientAddr.btAddr = *CSUDI_BDADDR_ANY;

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_RC_S)),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	

}


//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:套接字与本地主机(端口号为65535)绑定成功
//@PRECONDITION:1、协议栈初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@PRECONDITION:2、可以创建蓝牙流式套接字
//@INPUT:1、nFd 为创建蓝牙流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_RC_S类型的结构体:{addressFamily = CSUDI_AF_BLUETOOTH;port = (unsigned char)65535 & 0xFF;btAddr = *CSUDI_BDADDR_ANY}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM) 创建一个蓝牙流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定，成功返回0
//@EXECUTIONFLOW: 2、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Bind_0014(void)
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Bind_0014(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;
	
	CSUDISockAddr_RC_S sClientAddr = {0};
	sClientAddr.addressFamily = CSUDI_AF_BLUETOOTH;
	sClientAddr.port = (unsigned char)65535 & 0xFF;
	sClientAddr.btAddr = *CSUDI_BDADDR_ANY;

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_RC_S)),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	

}



//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:一个套接字与一个主机地址(IP 和端口号前后两次均相同)绑定两次导致套接字与本地主机第二次绑定失败
//@PRECONDITION:1、协议栈初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、为创建蓝牙流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_RC_S类型的结构体:{addressFamily = CSUDI_AF_BLUETOOTH;port = (unsigned char)g_nSaitionServer & 0xFF;btAddr = *CSUDI_BDADDR_ANY}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM) 创建一个蓝牙流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定，失败返回-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Bind_0015(void)
{   
	int nSockOneRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;

	CSUDISockAddr_RC_S sClientAddr = {0};
	sClientAddr.addressFamily = CSUDI_AF_BLUETOOTH;
	sClientAddr.port = (unsigned char)g_nSaitionServer & 0xFF;
	sClientAddr.btAddr = *CSUDI_BDADDR_ANY;

	nSockOneRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockOneRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_RC_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_RC_S)),"步骤3失败");
	CSTK_FATAL_POINT
	if(nSockOneRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockOneRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:两个套接字与同一个主机地址绑定导致第二个套接字与本地主机绑定失败
//@PRECONDITION:1、协议栈初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、为创建蓝牙流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_RC_S类型的结构体:{addressFamily = CSUDI_AF_BLUETOOTH;port = (unsigned char)g_nSaitionServer & 0xFF;btAddr = *CSUDI_BDADDR_ANY}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM) 创建一个蓝牙流式的套接字，成功返回值为nFd1
//@EXECUTIONFLOW: 2、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM) 创建一个蓝牙流式的套接字，成功返回值为nFd2
//@EXECUTIONFLOW: 3、调用CSUDISOCKBind (nFd1, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定成功，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKBind (nFd2, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定失败，失败返回-1
//@EXECUTIONFLOW: 5、调用CSUDISOCKClose(nFd1)关闭套接字，成功返回0
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd2)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Bind_0016(void)
{   
	int nSockOneRet = -1;
	int nSockTwoRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;

	CSUDISockAddr_RC_S sClientAddr = {0};
	sClientAddr.addressFamily = CSUDI_AF_BLUETOOTH;
	sClientAddr.port = (unsigned char)g_nSaitionServer & 0xFF;
	sClientAddr.btAddr = *CSUDI_BDADDR_ANY;
	
	nSockOneRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	nSockTwoRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockOneRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_RC_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKBind(nSockTwoRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_RC_S)),"步骤3失败");
	CSTK_FATAL_POINT
	if(nSockOneRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockOneRet),"关闭套接字1失败");
	}
	if(nSockTwoRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockTwoRet),"关闭套接字2失败");
	}
	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:地址族为0与本机地址绑定失败
//@PRECONDITION:1、协议栈初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、nFd 为创建蓝牙流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_RC_S类型的结构体:{addressFamily = CSUDI_AF_UNSPEC;port = (unsigned char)g_nSaitionServer & 0xFF;btAddr = *CSUDI_BDADDR_ANY}
//@INPUT:3、uLen = sizeof( CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM) 创建一个蓝牙流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Bind_0017(void)
{   
	int nSockOneRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;

	CSUDISockAddr_RC_S sClientAddr = {0};
	sClientAddr.addressFamily = CSUDI_AF_UNSPEC;
	sClientAddr.port = (unsigned char)g_nSaitionServer & 0xFF;
	sClientAddr.btAddr = *CSUDI_BDADDR_ANY;

	nSockOneRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockOneRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_RC_S)),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockOneRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockOneRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:地址族取最大值时套接字与本地主机绑定失败
//@PRECONDITION:1、协议栈初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、nFd 为创建蓝牙流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_RC_S类型的结构体:{addressFamily = CSUDI_AF_MAX;port = (unsigned char)g_nSaitionServer & 0xFF;btAddr = *CSUDI_BDADDR_ANY}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个蓝牙流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_RC_S))将本地主机端口与套接字绑定，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Bind_0018(void)
{   
	int nSockOneRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;

	CSUDISockAddr_RC_S sClientAddr = {0};
	sClientAddr.addressFamily = CSUDI_AF_MAX;
	sClientAddr.port = (unsigned char)g_nSaitionServer & 0xFF;
	sClientAddr.btAddr = *CSUDI_BDADDR_ANY;

	nSockOneRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockOneRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_RC_S)),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockOneRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockOneRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:地址族越界时(addressFamily=33)套接字与本地主机依然绑定失败
//@PRECONDITION:1、协议栈初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、nFd 为创建蓝牙流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_IN_S类型的结构体:{addressFamily = CSUDI_AF_MAX+1;port = (unsigned char)g_nSaitionServer & 0xFF;btAddr = *CSUDI_BDADDR_ANY}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM) 创建一个蓝牙流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Bind_0019(void)
{   
	int nSockOneRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;

	CSUDISockAddr_RC_S sClientAddr = {0};
	sClientAddr.addressFamily = CSUDI_AF_MAX + 1;
	sClientAddr.port = (unsigned char)g_nSaitionServer & 0xFF;
	sClientAddr.btAddr = *CSUDI_BDADDR_ANY;
	
	nSockOneRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockOneRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_RC_S)),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockOneRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockOneRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:地址族越界时(addressFamily=50)套接字与本地主机依然绑定失败
//@PRECONDITION:1、协议栈初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、nFd 为创建蓝牙流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_RC_S类型的结构体：{addressFamily = 50;port = (unsigned char)g_nSaitionServer & 0xFF;btAddr = *CSUDI_BDADDR_ANY}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM) 创建一个蓝牙流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Bind_0020(void)
{   
	int nSockOneRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;

	CSUDISockAddr_RC_S sClientAddr = {0};
	sClientAddr.addressFamily = 50;
	sClientAddr.port = (unsigned char)g_nSaitionServer & 0xFF;
	sClientAddr.btAddr = *CSUDI_BDADDR_ANY;
	
	nSockOneRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockOneRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_RC_S)),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockOneRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockOneRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKBind
//@DESCRIPTION:一个套接字同时与一台主机的两个不同端口绑定失败
//@PRECONDITION:1、协议栈初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@PRECONDITION:2、创建流式套接字成功
//@INPUT:1、nFd 为创建蓝牙流式套接字的返回值
//@INPUT:2、sClientAddr 为CSUDISockAddr_IN_S类型的结构体
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个蓝牙流式的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定,返回成功{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nSaitionServer);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定,返回成功{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nSaitionServer+2);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，失败返回-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Bind_0021(void)
{   
	int nSockOneRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;
	
	CSUDISockAddr_RC_S sClientAddr = {0};
	sClientAddr.addressFamily = CSUDI_AF_BLUETOOTH;
	sClientAddr.port = (unsigned char)g_nSaitionServer & 0xFF;
	sClientAddr.btAddr = *CSUDI_BDADDR_ANY;
	
	nSockOneRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockOneRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_RC_S)),"步骤2失败");

	sClientAddr.port = (unsigned char)(g_nSaitionServer+2) & 0xFF;
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKBind(nSockOneRet, ( CSUDISockAddr_S*)&sClientAddr, sizeof( CSUDISockAddr_RC_S)),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockOneRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockOneRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//**********************************************************************************//
//********************************** End  Test  CSUDISOCKBind *****************************//
//**********************************************************************************//

//**********************************************************************************//
//********************************* Begin  Test  CSUDISOCKListen****************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKListen
//@DESCRIPTION:成功把套接字置为监听状态
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以创建套接字成功
//@PRECONDITION:3、套接字与地址可以绑定成功
//@INPUT:1、nFd 为创建IPv4流式套接字成功后的返回值
//@INPUT:2、nNum = 10
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind(nFd,(CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定。sClientAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,10)对连接进行监听，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Listen_0001(void)
{   	
	int nSockRet = -1;
	int nNum = 10;
	
	CSUDISockAddr_IN_S sServAddr;	
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	//nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0);
	//nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0);
	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, ( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,nNum),"步骤3失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKListen
//@DESCRIPTION:成功把套接字置为监听状态
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以创建套接字成功
//@PRECONDITION:3、套接字与地址可以绑定成功
//@INPUT:1、nFd 为创建IPv4流式套接字成功后的返回值
//@INPUT:2、nNum = 32
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind(nFd,(CSUDISockAddr_S*)sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定。sClientAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,32)对连接进行监听，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Listen_0002(void)
{   	
	int nSockRet = -1;
	int nNum = 32;
	
	CSUDISockAddr_IN_S sServAddr;	
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, ( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,nNum),"步骤3失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKListen
//@DESCRIPTION:连接队列为负套接字对连接监听成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以创建套接字成功
//@PRECONDITION:3、套接字与地址可以绑定成功
//@INPUT:1、nFd 为创建IPv4流式套接字成功后的返回值
//@INPUT:2、nNum = -1
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind(nFd,(CSUDISockAddr_S*)sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定。sClientAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,-1)对连接进行监听，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
//@REMARKS:连接队列数为负时一律把连接队列数赋值为1，故连接队列数为负时套接字依然能监听成功
CSUDI_BOOL CSTC_SOCKET_IT_Listen_0003(void)
{   	
	int nSockRet = -1;
	int nNum = -1;
	
	CSUDISockAddr_IN_S sServAddr;	
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, ( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,nNum),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKListen
//@DESCRIPTION:连接队列数为0x7fffffff时套接字对连接监听成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以创建套接字成功
//@PRECONDITION:3、套接字与地址可以绑定成功
//@INPUT:1、nFd 为创建IPv4流式套接字成功后的返回值
//@INPUT:2、nNum = 0x7fffffff
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind(nFd,(CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定。sClientAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen (nFd,0x7fffffff)对连接进行监听，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
//@REMARKS:连接队列数常取约定常数10，但取极限值依然没有错
CSUDI_BOOL CSTC_SOCKET_IT_Listen_0004(void)
{   	
	int nSockRet = -1;
	int nNum = 0x7fffffff;
	
	CSUDISockAddr_IN_S sServAddr;	
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, ( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,nNum),"步骤3失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}



//@CASEGROUP:CSUDISOCKListen
//@DESCRIPTION:套接字为非法值-1时套接字对连接监听失败
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:1、nFd = -1
//@INPUT:2、nNum = 10 
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKListen (-1,10)对连接进行监听，失败返回-1
CSUDI_BOOL CSTC_SOCKET_IT_Listen_0005(void)
{   	
	int nSockRet = -1;
	int nNum = 10;

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE== CSUDISOCKListen(nSockRet,nNum),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKListen
//@DESCRIPTION:套接字为非法值0 时导致套接字对连接监听失败
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:1、nFd = 0
//@INPUT:2、nNum = 10
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKListen (0,10)对连接进行监听，失败返回-1
CSUDI_BOOL CSTC_SOCKET_IT_Listen_0006(void)
{   	
	int nSockRet = 0;
	int nNum = 10;

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE== CSUDISOCKListen(nSockRet,nNum),"步骤2失败");
	CSTK_FATAL_POINT
	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKListen
//@DESCRIPTION:套接字为非法值0x7fffffff时导致套接字对连接监听失败
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:1、nFd 为非创建套接字描述符，置为0x7fffffff
//@INPUT:2、nNum 为最大连接队列数，置为10
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKListen (0x7fffffff,10)对连接进行监听，失败返回-1
CSUDI_BOOL CSTC_SOCKET_IT_Listen_0007(void)
{   	
	int nSockRet = 0x7fffffff;
	int nNum = 10;

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE== CSUDISOCKListen(nSockRet,nNum),"步骤2失败");
	CSTK_FATAL_POINT
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKListen
//@DESCRIPTION:成功把套接字置为监听状态
//@PRECONDITION:1、协议栈初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@PRECONDITION:2、可以创建套接字成功
//@PRECONDITION:3、套接字与地址可以绑定成功
//@INPUT:1、nFd 为创建蓝牙流式套接字成功后的返回值
//@INPUT:2、nNum = 10
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMMc) 创建一个蓝牙流式套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind(nFd,(CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定。sClientAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nSaitionServer);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,10)对连接进行监听，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Listen_0008(void)
{   	
	int nSockRet = -1;
	int nNum = 10;	

	CSUDISockAddr_RC_S sServAddr = {0};
	sServAddr.addressFamily = CSUDI_AF_BLUETOOTH;
	sServAddr.port = (unsigned char)g_nSaitionServer & 0xFF;
	sServAddr.btAddr = *CSUDI_BDADDR_ANY;

	//nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0);
	//nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0);
	nSockRet = CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, ( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_RC_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,nNum),"步骤3失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKListen
//@DESCRIPTION:成功把套接字置为监听状态
//@PRECONDITION:1、协议栈初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@PRECONDITION:2、可以创建套接字成功
//@PRECONDITION:3、套接字与地址可以绑定成功
//@INPUT:1、nFd 为创建蓝牙流式套接字成功后的返回值
//@INPUT:2、nNum = 32
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM) 创建一个蓝牙流式套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind(nFd,(CSUDISockAddr_S*)sServAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定。sClientAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nSaitionServer);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,32)对连接进行监听，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Listen_0009(void)
{   	
	int nSockRet = -1;
	int nNum = 32;

	CSUDISockAddr_RC_S sServAddr = {0};
	sServAddr.addressFamily = CSUDI_AF_BLUETOOTH;
	sServAddr.port = (unsigned char)g_nSaitionServer & 0xFF;
	sServAddr.btAddr = *CSUDI_BDADDR_ANY;

	nSockRet = CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, ( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_RC_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,nNum),"步骤3失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKListen
//@DESCRIPTION:连接队列为负套接字对连接监听成功
//@PRECONDITION:1、协议栈初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@PRECONDITION:2、可以创建套接字成功
//@PRECONDITION:3、套接字与地址可以绑定成功
//@INPUT:1、nFd 为创建蓝牙流式套接字成功后的返回值
//@INPUT:2、nNum = -1
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM)创建一个蓝牙流式套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind(nFd,(CSUDISockAddr_S*)sServAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定。sClientAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nSaitionServer);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,-1)对连接进行监听，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
//@REMARKS:连接队列数为负时一律把连接队列数赋值为1，故连接队列数为负时套接字依然能监听成功
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Listen_0010(void)
{   	
	int nSockRet = -1;
	int nNum = -1;
	
	CSUDISockAddr_RC_S sServAddr = {0};
	sServAddr.addressFamily = CSUDI_AF_BLUETOOTH;
	sServAddr.port = (unsigned char)g_nSaitionServer & 0xFF;
	sServAddr.btAddr = *CSUDI_BDADDR_ANY;

	nSockRet = CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, ( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_RC_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,nNum),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKListen
//@DESCRIPTION:连接队列数为0x7fffffff时套接字对连接监听成功
//@PRECONDITION:1、协议栈初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@PRECONDITION:2、可以创建套接字成功
//@PRECONDITION:3、套接字与地址可以绑定成功
//@INPUT:1、nFd 为创建蓝牙流式套接字成功后的返回值
//@INPUT:2、nNum = 0x7fffffff
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM) 创建一个蓝牙流式套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind(nFd,(CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_RC_S))将本地主机端口与套接字绑定。sClientAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nSaitionServer);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen (nFd,0x7fffffff)对连接进行监听，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
//@REMARKS:连接队列数常取约定常数10，但取极限值依然没有错
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Listen_0011(void)
{   	
	int nSockRet = -1;
	int nNum = 0x7fffffff;

	CSUDISockAddr_RC_S sServAddr = {0};
	sServAddr.addressFamily = CSUDI_AF_BLUETOOTH;
	sServAddr.port = (unsigned char)g_nSaitionServer & 0xFF;
	sServAddr.btAddr = *CSUDI_BDADDR_ANY;

	nSockRet = CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, ( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_RC_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,nNum),"步骤3失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//**********************************************************************************//
//********************************* End  Test  CSUDISOCKListen *****************************//
//**********************************************************************************//

//**********************************************************************************//
//********************************* Begin  Test  CSUDISOCKConnect *****************************//
//**********************************************************************************/
//@CASEGROUP:CSUDISOCKETConnect
//@DESCRIPTION:客户端向服务端发起连接成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建套接字成功
//@PRECONDITION:3、服务端可以成功接收连接
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4字节流的套接字，成功返回套接字描述符nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Connect_0001(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	CSUDISockAddr_IN_S sServAddr;
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort= 26000;
	SOCKET_iInitWintcpip(&sConfig);

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");

	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETConnect
//@DESCRIPTION:套接字为非法值-1导致客户端向服务端连接失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、服务端可以成功接收连接
//@INPUT:1、nFd =-1，非创建的套接字描述符
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKConnect(-1,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，失败返回-1
CSUDI_BOOL CSTC_SOCKET_IT_Connect_0002(void)
{   
	int nSockRet = -1;
	
	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE== CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_FATAL_POINT
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETConnect
//@DESCRIPTION:套接字为非法值0导致客户端向服务端连接失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、服务端可以成功接收连接
//@INPUT:1、nFd =0，非创建的套接字描述符
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKConnect(0,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，失败返回-1
CSUDI_BOOL CSTC_SOCKET_IT_Connect_0003(void)
{   
	int nSockRet = 0;

	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE== CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_FATAL_POINT
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETConnect
//@DESCRIPTION:套接字为非法值1导致客户端向服务端连接失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、服务端可以成功接收连接
//@INPUT:1、nFd = 1 ，非创建的套接字描述符
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKConnect (1,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，失败返回-1
CSUDI_BOOL CSTC_SOCKET_IT_Connect_0004(void)
{   
	int nSockRet = 1;

	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE== CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_FATAL_POINT
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETConnect
//@DESCRIPTION:套接字为非法值0x7fffffff导致客户端向服务端发起连接失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、服务端可以成功接收连接
//@INPUT:1、nFd = 0x7fffffff ，非创建的套接字描述符
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKConnect (0x7fffffff,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，失败返回-1
CSUDI_BOOL CSTC_SOCKET_IT_Connect_0005(void)
{   
	int nSockRet = 0x7fffffff;

	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE== CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_FATAL_POINT
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETConnect
//@DESCRIPTION:所连接的端口号非服务端的端口号导致连接失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(52000);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4字节流的套接字，成功返回0
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，失败返回-1
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Connect_0006(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;

	CSTCPrint("该测试用例需要等待几分钟\n");	
	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(52000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETConnect
//@DESCRIPTION:IP地址非法导致客户端向服务端连接失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr("172.30.18.256")}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4字节流的套接字，成功返回0
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，失败返回-1
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Connect_0007(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSTCPrint("该测试用例需要等待几分钟\n");	
	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr("172.30.18.256");

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETConnect
//@DESCRIPTION:错误IP地址导致客户端向服务端连接失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr("192.168.9.360")}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4字节流的套接字，成功返回0
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，失败返回-1
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Connect_0008(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr("192.168.9.360");

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE== CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETConnect
//@DESCRIPTION:错误IP地址导致客户端向服务端连接失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr("255.255.255.255")}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4字节流的套接字，成功返回0
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，失败返回-1
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Connect_0009(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr("255.255.255.255");

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKETConnect
//@DESCRIPTION:地址族非法导致客户端向服务端连接失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sServAddr:{sin_family = 0xffff;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4字节流的套接字，成功返回0
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，失败返回-1
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Connect_0010(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = 0xffff;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKETConnect
//@DESCRIPTION:在客户端创建4个套接字，4个套接字分别并向服务端发起连接请求，每个套接字连接成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4字节流的套接字，成功返回0
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sClientAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，成功返回0
//@EXECUTIONFLOW: 3、循环调用步骤1、2共4次
//@EXECUTIONFLOW: 4、循环调用CSUDISOCKClose(nFd)4次关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Connect_0011(void)
{   
	int nSockRet[4] = {0};
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	int i=0,j=0;
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort= 26000;
	SOCKET_iInitWintcpip(&sConfig);

	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	for(i=0;i<4;i++)
	{
		nSockRet[i] = CSUDISOCKSocket(nDomain,nType,nProtocol);
		CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet[i],"步骤1失败");
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet[i],( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	}

	CSTK_FATAL_POINT
	for(j=0;j<i;j++)
	{
		if(nSockRet[i] != -1 )
		{
			CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet[j]),"关闭套接字失败");
		}
	}
	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKETConnect
//@DESCRIPTION:在客户端创建一个套接字，多次向服务端发起连接请求，第一次连接成功，之后的连接失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建套接字成功
//@PRECONDITION:3、服务端可以成功接收连接
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4字节流的套接字，成功返回0
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sClientAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，成功返回0
//@EXECUTIONFLOW: 3、循环调用步骤2共20次
//@EXECUTIONFLOW: 4、循环调用CSUDISOCKClose(nFd)20次关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Connect_0012(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	int i = 0;
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort= 26000;
	SOCKET_iInitWintcpip(&sConfig);
	
	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	for(i=0;i<20;i++)
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤3失败");
	}
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE;	
}



//@CASEGROUP:CSUDISOCKETConnect
//@DESCRIPTION:在客户端创建套接字并向服务端发起连接请求重复10次，返回成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建套接字成功
//@PRECONDITION:3、服务端可以成功接收连接
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4字节流的套接字，成功返回0
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sClientAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd)，成功返回0
//@EXECUTIONFLOW: 4、循环调用步骤1-3共10次
CSUDI_BOOL CSTC_SOCKET_IT_Connect_0013(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	int i = 0;
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort= 26000;
	SOCKET_iInitWintcpip(&sConfig);

	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	for(i=0;i<10;i++)
	{
		CSTCPrint("This is the %dst Time!\n",i+1);
		nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
		CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,(CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
		if(nSockRet != -1 )
		{
			CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
		}
	}
	
	CSTK_FATAL_POINT;
		
	return CSUDI_TRUE;	
}


//**********************************************************************************//
//********************************* End  Test  CSUDISOCKConnect ********************//
//**********************************************************************************//


//**********************************************************************************//
//********************************* Begin  Test  CSUDISOCKAccept *******************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKAccept
//@DESCRIPTION:服务端响应客户端的连接请求成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、服务端可以创建套接字成功
//@PRECONDITION:3、服务端套接字可以绑定成功
//@PRECONDITION:4、服务端可以置为监听状态
//@PRECONDITION:5、客户端向服务端发起连接请求
//@INPUT:1、nFd 为处于监听状态的套接字描述符
//@INPUT:2、CSUDISockAddr_IN_S sClientAddr，保存客户端地址信息
//@INPUT:3、uAddrLen = sizeof(CSUDISockAddr_S)，结构体CSUDISockAddr_S 的长度
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定,sServAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,10)，使socket处于监听状态，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen) 响应连接，成功返回新套接字描述符nFd2
//@EXECUTIONFLOW: 5、调用CSUDISOCKClose(nFd2) 关闭连接套接字，成功返回0
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd) 关闭监听套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Accept_0001(void)
{   
	int nSockRet = -1;
	int nAcceptRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	WintcpipConfig_S sConfig;

	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nStbPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,10),"步骤3失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_CLIENT;
	sConfig.uBufLen = 1460;
	sConfig.wServerPortForClient = g_nStbPort;
	SOCKET_iInitWintcpip(&sConfig);

	nAcceptRet = CSUDISOCKAccept(nSockRet,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nAcceptRet,"步骤4失败");
	
	CSTK_FATAL_POINT
	if(nAcceptRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nAcceptRet),"步骤5关闭连接套接字失败！");
	}
	
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤6关闭监听套接字失败！");
	}
	
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKAccept
//@DESCRIPTION:非法套接字-1导致服务端响应客户端的连接请求失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、服务端可以创建套接字成功
//@PRECONDITION:3、服务端套接字可以绑定成功
//@PRECONDITION:4、服务端可以置为监听状态
//@PRECONDITION:5、客户端向服务端发起连接请求
//@INPUT:1、nFd1 = -1
//@INPUT:2、CSUDISockAddr_IN_S sClientAddr，保存客户端地址信息
//@INPUT:3、uAddrLen = sizeof(CSUDISockAddr_S)，结构体CSUDISockAddr_S 的长度
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定,sServAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,10)，使socket处于监听状态，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKAccept(-1,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen) 响应连接，失败返回-1
//@EXECUTIONFLOW: 5、调用CSUDISOCKClose(nFd2) 关闭连接套接字，成功返回0
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd) 关闭监听套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Accept_0002(void)
{   
	int nSockRet = -1;
	int nAcceptRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(52000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,10),"步骤3失败");

	nAcceptRet = CSUDISOCKAccept(-1, (CSUDISockAddr_S*)&sClientAddr, &uAddrLen);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nAcceptRet,"步骤4失败");

	CSTK_FATAL_POINT
	if(nAcceptRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nAcceptRet),"步骤5关闭连接套接字失败！");
	}
	
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤6关闭监听套接字失败！");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKAccept
//@DESCRIPTION:存储客户端结构体指针为非法值空导致服务端响应客户端的连接请求失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、服务端可以创建套接字成功
//@PRECONDITION:3、服务端套接字可以绑定成功
//@PRECONDITION:4、服务端可以置为监听状态
//@PRECONDITION:5、客户端向服务端发起连接请求
//@INPUT:1、nFd 为处于监听状态的套接字描述符
//@INPUT:2、CSUDISockAddr_IN_S *sClientAddr = CSUDI_NULL
//@INPUT:3、uAddrLen = sizeof(CSUDISockAddr_S)，结构体CSUDISockAddr_S 的长度
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定,sServAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,10)，使socket处于监听状态，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen) 响应连接，失败返回-1
//@EXECUTIONFLOW: 5、调用CSUDISOCKClose(nFd2) 关闭连接套接字，成功返回0
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd) 关闭监听套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Accept_0003(void)
{   
	int nSockRet = -1;
	int nAcceptRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);

	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(53000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,10),"步骤3失败");

	nAcceptRet = CSUDISOCKAccept(nSockRet, CSUDI_NULL, &uAddrLen);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nAcceptRet,"步骤4失败");

	CSTK_FATAL_POINT
	if(nAcceptRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nAcceptRet),"步骤5关闭连接套接字失败！");
	}
	
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤6关闭监听套接字失败！");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKAccept
//@DESCRIPTION:结构体长度值为非法值0导致服务端响应客户端的连接请求失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、服务端可以创建套接字成功
//@PRECONDITION:3、服务端套接字可以绑定成功
//@PRECONDITION:4、服务端可以置为监听状态
//@PRECONDITION:5、客户端向服务端发起连接请求
//@INPUT:1、nFd 为处于监听状态的套接字描述符
//@INPUT:2、CSUDISockAddr_IN_S sClientAddr，保存客户端地址信息
//@INPUT:3、uAddrLen = sizeof(CSUDISockAddr_S)，结构体CSUDISockAddr_S 的长度
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定,sServAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,10)，使socket处于监听状态，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,0) 响应连接，失败返回-1
//@EXECUTIONFLOW: 5、调用CSUDISOCKClose(nFd2) 关闭连接套接字，成功返回0
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd) 关闭监听套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Accept_0004(void)
{   
	int nSockRet = -1;
	int nAcceptRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;

	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(54000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,10),"步骤3失败");

	nAcceptRet = CSUDISOCKAccept(nSockRet,(CSUDISockAddr_S*)&sClientAddr,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nAcceptRet,"步骤4失败");

	CSTK_FATAL_POINT
	if(nAcceptRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nAcceptRet),"步骤5关闭连接套接字失败！");
	}
	
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤6关闭监听套接字失败！");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKAccept
//@DESCRIPTION:甩信服务端响应客户端的连接请求不成功
//@PRECONDITION:1、协议栈初始化成功, 机顶盒的内核带有蓝牙模块功能(驱动提供)
//@PRECONDITION:2、服务端可以创建套接字成功
//@PRECONDITION:3、服务端套接字可以绑定成功
//@PRECONDITION:4、服务端可以置为监听状态
//@PRECONDITION:5、客户端向服务端发起连接请求
//@INPUT:1、nFd 为处于监听状态的套接字描述符
//@INPUT:2、CSUDISockAddr_IN_S sClientAddr，保存客户端地址信息
//@INPUT:3、uAddrLen = sizeof(CSUDISockAddr_S)，结构体CSUDISockAddr_S 的长度
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM)创建一个蓝牙流式套接字,成功返回nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定,sServAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nSaitionServer);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,10)，使socket处于监听状态，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,(unsigned int*)&uAddrLen) 响应连接，成功返回0
//@EXECUTIONFLOW: 5、调用CSUDISOCKClose(nFd2) 关闭连接套接字，成功返回0
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd) 关闭监听套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Accept_0005(void)
{   
	int nSockRet = -1;
	int nAcceptRet=-1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	
	
	CSUDISockAddr_IN_S sClientAddr= {0};
	CSUDISockAddr_RC_S sServAddr = {0};
	sServAddr.addressFamily = CSUDI_AF_BLUETOOTH;
	sServAddr.port = (unsigned char)g_nSaitionServer & 0xFF;
	sServAddr.btAddr = *CSUDI_BDADDR_ANY;

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,10),"步骤3失败");

	CSUDIOSThreadSleep(1000);
	nAcceptRet = CSUDISOCKAccept(nSockRet,(CSUDISockAddr_S*)&sClientAddr, (unsigned int*)&uAddrLen);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == nAcceptRet,"步骤4失败");

	CSTK_FATAL_POINT
	if(nAcceptRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nAcceptRet),"步骤5关闭连接套接字失败！");
	}
	
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤6关闭监听套接字失败！");
	}

	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKAccept
//@DESCRIPTION:蓝牙服务端响应客户端的连接请求成功
//@PRECONDITION:1、协议栈初始化成功, , 机顶盒的内核带有蓝牙模块功能(驱动提供)。mount的文件中加入了相关版本的蓝牙库和头文件(由驱动提供)
//@PRECONDITION:2、可以调用CSUDIBTSdpRegister()启动机顶盒sdp服务
//@PRECONDITION:3、服务端可以创建套接字成功
//@PRECONDITION:4、服务端套接字可以绑定成功
//@PRECONDITION:5、服务端可以置为监听状态
//@PRECONDITION:6、客户端向服务端发起连接请求
//@INPUT:1、nFd 为处于监听状态的套接字描述符
//@INPUT:2、CSUDISockAddr_IN_S sClientAddr，保存客户端地址信息
//@INPUT:3、uAddrLen = sizeof(CSUDISockAddr_S)，结构体CSUDISockAddr_S 的长度
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDIBTSdpRegister(acSaitionID, 28, acName, acDsc,acProv)注册sdp服务
//@EXECUTIONFLOW: 2、调用CSUDISOCKSocket(CSUDI_AF_BLUETOOTH,CSUDI_SOCK_STREAM,CSUDI_BTPROTO_RFCOMM)创建一个蓝牙流式套接字,成功返回nFd
//@EXECUTIONFLOW: 3、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))将本地主机端口与套接字绑定,sServAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nSaitionServer);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKListen(nFd,10)，使socket处于监听状态，成功返回0
//@EXECUTIONFLOW: 5、调用CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,(unsigned int*)&uAddrLen) 响应连接，成功返回0
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd2) 关闭连接套接字，成功返回0
//@EXECUTIONFLOW: 7、调用CSUDISOCKClose(nFd) 关闭监听套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Accept_0006(void)
{   
	int nSockRet = -1;
	int nAcceptRet=-1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	const char acSaitionID[] = { 0x03, 0xDA, 0x49, 0x59, 0x8A, 0xBA, 0x43, 0xBA,
    							0xB3, 0xD4, 0xC2, 0x77, 0x6B, 0xB0, 0xBB, 0x26};
	const char acName[] = "SaitionServer";
	const char acDsc[] = "Coship Saition Server";
	const char acProv[] = "www.coship.com";

	
	CSUDISockAddr_IN_S sClientAddr= {0};
	CSUDISockAddr_RC_S sServAddr = {0};
	sServAddr.addressFamily = CSUDI_AF_BLUETOOTH;
	sServAddr.port = (unsigned char)g_nSaitionServer & 0xFF;
	sServAddr.btAddr = *CSUDI_BDADDR_ANY;
	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDIBTSdpRegister(acSaitionID, 28, acName, acDsc,acProv),"步骤1失败" );

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤3失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,10),"步骤4失败");

	CSUDIOSThreadSleep(1000);
	nAcceptRet = CSUDISOCKAccept(nSockRet,(CSUDISockAddr_S*)&sClientAddr, (unsigned int*)&uAddrLen);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nAcceptRet,"步骤5失败");

	CSTK_FATAL_POINT
	if(nAcceptRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nAcceptRet),"步骤6关闭连接套接字失败！");
	}
	
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤7关闭监听套接字失败！");
	}

	return CSUDI_TRUE;	
}
//**********************************************************************************//
//********************************* End  Test  CSUDISOCKAccept ****************************//
//**********************************************************************************//

//**********************************************************************************//
//********************************* Begin  Test  CSUDISOCKSend ****************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKETSend
//@DESCRIPTION:pcBuf为空发送数据成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建IPv4流式套接字成功
//@PRECONDITION:3、客户端与服务端可以连接成功
//@INPUT:1、nFd 创建基于IPv4流式套接字的返回值
//@INPUT:2、pcBuf=CSUDI_NULL
//@INPUT:3、uNum = 4 为发送数据字节数
//@INPUT:4、nFlags =0
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4流式套接字,成功返回nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}，成功返回0
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKSend(nFd, pcBuf, uNum, nFlags)向服务器端发送数据，成功返回实际发送字节数
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Send_0001(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);

	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,(CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");      
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKSend(nSockRet, CSUDI_NULL, 4, 0),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤4失败");
	}

	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKETSend
//@DESCRIPTION:套接字非法导致发送数据失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建IPv4流式套接字成功
//@PRECONDITION:3、客户端与服务端可以连接成功
//@INPUT:1、nFd = -1，套接字不是创建所得
//@INPUT:2、szBuf[]="hello world"
//@INPUT:3、uNum = sizeof(szBuf) 为发送数据字节数
//@INPUT:4、nFlags =0
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4流式套接字,成功返回nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}，成功返回0
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKSend(nFd, szBuf, uNum, nFlags)向服务器端发送数据，失败返回-1
CSUDI_BOOL CSTC_SOCKET_IT_Send_0002(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	char szBuf[]="hello world";
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);
	
	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,(CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKSend(-1, szBuf, sizeof(szBuf), 0),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤4失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETSend
//@DESCRIPTION:发送标志为负时发送数据成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建IPv4流式套接字成功
//@PRECONDITION:3、客户端与服务端可以连接成功
//@INPUT:1、nFd 创建IPv4流式套接字的返回值
//@INPUT:2、szBuf[]="hello world"
//@INPUT:3、uNum = sizeof(szBuf) 为发送数据字节数
//@INPUT:4、nFlags =-1
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4流式套接字,成功返回nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}，成功返回0
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKSend(nFd, szBuf, uNum, nFlags)向服务器端发送数据，成功返回实际发送字节数
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Send_0003(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	char szBuf[]="hello world";
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);
	
	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,(CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != CSUDISOCKSend(nSockRet, szBuf, sizeof(szBuf), -1),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤4失败");
	}

	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKETSend
//@DESCRIPTION:发送数据uNum=0xffffffff时发送数据成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建IPv4流式套接字成功
//@PRECONDITION:3、客户端与服务端可以连接成功
//@INPUT:1、nFd 创建IPv4流式套接字的返回值
//@INPUT:2、szBuf[]="hello world"
//@INPUT:3、uNum = 0xffffffff
//@INPUT:4、nFlags =0
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4流式套接字,成功返回nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}，成功返回0
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKSend(nFd, szBuf, uNum, nFlags)向服务器端发送数据，成功返回发送字节数
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Send_0004(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	char szBuf[]="hello world";
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);
	
	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,(CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");

#ifdef PLATFORM_ST40
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKSend(nSockRet, szBuf, 0xffffffff, 0),"步骤3失败");
#else
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != CSUDISOCKSend(nSockRet, szBuf, 0xffffffff, 0),"步骤3失败");
#endif

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤4失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETSend
//@DESCRIPTION:发送数据成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建IPv4流式套接字成功
//@PRECONDITION:3、客户端与服务端可以连接成功
//@INPUT:1、nFd 创建基于IPv4流式套接字的返回值
//@INPUT:2、szBuf[16]="hello world"
//@INPUT:3、uNum = 8
//@INPUT:4、nFlags =0
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4流式套接字,成功返回nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}，成功返回0
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKSend(nFd, szBuf, uNum, nFlags)向服务器端发送数据，成功返回8
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Send_0005(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	char szBuf[]="hello world";
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);
	
	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,(CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != CSUDISOCKSend(nSockRet, szBuf, sizeof(szBuf), 0),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤4失败");
	}

	return CSUDI_TRUE;	
}
//**********************************************************************************//
//********************************* End  Test  CSUDISOCKSend *****************************//
//**********************************************************************************//


//**********************************************************************************//
//********************************* Begin  Test  CSUDISOCKRecv ****************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKRecv
//@DESCRIPTION:接收缓存为空导致接收失败
//@PRECONDITION:1、机顶盒可以创建套接字成功
//@PRECONDITION:2、机顶盒可以与创建套接字绑定成功
//@PRECONDITION:3、机顶盒可以置为监听状态
//@PRECONDITION:4、机顶盒可以接受主机连接
//@INPUT:1、nFd CSUDISOCKAccept返回套接字
//@INPUT:2、pcBuf = CSUDI_NULL
//@INPUT:3、uNum=16 
//@INPUT:4、nFlags =0
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定,sServAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKHtonl(g_szStbIp)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,10)，使socket处于监听状态，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen) 响应连接，成功返回0
//@EXECUTIONFLOW: 5、调用CSUDISOCKRecv(nFd, pcBuf,uNum,nFlags)从客户端接收数据，失败返回-1
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Recv_0001(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	int nRetAccept = -1;
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	WintcpipConfig_S sConfig;
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nStbPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,10),"步骤3失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_CLIENT;
	sConfig.uBufLen = 1460;
	sConfig.wServerPortForClient = 51000;
	SOCKET_iInitWintcpip(&sConfig);

	nRetAccept = CSUDISOCKAccept(nSockRet,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nRetAccept,"步骤4失败");

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKRecv(nRetAccept, CSUDI_NULL, 16, 0),"步骤5失败");

	CSTK_FATAL_POINT
	if(nRetAccept !=-1)
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nRetAccept),"释放连接套接字失败！");
	}
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤6失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKRecv
//@DESCRIPTION:数据报套接字导致接收数据失败
//@PRECONDITION:1、机顶盒可以创建套接字成功
//@PRECONDITION:2、机顶盒可以与创建套接字绑定成功
//@INPUT:1、nFd CSUDISOCKAccept返回套接字
//@INPUT:2、szBuf[16] 
//@INPUT:3、uNum=16 
//@INPUT:4、nFlags =0
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定,sServAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKHtonl(g_szStbIp)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKRecv(nFd, pcBuf,uNum,nFlags)从客户端接收数据，失败返回-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Recv_0002(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char szBuf[16] ;
	int nRetAccept = -1;

	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(53000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKRecv(nRetAccept, szBuf, 16, 0),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤4失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKRecv
//@DESCRIPTION:接收标志非法导致接收失败
//@PRECONDITION:1、机顶盒可以创建套接字成功
//@PRECONDITION:2、机顶盒可以与创建套接字绑定成功
//@PRECONDITION:3、机顶盒可以置为监听状态
//@PRECONDITION:4、机顶盒可以接受主机连接
//@INPUT:1、nFd CSUDISOCKAccept返回套接字
//@INPUT:2、szBuf[16] 
//@INPUT:3、uNum=16 
//@INPUT:4、nFlags =-1
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定,sServAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKHtonl(g_szStbIp)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,10)，使socket处于监听状态，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen) 响应连接，成功返回新套接字描述符nFd2
//@EXECUTIONFLOW: 5、调用CSUDISOCKRecv(nFd, pcBuf,uNum,nFlags)从客户端接收数据，失败返回-1
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd2) 关闭套接字，成功返回0
//@EXECUTIONFLOW: 7、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Recv_0003(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	int nRetAccept = -1;
	char szBuf[16] ;
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	WintcpipConfig_S sConfig;

	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(54000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,10),"步骤3失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_CLIENT;
	sConfig.uBufLen = 1460;
	sConfig.wServerPortForClient = 54000;
	SOCKET_iInitWintcpip(&sConfig);

	nRetAccept = CSUDISOCKAccept(nSockRet,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nRetAccept,"步骤4失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKRecv(nRetAccept, szBuf, 16, -1),"步骤5失败");

	CSTK_FATAL_POINT
	if(nRetAccept!=-1)
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nRetAccept),"步骤6释放连接套接字失败！");
	}
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤7失败");
	}

	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKRecv
//@DESCRIPTION:套接字非法导致接收失败
//@PRECONDITION:1、机顶盒可以创建套接字成功
//@PRECONDITION:2、机顶盒可以与创建套接字绑定成功
//@PRECONDITION:3、机顶盒可以置为监听状态
//@PRECONDITION:4、机顶盒可以接受主机连接
//@INPUT:1、nFd = -1
//@INPUT:2、szBuf[16] 
//@INPUT:3、uNum=16 
//@INPUT:4、nFlags =0
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定,sServAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKHtonl(g_szStbIp)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,10)，使socket处于监听状态，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen) 响应连接，成功返回新套接字描述符nFd2
//@EXECUTIONFLOW: 5、调用CSUDISOCKRecv(nFd, pcBuf,uNum,nFlags)从客户端接收数据，失败返回-1
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd2) 关闭套接字，成功返回0
//@EXECUTIONFLOW: 7、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Recv_0004(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	int nRetAccept = -1;
	char szBuf[16];
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	WintcpipConfig_S sConfig;
	
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(55000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,10),"步骤3失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_CLIENT;
	sConfig.uBufLen = 1460;
	sConfig.wServerPortForClient = 55000;
	SOCKET_iInitWintcpip(&sConfig);

	nRetAccept = CSUDISOCKAccept(nSockRet,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen);

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nRetAccept,"步骤4失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKRecv(-1, szBuf, 16, 0),"步骤5失败");
	CSTK_FATAL_POINT
	if(nRetAccept!=-1)
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nRetAccept),"步骤6释放连接套接字失败！");
	}
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤7失败");
	}
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKRecv
//@DESCRIPTION:接收数据成功
//@PRECONDITION:1、机顶盒可以创建套接字成功
//@PRECONDITION:2、机顶盒可以与创建套接字绑定成功
//@PRECONDITION:3、机顶盒可以置为监听状态
//@PRECONDITION:4、机顶盒可以接受主机连接
//@INPUT:1、nFd CSUDISOCKAccept返回套接字
//@INPUT:2、szBuf[16] 
//@INPUT:3、uNum=16 
//@INPUT:4、nFlags =0
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定,sServAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKHtonl(g_szStbIp)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,10)，使socket处于监听状态，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen) 响应连接，成功返回新套接字描述符nFd2
//@EXECUTIONFLOW: 5、调用CSUDISOCKRecv(nFd, pcBuf,uNum,nFlags)从客户端接收数据，成功返回0
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd2) 关闭套接字，成功返回0
//@EXECUTIONFLOW: 7、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Recv_0005(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	char szBuf[16] ;
	int nRetAccept = -1;
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	WintcpipConfig_S sConfig;

	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(56000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,10),"步骤3失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_CLIENT;
	sConfig.uBufLen = 1460;
	sConfig.wServerPortForClient = 56000;
	SOCKET_iInitWintcpip(&sConfig);

	nRetAccept = CSUDISOCKAccept(nSockRet,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nRetAccept,"步骤4失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != CSUDISOCKRecv(nRetAccept, szBuf, 16, 0),"步骤5失败");

	CSTK_FATAL_POINT
	if(nRetAccept!=-1)
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nRetAccept),"步骤6套接字释放失败");
	}
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤7失败");
	}

	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKRecv
//@DESCRIPTION:接收数据成功
//@PRECONDITION:1、协议栈初始化成功, , 机顶盒的内核带有蓝牙模块功能(驱动提供)。mount的文件中加入了相关版本的蓝牙库和头文件(由驱动提供)
//@PRECONDITION:2、可以调用CSUDIBTSdpRegister()启动机顶盒sdp服务
//@PRECONDITION:3、机顶盒可以创建套接字成功
//@PRECONDITION:4、机顶盒可以与创建套接字绑定成功
//@PRECONDITION:5、机顶盒可以置为监听状态
//@PRECONDITION:6、机顶盒可以接受主机连接
//@INPUT:1、nFd CSUDISOCKAccept返回套接字
//@INPUT:2、szBuf[2048] 
//@INPUT:3、uNum=2048 
//@INPUT:4、nFlags =0
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDIBTSdpRegister(acSaitionID, 28, acName, acDsc,acProv)注册sdp服务
//@EXECUTIONFLOW: 2、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个蓝牙流式套接字,返回值为nFd
//@EXECUTIONFLOW: 3、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定,sServAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKHtonl(g_nSaitionServer)}，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKListen(nFd,10)，使socket处于监听状态，成功返回0
//@EXECUTIONFLOW: 5、调用CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen) 响应连接，成功返回0
//@EXECUTIONFLOW: 6、调用CSUDISOCKRecv(nFd, pcBuf,uNum,nFlags)从客户端接收数据，成功返回0
//@EXECUTIONFLOW: 7、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_BlueTooth_Recv_0006(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_BLUETOOTH;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = CSUDI_BTPROTO_RFCOMM;
	int nRetAccept = -1;
	char acBuf[2048] ;
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	const char acSaitionID[] = { 0x03, 0xDA, 0x49, 0x59, 0x8A, 0xBA, 0x43, 0xBA,
    							0xB3, 0xD4, 0xC2, 0x77, 0x6B, 0xB0, 0xBB, 0x26};
	const char acName[] = "SaitionServer";
	const char acDsc[] = "Coship Saition Server";
	const char acProv[] = "www.coship.com";
	
	CSUDISockAddr_IN_S sClientAddr= {0};
	CSUDISockAddr_RC_S sServAddr = {0};
	sServAddr.addressFamily = CSUDI_AF_BLUETOOTH;
	sServAddr.port = (unsigned char)g_nSaitionServer & 0xFF;
	sServAddr.btAddr = *CSUDI_BDADDR_ANY;

	memset(acBuf, 0, sizeof(acBuf));

	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDIBTSdpRegister(acSaitionID, 28, acName, acDsc,acProv),"步骤1失败" );


	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤3失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,10),"步骤4失败");

	CSUDIOSThreadSleep(1000);

	nRetAccept = CSUDISOCKAccept(nSockRet,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen);

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nRetAccept,"步骤5失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != CSUDISOCKRecv(nRetAccept, acBuf, sizeof(acBuf), 0),"步骤6失败");

	CSTK_FATAL_POINT
	if(nRetAccept !=-1)
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nRetAccept),"释放连接套接字失败！");
	}
	
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤7失败");
	}
	return CSUDI_TRUE;	
}
//**********************************************************************************//
//********************************* End  Test  CSUDISOCKRecv *****************************//
//**********************************************************************************//


//**********************************************************************************//
//********************************* Begin  Test  CSUDISOCKSendTo **************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKETSendTo
//@DESCRIPTION:客户端成功发送数据到服务端
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建基于流式套接字成功
//@PRECONDITION:3、客户端与服务端可以连接成功
//@INPUT:1、nFd 创建基于流式套接字的返回值
//@INPUT:2、szBuf[]="hello world"
//@INPUT:3、uNum = sizeof(szBuf) 为发送数据字节数
//@INPUT:4、nFlags 为发送标志，置为0
//@INPUT:5、psAddr = CSUDI_NULL
//@INPUT:6、uAddrLen = 0
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}，成功返回0
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKSendTo(nFd, szBuf, strlen(pBuf),0,NULL,0))向服务器端发送数据，成功返回11
//@EXECUTIONFLOW: 4、客户端调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SendTo_0001(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	char szBuf[]="hello world";
	CSUDISockAddr_IN_S sServAddr;
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);
	
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");

	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,(CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
#ifdef PLATFORM_ST40
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKSendTo(nSockRet, szBuf, sizeof(szBuf), 0,CSUDI_NULL,0),"步骤3失败");
#else
	CSTK_ASSERT_TRUE_FATAL(12 == CSUDISOCKSendTo(nSockRet, szBuf, sizeof(szBuf), 0,CSUDI_NULL,0),"步骤3失败");
#endif

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤4失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETSendTo
//@DESCRIPTION:基于数据报套接字时客户端成功发送数据到服务端
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建基于数据报套接字成功
//@INPUT:1、nFd 创建基于数据报套接字的返回值
//@INPUT:2、szBuf[]="hello world"
//@INPUT:3、uNum = sizeof(szBuf) 为发送数据字节数
//@INPUT:4、nFlags = 0
//@INPUT:5、sServAddr 为CSUDISockAddr_S类型的结构体sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:6、uAddrLen = sizeof(CSUDISockAddr_S)	
//@EXPECTATION:  成功返回实际发送的字节数11
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0)创建一个IPv4数据报套接字,返回值为nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKSendTo(nFd, szBuf, uNum,0,&sServAddr,uAddrLen)向服务器端发送数据
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SendTo_0002(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char szBuf[]="hello world";
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	
	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(12 == CSUDISOCKSendTo(nSockRet, szBuf, sizeof(szBuf), 0,(CSUDISockAddr_S *)&sServAddr,uAddrLen),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤3失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETSendTo
//@DESCRIPTION:  客户端成功发送比缓存数据长度小的数据
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建基于数据报套接字成功
//@INPUT:1、nFd 创建基于数据报套接字的返回值
//@INPUT:2、szBuf[16]="hello world"
//@INPUT:3、uNum = 8
//@INPUT:4、nFlags = 0
//@INPUT:5、sServAddr 为CSUDISockAddr_S类型的结构体sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:6、uAddrLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回实际发送的字节数8
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0)创建一个IPv4数据报套接字,返回值为nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKSendTo(nFd, szBuf, uNum,0,&sServAddr,uAddrLen)向服务器端发送数据
//@EXECUTIONFLOW: 3、服务端调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SendTo_0003(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char szBuf[]="hello world";
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	CSUDISockAddr_IN_S sServAddr;

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(8 == CSUDISOCKSendTo(nSockRet, szBuf, 8, 0,(CSUDISockAddr_S *)&sServAddr,uAddrLen),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤3失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETSendTo
//@DESCRIPTION:发送数据缓存为空串时发送成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建基于数据报套接字成功
//@INPUT:1、nFd 创建基于数据报套接字的返回值
//@INPUT:2、szBuf[]=""
//@INPUT:3、uNum = sizeof(szBuf)
//@INPUT:4、nFlags = 0
//@INPUT:5、sServAddr 为CSUDISockAddr_S类型的结构体sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:6、uAddrLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION: 失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0)创建一个IPv4数据报套接字,返回值为nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKSendTo(nFd, szBuf, uNum,0,&sServAddr,uAddrLen)向服务器端发送数据，成功返回1
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SendTo_0004(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char szBuf[]="";
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	CSUDISockAddr_IN_S sServAddr;

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(1 == CSUDISOCKSendTo(nSockRet, szBuf, sizeof(szBuf), 0,(CSUDISockAddr_S *)&sServAddr,uAddrLen),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤3失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETSendTo
//@DESCRIPTION:发送数据缓存为空时发送失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建基于数据报套接字成功
//@INPUT:1、nFd 创建基于数据报套接字的返回值
//@INPUT:2、pcBuf=CSUDI_NULL
//@INPUT:3、uNum = 16
//@INPUT:4、nFlags = 0
//@INPUT:5、sServAddr 为CSUDISockAddr_S类型的结构体sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:6、uAddrLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION: 失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0)创建一个IPv4数据报套接字,返回值为nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKSendTo(nFd, pcBuf, uNum,0,&sServAddr,uAddrLen)向服务器端发送数据
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SendTo_0005(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char* pcBuf = CSUDI_NULL;
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	CSUDISockAddr_IN_S sServAddr;

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKSendTo(nSockRet, pcBuf, 16, 0,(CSUDISockAddr_S *)&sServAddr,uAddrLen),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤3失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETSendTo
//@DESCRIPTION:nFd=-1非创建套接字导致发送数据失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建基于数据报套接字成功
//@INPUT:1、nFd = -1
//@INPUT:2、szBuf[]="hello world"
//@INPUT:3、uNum = sizeof(szBuf) 
//@INPUT:4、nFlags = 0
//@INPUT:5、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:6、uAddrLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION: 失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0)创建一个IPv4数据报套接字,返回值为nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKSendTo(-1, pcBuf, uNum,0,&sServAddr,uAddrLen)向服务器端发送数据，失败返回-1
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SendTo_0006(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char szBuf[]="hello world";
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	CSUDISockAddr_IN_S sServAddr;

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKSendTo(-1, szBuf, sizeof(szBuf) , 0,(CSUDISockAddr_S *)&sServAddr,uAddrLen),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤3失败");
	}

	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKETSendTo
//@DESCRIPTION:基于数据报套接字未指定发送地址导致发送数据失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建基于数据报套接字成功
//@INPUT:1、nFd 创建基于数据报套接字的返回值
//@INPUT:2、szBuf[]="hello world"
//@INPUT:3、uNum = sizeof(szBuf) 
//@INPUT:4、nFlags = 0
//@INPUT:5、psServAddr = CSUDI_NULL
//@INPUT:6、uAddrLen = 16
//@EXPECTATION: 失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0)创建一个IPv4数据报套接字,返回值为nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKSendTo(nFd, szBuf, uNum,0,psServAddr,uAddrLen)向服务器端发送数据，失败返回-1
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SendTo_0007(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char szBuf[]="hello world";
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKSendTo(nSockRet, szBuf, sizeof(szBuf) , 0,CSUDI_NULL,uAddrLen),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤3失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETSendTo
//@DESCRIPTION:指定发送IP地址不存在导致发送数据失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建基于数据报套接字成功
//@INPUT:1、nFd 创建基于数据报套接字的返回值
//@INPUT:2、szBuf[]="hello world"
//@INPUT:3、uNum = sizeof(szBuf) 
//@INPUT:4、nFlags = 0
//@INPUT:5、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr("172.30.18.256")}
//@INPUT:6、uAddrLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION: 失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0)创建一个IPv4数据报套接字,返回值为nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))绑定套接字，成功返回0
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKSendTo(nFd, szBuf, uNum,0,&sServAddr,uAddrLen)向服务器端发送数据，失败返回-1
//@EXECUTIONFLOW: 4、客户端调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SendTo_0008(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char szBuf[]="hello world";
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr("172.30.18.256");

	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons( g_nClientPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKSendTo(nSockRet, szBuf, sizeof(szBuf), 0,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S)),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤4失败");
	}

	return CSUDI_TRUE;	
}



//@CASEGROUP:CSUDISOCKETSendTo
//@DESCRIPTION:指定发送端口号为65535 ，发送数据成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建基于数据报套接字成功
//@INPUT:1、nFd 创建基于数据报套接字的返回值
//@INPUT:2、szBuf[]="hello world"
//@INPUT:3、uNum = sizeof(szBuf) 
//@INPUT:4、nFlags = 0
//@INPUT:5、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(65535);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:6、uAddrLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0)创建一个IPv4数据报套接字,返回值为nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))绑定套接字，成功返回0
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKSendTo(nFd, szBuf, uNum,0,&sServAddr,uAddrLen)向服务器端发送数据，成功返回发送字节数
//@EXECUTIONFLOW: 4、客户端调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SendTo_0009(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char szBuf[]="hello world";
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(65535);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons( g_nClientPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != CSUDISOCKSendTo(nSockRet, szBuf, sizeof(szBuf) , 0,(CSUDISockAddr_S *)&sServAddr,uAddrLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤4失败");
	}

	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKETSendTo
//@DESCRIPTION:指定地址族sin_family=0发送数据成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建基于数据报套接字成功
//@INPUT:1、nFd 创建基于数据报套接字的返回值
//@INPUT:2、szBuf[]="hello world"
//@INPUT:3、uNum = sizeof(szBuf) 
//@INPUT:4、nFlags = 0
//@INPUT:5、sServAddr:{sin_family = 0;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:6、uAddrLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION: 失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0)创建一个IPv4数据报套接字,返回值为nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S))绑定套接字，成功返回0
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKSendTo(nFd, szBuf, uNum,0,&sServAddr,uAddrLen)向服务器端发送数据，成功返回发送字节数
//@EXECUTIONFLOW: 4、客户端调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SendTo_0010(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char szBuf[]="hello world";
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;

	sServAddr.sin_family = 0;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons( g_nClientPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != CSUDISOCKSendTo(nSockRet, szBuf, sizeof(szBuf) , 0,(CSUDISockAddr_S *)&sServAddr,uAddrLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤4失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETSendTo
//@DESCRIPTION:指定地址族为非法值32导致发送数据失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建基于数据报套接字成功
//@INPUT:1、nFd 创建基于数据报套接字的返回值
//@INPUT:2、szBuf[]="hello world"
//@INPUT:3、uNum = sizeof(szBuf) 
//@INPUT:4、nFlags = 0
//@INPUT:5、sServAddr:{sin_family = 32;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:6、uAddrLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION: 失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0)创建一个IPv4数据报套接字,返回值为nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKSendTo(nFd, szBuf, uNum,0,&sServAddr,uAddrLen)向服务器端发送数据，失败返回-1
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SendTo_0011(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char szBuf[]="hello world";
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	CSUDISockAddr_IN_S sServAddr;

	sServAddr.sin_family = 32;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
#ifdef PLATFORM_ST40
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != CSUDISOCKSendTo(nSockRet, szBuf, sizeof(szBuf) , 0,(CSUDISockAddr_S *)&sServAddr,uAddrLen),"步骤2失败");
#else
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKSendTo(nSockRet, szBuf, sizeof(szBuf) , 0,(CSUDISockAddr_S *)&sServAddr,uAddrLen),"步骤2失败");
#endif

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤3失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKETSendTo
//@DESCRIPTION:指定地址族为非法值33导致发送数据失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建基于数据报套接字成功
//@INPUT:1、nFd 创建基于数据报套接字的返回值
//@INPUT:2、szBuf[]="hello world"
//@INPUT:3、uNum = sizeof(szBuf) 
//@INPUT:4、nFlags = 0
//@INPUT:5、sServAddr:{sin_family = 33;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:6、uAddrLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION: 失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0)创建一个IPv4数据报套接字,返回值为nFd
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKSendTo(nFd, szBuf, uNum,0,&sServAddr,uAddrLen)向服务器端发送数据，失败返回-1
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SendTo_0012(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char szBuf[]="hello world";
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	CSUDISockAddr_IN_S sServAddr;

	sServAddr.sin_family = 33;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKSendTo(nSockRet, szBuf, sizeof(szBuf) , 0,(CSUDISockAddr_S *)&sServAddr,uAddrLen),"步骤2失败");
	
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤3失败");
	}

	return CSUDI_TRUE;	
}
//**********************************************************************************//
//*************************** End  Test  CSUDISOCKSendTo ****************************//
//**********************************************************************************//



//**********************************************************************************//
//************************** Begin  Test  CSUDISOCKRecvFrom ************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKRecvFrom
//@DESCRIPTION:基于数据报套接字时机顶盒接收数据成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以创建基于IPv4数据报套接字成功
//@PRECONDITION:3、主机可以成功发送数据
//@INPUT:1、nFd， 创建基于IPv4 数据报套接字的返回值
//@INPUT:2、szBuf[16]，接收数据缓存指针
//@INPUT:3、uNum = sizeof(szBuf)
//@INPUT:4、nFlags = 0
//@INPUT:5、sServAddr，保存发送数据方的地址信息
//@INPUT:6、uAddrLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、机顶盒调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报套接字，成功返回nFd
//@EXECUTIONFLOW: 2、机顶盒调用CSUDISOCKBind(nFd,&sClientAddr,sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定成功,sClientAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_szStbIp);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、机顶盒调用CSUDISOCKRecvFrom(nFd,szBuf,uNum,nFlags,&sServtAddr,&uAddrLen) 机顶盒接收PC机发送的数据，成功返回12
//@EXECUTIONFLOW: 4、机顶盒调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_RecvFrom_0001(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char szBuf[16];
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	WintcpipConfig_S sConfig;

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(50000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons(40000);
	sClientAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szClientIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_UDP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_CLIENT;
	sConfig.uBufLen = 1460;
	sConfig.wServerPortForClient = 50000;
	sConfig.wClientPort = 40000;
	SOCKET_iInitWintcpip(&sConfig);

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != CSUDISOCKRecvFrom(nSockRet, szBuf, 16, 0,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤4失败");
	}

	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKRecvFrom
//@DESCRIPTION:基于流式套接字时机顶盒接收数据成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以创建套接字成功
//@PRECONDITION:3、机顶盒可以与创建套接字绑定成功
//@PRECONDITION:4、机顶盒可以置为监听状态
//@PRECONDITION:5、机顶盒可以接受主机连接
//@INPUT:1、nFd， CSUDISOCKAccept的返回套接字
//@INPUT:2、szBuf[16]，接收数据缓存指针
//@INPUT:3、uNum = sizeof(szBuf)
//@INPUT:4、nFlags = 0
//@INPUT:5、psServAddr= CSUDI_NULL
//@INPUT:6、uAddrLen = 0
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、机顶盒调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、机顶盒调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定,sServAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKHtonl(g_szStbIp)}，成功返回0
//@EXECUTIONFLOW: 3、机顶盒调用CSUDISOCKListen(nFd,10)，使socket处于监听状态，成功返回0
//@EXECUTIONFLOW: 4、机顶盒调用CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen) 响应连接，成功返回新套接字描述符bFd2
//@EXECUTIONFLOW: 5、机顶盒调用CSUDISOCKRecvFrom(nFd,szBuf,uNum,nFlags,psServtAddr,uAddrLen) 机顶盒接收PC机发送的数据，成功返回大于0值
//@EXECUTIONFLOW: 6、机顶盒调用CSUDISOCKClose(nFd2) 关闭套接字，成功返回0
//@EXECUTIONFLOW: 7、机顶盒调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_RecvFrom_0002(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	int nRetAccept = -1;
	char szBuf[16];
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	WintcpipConfig_S sConfig;

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(56000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,10),"步骤3失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_CLIENT;
	sConfig.uBufLen = 1460;
	sConfig.wServerPortForClient = 56000;
	SOCKET_iInitWintcpip(&sConfig);

	nRetAccept = CSUDISOCKAccept(nSockRet,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nRetAccept,"步骤4失败");
#ifdef PLATFORM_ST40
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKRecvFrom(nRetAccept, szBuf, 16, 0,CSUDI_NULL,0),"步骤5失败");
#else
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != CSUDISOCKRecvFrom(nRetAccept, szBuf, 16, 0,CSUDI_NULL,0),"步骤5失败");
#endif

	CSTK_FATAL_POINT
	if(nRetAccept!=-1)
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nRetAccept),"步骤6释放连接套接字失败！");
	}
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤7失败");
	}

	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKRecvFrom
//@DESCRIPTION:缓存指针为空时机顶盒接收数据失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以创建基于IPv4数据报套接字成功
//@PRECONDITION:3、主机可以成功发送数据
//@INPUT:1、nFd， 创建基于IPv4 数据报套接字的返回值
//@INPUT:2、pcBuf = CSUDI_NULL
//@INPUT:3、uNum = 16 
//@INPUT:4、nFlags = 0
//@INPUT:5、sServAddr，保存机顶盒的地址信息
//@INPUT:6、uAddrLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、机顶盒调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报套接字，成功返回nFd
//@EXECUTIONFLOW: 2、机顶盒调用CSUDISOCKBind(nFd,&sClientAddr,sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定成功,sClientAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、机顶盒调用CSUDISOCKRecvFrom(nFd,pcBuf,uNum,nFlags,&sServtAddr,&uAddrLen) 机顶盒接收PC机发送的数据，失败返回-1
//@EXECUTIONFLOW: 4、机顶盒调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_RecvFrom_0003(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	WintcpipConfig_S sConfig;
	
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(50000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);
	
	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons(40000);
	sClientAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szClientIp);
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_UDP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_CLIENT;
	sConfig.uBufLen = 1460;
	sConfig.wServerPortForClient = 50000;
	sConfig.wClientPort = 40000;
	SOCKET_iInitWintcpip(&sConfig);

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKRecvFrom(nSockRet, CSUDI_NULL, 16, 0,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤4失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKRecvFrom
//@DESCRIPTION:缓存小于发送数据长度时机顶盒接收数据成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以创建基于IPv4数据报套接字成功
//@PRECONDITION:3、PC机可以成功发送数据"hello world"
//@INPUT:1、nFd， 创建基于IPv4 数据报套接字的返回值
//@INPUT:2、szBuf[4]，接收数据缓存指针
//@INPUT:3、uNum = sizeof(szBuf)
//@INPUT:4、nFlags = 0
//@INPUT:5、sServAddr，保存发送数据方的地址信息
//@INPUT:6、uAddrLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、机顶盒调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报套接字，成功返回nFd
//@EXECUTIONFLOW: 2、机顶盒调用CSUDISOCKBind(nFd,&sClientAddr,sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定成功,sClientAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、机顶盒调用CSUDISOCKRecvFrom(nFd,szBuf,uNum,nFlags,&sServtAddr,&uAddrLen) 服务器端接收客户端发送的数据，成功返回大于0值
//@EXECUTIONFLOW: 4、机顶盒调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_RecvFrom_0004(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char szBuf[4];
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	WintcpipConfig_S sConfig;
	
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(50000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);
	
	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons(40000);
	sClientAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szClientIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_UDP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_CLIENT;
	sConfig.uBufLen = 1460;
	sConfig.wClientPort = 40000;
	sConfig.wServerPortForClient = 50000;
	SOCKET_iInitWintcpip(&sConfig);

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != CSUDISOCKRecvFrom(nSockRet, szBuf, sizeof(szBuf), 0,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen),"步骤3失败");
	
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤4失败");
	}

	return CSUDI_TRUE;	
}


//@CASEGROUP:CSUDISOCKRecvFrom
//@DESCRIPTION:套接字非法时机顶盒接收数据失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以创建基于IPv4数据报套接字成功
//@PRECONDITION:3、PC机可以成功发送数据"hello world"
//@INPUT:1、nFd = -1
//@INPUT:2、szBuf[16]，接收数据缓存指针
//@INPUT:3、uNum = sizeof(szBuf)
//@INPUT:4、nFlags = 0
//@INPUT:5、sServAddr，保存发送数据方的地址信息
//@INPUT:6、uAddrLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报套接字，成功返回nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind(nFd,&sClientAddr,sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定成功,sClientAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKRecvFrom(-1,szBuf,uNum,nFlags,&sServtAddr,&uAddrLen) 机顶盒接收PC机发送的数据， 失败返回-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_RecvFrom_0005(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char szBuf[16];
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(50000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);
	
	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons(40000);
	sClientAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szClientIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKRecvFrom(-1, szBuf, 16, 0,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤4失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKRecvFrom
//@DESCRIPTION:标志位为非法值-1时机顶盒接收数据失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以创建基于IPv4数据报套接字成功
//@PRECONDITION:3、PC机可以成功发送数据"hello world"
//@INPUT:1、nFd， 创建基于IPv4 数据报套接字的返回值
//@INPUT:2、szBuf[16]，接收数据缓存指针
//@INPUT:3、uNum = sizeof(szBuf)
//@INPUT:4、nFlags = -1
//@INPUT:5、sServAddr，保存发送数据方的地址信息
//@INPUT:6、uAddrLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、机顶盒调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报套接字，成功返回nFd
//@EXECUTIONFLOW: 2、机顶盒调用CSUDISOCKBind(nFd,&sClientAddr,sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定成功,sClientAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、机顶盒调用CSUDISOCKRecvFrom(nFd,szBuf,uNum,nFlags,&sServtAddr,&uAddrLen) 机顶盒接收PC机发送的数据， 失败返回-1
//@EXECUTIONFLOW: 4、机顶盒调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_RecvFrom_0006(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_DGRAM;
	int nProtocol = 0;
	char szBuf[16];
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(50000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);
	
	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons(40000);
	sClientAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szClientIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKRecvFrom(nSockRet, szBuf, 16, -1,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤4失败");
	}

	return CSUDI_TRUE;	
}
//**********************************************************************************//
//********************************* End  Test  CSUDISOCKRecvFrom ***********************//
//**********************************************************************************//



//**********************************************************************************//
//*********************************** Begin  Test  CSUDISOCKSelect *************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKSelect
//@DESCRIPTION: 成功检查到套接字集有数据可读
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以创建套接字成功
//@PRECONDITION:3、机顶盒套接字可以绑定成功
//@PRECONDITION:4、机顶盒可以置为监听状态
//@PRECONDITION:5、机顶盒可以接受连接请求
//@INPUT:1、nFds = nFd + 1
//@INPUT:2、psReadnFds = &sReadnFds
//@INPUT:3、psWritenFds = CSUDI_NULL
//@INPUT:4、psExceptnFds  = CSUDI_NULL
//@INPUT:5、psTimeOut  = &sTimeOut，sTimeOut{tv_sec=1；tv_usec=0} 
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、机顶盒调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、机顶盒调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定,sServAddr 为CSUDISockAddr_IN_S类型的结构体:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}，成功返回0
//@EXECUTIONFLOW: 3、机顶盒调用CSUDISOCKListen(nFd,10)，使socket处于监听状态，成功返回0
//@EXECUTIONFLOW: 4、机顶盒调用CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen) 响应连接，成功返回新套接字描述符nFd2
//@EXECUTIONFLOW: 5、机顶盒调用CSUDI_FD_ZERO(&sReadnFds)把套接字集合清空
//@EXECUTIONFLOW: 6、机顶盒调用CSUDI_FD_SET(nFd,&sReadnFds)把套接字句柄加入到监视集合
//@EXECUTIONFLOW: 7、机顶盒调用CSUDISOCKSelect(nFds, psReadnFds, CSUDI_NULL, CSUDI_NULL, psTimeOut)检测是否有可读数据，成功返回大于0值
//@EXECUTIONFLOW: 8、机顶盒调用CSUDI_FD_ISSET(nRet, &sReadnFds)检测套接字是否有数据可读
//@EXECUTIONFLOW: 9、机顶盒调用CSUDISOCKClose(nFd2) 关闭套接字，成功返回0
//@EXECUTIONFLOW: 10、机顶盒调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Select_0001(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	int nRet =-1;
	unsigned int uAddrLen = sizeof(CSUDISockAddr_S);
	CSUDIFdSet_S sReadnFds;
	CSUDITimeval_S sTimeOut;
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	WintcpipConfig_S sConfig;

	sTimeOut.tv_sec = 10;
	sTimeOut.tv_usec = 0;

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(52000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	nSockRet = CSUDISOCKSocket(nDomain, nType, nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet, "步骤1失败");
	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind (nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)), "步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet,10),"步骤3失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_CLIENT;
	sConfig.uBufLen = 1460;
	sConfig.wServerPortForClient = 52000;
	SOCKET_iInitWintcpip(&sConfig);

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE !=(nRet= CSUDISOCKAccept(nSockRet, (CSUDISockAddr_S*)&sClientAddr, &uAddrLen)), "步骤4失败");

	CSUDI_FD_ZERO(&sReadnFds);
	CSUDI_FD_SET(nRet, &sReadnFds);

	CSTK_ASSERT_TRUE_FATAL(0 < CSUDISOCKSelect(nRet+1, &sReadnFds, CSUDI_NULL, CSUDI_NULL, &sTimeOut), "步骤7失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FD_ISSET(nRet, &sReadnFds), "步骤8失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{	
		if(nRet>0)
		{
			CSUDI_FD_CLR(nRet, &sReadnFds);
		}
		
		if(nRet != -1)
		{
			CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nRet), "步骤9失败");
		}
	
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet), "步骤10失败");
	}
	
	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKSelect
//@DESCRIPTION: 成功检查到套接字集有套接字可写
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以成功创建IPv4流式套接字
//@PRECONDITION:3、机顶盒与PC机可以连接成功
//@PRECONDITION:4、机顶盒向PC机可以发送数据成功
//@INPUT:1、nFds = nFd + 1
//@INPUT:2、psReadnFds = CSUDI_NULL
//@INPUT:3、psWritenFds = &sWritenFds
//@INPUT:4、psExceptnFds  = CSUDI_NULL
//@INPUT:5、psTimeOut  = &sTimeOut，sTimeOut{tv_sec=1；tv_usec=0} 
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、机顶盒调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、机顶盒调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))机顶盒向PC机发起连接请求,SServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}，成功返回0
//@EXECUTIONFLOW: 3、机顶盒调用CSUDI_FD_ZERO(&sWritenFds)把套接字集合清空
//@EXECUTIONFLOW: 4、机顶盒调用CSUDI_FD_SET(nFd,&sWritenFds)把套接字句柄加入到监视集合中
//@EXECUTIONFLOW: 5、机顶盒调用CSUDISOCKSelect(nFds, psReadnFds, psWritenFds, psExceptnFds, psTimeOut)检测是否有套接字可写，成功返回大于0值
//@EXECUTIONFLOW: 6、机顶盒调用CSUDI_FD_ISSET(nSockRet, &sWritenFds)检测套接字是否有数据可写
//@EXECUTIONFLOW: 7、机顶盒调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Select_0002(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	CSUDISockAddr_IN_S sServAddr;
	CSUDIFdSet_S sWritenFds;
	CSUDITimeval_S sTimeOut;
	WintcpipConfig_S sConfig;

	sTimeOut.tv_sec = 5;
	sTimeOut.tv_usec = 0;
	
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain, nType, nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSUDISOCKFcntl(nSockRet, CSUDI_F_SETFL, CSUDI_O_NONBLOCK, 0);

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);

	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKConnect(nSockRet, ( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)), "步骤2失败");
	CSUDI_FD_ZERO(&sWritenFds);
	CSUDI_FD_SET(nSockRet, &sWritenFds);
	
	CSTK_ASSERT_TRUE_FATAL(0 < CSUDISOCKSelect(nSockRet+1, CSUDI_NULL, &sWritenFds, CSUDI_NULL, &sTimeOut), "步骤5失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FD_ISSET(nSockRet, &sWritenFds), "步骤6失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{		
		CSUDI_FD_CLR(nSockRet, &sWritenFds);
		CSUDISOCKFcntl(nSockRet, CSUDI_F_SETFL, ~CSUDI_O_NONBLOCK, 0);
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet), "关闭套接字失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKSelect
//@DESCRIPTION: 检查到套接字集没有意外套接字
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以成功创建IPv4流式套接字
//@PRECONDITION:3、机顶盒与PC机可以连接成功
//@PRECONDITION:4、机顶盒向PC机可以发送数据成功
//@INPUT:1、nFds = nFd + 1
//@INPUT:2、psReadnFds = CSUDI_NULL
//@INPUT:3、psWritenFds = CSUDI_NULL
//@INPUT:4、psExceptnFds  = &sErrorFds
//@INPUT:5、psTimeOut  = &sTimeOut，sTimeOut{tv_sec=1；tv_usec=0} 
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、机顶盒调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、机顶盒调用CSUDI_FD_ZERO(&sWritenFds)把套接字集合清空
//@EXECUTIONFLOW: 3、机顶盒调用CSUDI_FD_SET(nFd,&sWritenFds)把套接字句柄加入到监视集合中
//@EXECUTIONFLOW: 4、机顶盒调用CSUDISOCKSelect(nFds, psReadnFds, psWritenFds, psExceptnFds, psTimeOut)检测是否超时，成功返回0
//@EXECUTIONFLOW: 6、机顶盒调用CSUDI_FD_ISSET(nSockRet, &sErrorFds)检测是否有意外状态的套接字
//@EXECUTIONFLOW: 7、机顶盒调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Select_0003(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	CSUDIFdSet_S sErrorFds;
	CSUDITimeval_S sTimeOut;

	sTimeOut.tv_sec = 5;
	sTimeOut.tv_usec = 0;

	nSockRet = CSUDISOCKSocket(nDomain, nType, nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet, "步骤1失败");
	CSUDISOCKFcntl(nSockRet, CSUDI_F_SETFL, CSUDI_O_NONBLOCK, 0);

	CSUDI_FD_ZERO(&sErrorFds);
	CSUDI_FD_SET(nSockRet, &sErrorFds);

	CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKSelect(nSockRet+1, CSUDI_NULL, CSUDI_NULL, &sErrorFds, &sTimeOut), "步骤4失败");
	CSTK_ASSERT_TRUE_FATAL(!CSUDI_FD_ISSET(nSockRet, &sErrorFds), "步骤5失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{		
		CSUDI_FD_CLR(nSockRet, &sErrorFds);
		CSUDISOCKFcntl(nSockRet, CSUDI_F_SETFL, ~CSUDI_O_NONBLOCK, 0);
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet), "关闭套接字失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKSelect
//@DESCRIPTION: 套接字非法导致未能检查到套接字集有数据可读
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以成功创建IPv4流式套接字
//@PRECONDITION:3、机顶盒与PC机可以连接成功
//@PRECONDITION:4、机顶盒向PC机可以发送数据成功
//@INPUT:1、nFds = -1，非最大套接字加1
//@INPUT:2、psReadnFds = &sReadnFds
//@INPUT:3、psWritenFds = CSUDI_NULL
//@INPUT:4、psExceptnFds  = CSUDI_NULL
//@INPUT:5、psTimeOut  = &sTimeOut，sTimeOut{tv_sec=1；tv_usec=0} 
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、机顶盒调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4流式的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、机顶盒调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))机顶盒向PC机发起连接请求,SServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}，成功返回0
//@EXECUTIONFLOW: 3、机顶盒调用CSUDI_FD_ZERO(&sReadnFds)把套接字集合清空
//@EXECUTIONFLOW: 4、机顶盒调用CSUDI_FD_SET(nFd,&sReadnFds)把套接字句柄加入到监视集合中
//@EXECUTIONFLOW: 5、机顶盒调用CSUDISOCKSelect(nFds, psReadnFds, psWritenFds, psExceptnFds, psTimeOut)检测是否有可读数据，失败返回-1
//@EXECUTIONFLOW: 6、机顶盒调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Select_0004(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	CSUDISockAddr_IN_S sServAddr;
	CSUDIFdSet_S sReadnFds;
	CSUDITimeval_S sTimeOut;
	WintcpipConfig_S sConfig;

	sTimeOut.tv_sec = 1;
	sTimeOut.tv_usec = 0;
	
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain, nType, nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet, "步骤1失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);

	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)), "步骤2失败");
	CSUDI_FD_ZERO(&sReadnFds);
	CSUDI_FD_SET(nSockRet,&sReadnFds);
	CSTK_ASSERT_TRUE_FATAL(0 > CSUDISOCKSelect(-1, &sReadnFds, CSUDI_NULL, CSUDI_NULL, &sTimeOut), "步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSUDISOCKFcntl(nSockRet, CSUDI_F_SETFL, ~CSUDI_O_NONBLOCK, 0);
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet), "关闭套接字失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKSelect
//@DESCRIPTION: 检查到套接字集传入timeout为空时会不会死机
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以成功创建IPv4流式套接字
//@PRECONDITION:3、机顶盒与PC机可以连接成功
//@PRECONDITION:4、机顶盒向PC机可以发送数据成功
//@INPUT:1、nFds = nFd + 1
//@INPUT:2、psReadnFds = CSUDI_NULL
//@INPUT:3、psWritenFds = CSUDI_NULL
//@INPUT:4、psExceptnFds  = &sErrorFds
//@INPUT:5、psTimeOut  =  CSUDI_NULL
//@EXPECTATION:  成功返回错误码
//@EXECUTIONFLOW: 1、机顶盒调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、机顶盒调用CSUDISOCKFcntl(nSockRet, CSUDI_F_GETFL, 0, 0)把套接字集合清空
//@EXECUTIONFLOW: 3、机顶盒调用CSUDISOCKFcntl(nSockRet, CSUDI_F_SETFL, nArg | CSUDI_O_NONBLOCK, 0)把套接字句柄加入到监视集合中
//@EXECUTIONFLOW: 4、机顶盒调用CSUDISOCKSelect(nFds, psReadnFds, psWritenFds, psExceptnFds, psTimeOut)检测&sTimeOut为空时是否死机
//@EXECUTIONFLOW: 5、机顶盒调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Select_0005(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	int nArg = -1;
	CSUDIFdSet_S sReadFds;
	CSUDIFdSet_S sWriteFds;
	CSUDIFdSet_S sErrorFds;

	CSTCPrint("该测试用例可能会导致死机，若死机则用例fail\n");
	nSockRet = CSUDISOCKSocket(nDomain, nType, nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet, "步骤1失败");

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != (nArg = CSUDISOCKFcntl(nSockRet, CSUDI_F_GETFL, 0, 0)), "步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != CSUDISOCKFcntl(nSockRet, CSUDI_F_SETFL, nArg | CSUDI_O_NONBLOCK, 0), "步骤3失败");

	CSUDI_FD_ZERO(&sReadFds);
	CSUDI_FD_SET(nSockRet, &sReadFds);
	CSUDI_FD_ZERO(&sWriteFds);
	CSUDI_FD_SET(nSockRet, &sWriteFds);
	CSUDI_FD_ZERO(&sErrorFds);
	CSUDI_FD_SET(nSockRet, &sErrorFds);

	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKSelect(nSockRet+1, &sReadFds, &sWriteFds, &sErrorFds, CSUDI_NULL), "步骤4失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != CSUDISOCKFcntl(nSockRet, CSUDI_F_SETFL, nArg, 0), "还原noblock属性");
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet), "关闭套接字失败");
	}

	return CSUDI_TRUE;
}

//@CASEGROUP:CSUDISOCKSelect
//@DESCRIPTION: 检查CSUDISOCKSelect接口传入timeout为空时是否无限阻塞
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以成功创建IPv4流式套接字
//@PRECONDITION:3、机顶盒与PC机可以连接成功
//@PRECONDITION:4、机顶盒向PC机可以发送数据成功
//@INPUT:1、nfds = nSockRet + 1
//@INPUT:2、psReadnFds = &sReadFds
//@INPUT:3、psWritenFds = CSUDI_NULL
//@INPUT:4、psExceptnFds  = CSUDI_NULL
//@INPUT:5、psTimeOut  =  CSUDI_NULL
//@EXPECTATION:  成功返回错误码
//@EXECUTIONFLOW: 1、机顶盒调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4流式套接字,返回值为nSockRet
//@EXECUTIONFLOW: 2、机顶盒调用CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)将套接字与指定的地址、端口关联
//@EXECUTIONFLOW: 3、机顶盒调用CSUDISOCKListen(nSockRet, 10)开始监听套接字
//@EXECUTIONFLOW: 4、机顶盒调用CSUDISOCKSelect(nfds, psReadnFds, psWritenFds, psExceptnFds, psTimeOut)检测&sTimeOut为空时等待10分钟后接收数据，看是否成功返回
//@EXECUTIONFLOW: 5、机顶盒调用CSUDISOCKClose(nSockRet) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Select_0006(void)
{
	CSUDI_HANDLE hThreadhandle = CSUDI_NULL;
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	int nPriority = 88; // 0-255
	CSUDIFdSet_S sReadFds;
	CSUDISockAddr_IN_S sServAddr;

	CSTCPrint("本用例用于测试CSUDISOCKSelect接口最后一个参数设置为NULL的情况，");
	CSTCPrint("要求至少等待10分钟\n");
	
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(53000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	nSockRet = CSUDISOCKSocket(nDomain, nType, nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet, "步骤1失败");

	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)), "步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKListen(nSockRet, 10), "步骤3失败");
	
	CSUDI_FD_ZERO(&sReadFds);
	CSUDI_FD_SET(nSockRet, &sReadFds);

	// 开启线程定时10分钟
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDIOSThreadCreate("SOCK_Select6Thread1", nPriority, SOCKET_TEST_STACK_SIZE,
	                         SOCKET_Select6Thread1Entry, NULL, &hThreadhandle),
	                         "创建任务失败");

	CSTK_ASSERT_TRUE_FATAL(0 < CSUDISOCKSelect(nSockRet+1, &sReadFds, CSUDI_NULL, CSUDI_NULL, CSUDI_NULL), "步骤4失败");

	CSTK_FATAL_POINT
	{
		if (CSUDI_NULL != hThreadhandle)
		{
			CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDIOSThreadDestroy(hThreadhandle), "删除任务失败");

			hThreadhandle = CSUDI_NULL;
		}
	}

	if (-1 != nSockRet)
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet), "步骤5失败");
	}

	return CSUDI_TRUE;
}


//**********************************************************************************//
//*********************************** End  Test  CSUDISOCKSelect***************************//
//**********************************************************************************//


//**********************************************************************************//
//*********************************** Begin  Test  CSUDISOCKFcntl **************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKFcntl
//@DESCRIPTION: 成功设置套接字为非阻塞模式
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以成功创建IPv4流式套接字
//@INPUT:1、nFd 为创建的套接字返回值
//@INPUT:2、nCmd = CSUDI_F_SETFL  设置给nFd描述符状态标志
//@INPUT:3、nArg1 = CSUDI_O_NONBLOCK  设置为非阻塞模式
//@INPUT:4、nArg2 = CSUDI_NULL
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、机顶盒调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4数据报的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、机顶盒调用CSUDISOCKFcntl(nSockRet, CSUDI_F_GETFL, 0, 0)获取状态，期望成功返回非-1值
//@EXECUTIONFLOW: 3、判断获取的状态不应该包含非阻塞模式
//@EXECUTIONFLOW: 4、机顶盒调用CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, nArg1,nArg2)设置非阻塞，成功返回非-1值
//@EXECUTIONFLOW: 5、机顶盒调用CSUDISOCKFcntl(nSockRet, CSUDI_F_GETFL, 0, 0)获取状态，期望成功返回非-1值
//@EXECUTIONFLOW: 6、判断获取的状态应该包含非阻塞模式
//@EXECUTIONFLOW: 7、机顶盒调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Fcntl_0001(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	int nArg = 0;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != (nArg = CSUDISOCKFcntl(nSockRet, CSUDI_F_GETFL, 0, 0)), "步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(0 == (nArg & CSUDI_O_NONBLOCK), "步骤3，获取状态不应该包含非阻塞模式");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != CSUDISOCKFcntl(nSockRet, CSUDI_F_SETFL, nArg | CSUDI_O_NONBLOCK, 0), "步骤4失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != (nArg = CSUDISOCKFcntl(nSockRet, CSUDI_F_GETFL, 0, 0)), "步骤5失败");
	CSTK_ASSERT_TRUE_FATAL(nArg & CSUDI_O_NONBLOCK, "步骤6，获取状态没有包含非阻塞模式");
 
	CSTK_FATAL_POINT
	if(nSockRet != -1)
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet), "关闭套接字失败");
	}

	return CSUDI_TRUE;
}


//@CASEGROUP:CSUDISOCKFcntl
//@DESCRIPTION: nArg1=-1 导致设置套接字失败
//@PRECONDITION:1、客户端成功创建字节流套接字
//@INPUT:1、nFd 为创建的套接字返回值
//@INPUT:2、nCmd = CSUDI_F_SETFL  
//@INPUT:3、nArg1 = -1  
//@INPUT:4、nArg2 = CSUDI_NULL
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、机顶盒调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4数据报的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、机顶盒调用CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, nArg1,nArg2)，失败返回-1
//@EXECUTIONFLOW: 3、机顶盒调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Fcntl_0002(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKFcntl(nSockRet,CSUDI_F_SETFL,-1,0),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKFcntl
//@DESCRIPTION: 套接字非法导致设置套接字失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以成功创建IPv4流式套接字
//@INPUT:1、nFd = -1
//@INPUT:2、nCmd = CSUDI_F_SETFL  设置给nFd描述符状态标志
//@INPUT:3、nArg1 = CSUDI_O_NONBLOCK  设置为非阻塞模式
//@INPUT:4、nArg2 = CSUDI_NULL 
//@EXPECTATION:  失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、机顶盒调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4数据报的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、机顶盒调用CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, nArg1,nArg2)，失败返回-1
//@EXECUTIONFLOW: 3、机顶盒调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Fcntl_0003(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKFcntl(-1,CSUDI_F_SETFL,CSUDI_O_NONBLOCK,0),"步骤2失败");
 
	CSTK_FATAL_POINT
	return CSUDI_TRUE; 
}
//**********************************************************************************//
//*********************************** End  Test  CSUDISOCKFcntl****************************//
//**********************************************************************************//



//**********************************************************************************//
//********************************* Begin  Test  CSUDISetGetSockOpt **********************//
//**********************************************************************************//
//@CASEGROUP:1、CSUDISOCKSetSockOpt  
//@CASEGROUP:2、CSUDISOCKGetSockOpt  
//@DESCRIPTION: 成功设置和获取套接字选项CSUDI_SO_RCVBUF 的值
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以成功创建IPv4数据报套接字
//@INPUT:1、CSUDISOCKSetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_RCVBUF
//@INPUT:pnOptval = &nSetRecvBuf，其中 nSetRecvBuf=16*1024  
//@INPUT:uOptlen = sizeof(nSetRecvBuf)
//@INPUT:2、CSUDISOCKGetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_RCVBUF
//@INPUT:pnOptval = &nGetRecvBuf，其中nGetRecvBuf = 0
//@INPUT:uOptlen = sizeof(nGetRecvBuf)
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, nLevel, nOptname,pnOptval, uOptlen),设置CSUDI_SO_RCVBUF选项值，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, nLevel, nOptname,pnOptval, &uOptlen),获取CSUDI_SO_RCVBUF选项值，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SetGetSockOpt_0001(void)
{   
	int nSockRet = -1;
	int nSetRecvBuf = 33*1024;  
	int nGetRecvBuf = 0;
	unsigned int uGetRecvBufLen = sizeof(nGetRecvBuf);

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKSetSockOpt(nSockRet, CSUDI_SOL_SOCKET, CSUDI_SO_RCVBUF,&nSetRecvBuf, sizeof(nSetRecvBuf)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKGetSockOpt(nSockRet, CSUDI_SOL_SOCKET, CSUDI_SO_RCVBUF,&nGetRecvBuf, &uGetRecvBufLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:1、CSUDISOCKSetSockOpt  
//@CASEGROUP:2、CSUDISOCKGetSockOpt  
//@DESCRIPTION: 成功设置和获取套接字选项CSUDI_SO_SNDBUF 的值
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以成功创建IPv4数据报套接字
//@INPUT:1、CSUDISOCKSetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_SNDBUF
//@INPUT:pnOptval = &nSetSendBuf，其中 nSetSendBuf=16*1024  
//@INPUT:uOptlen = sizeof(nSetSendBuf)
//@INPUT:2、CSUDISOCKGetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_SNDBUF
//@INPUT:pnOptval = &nGetSendBuf，其中nGetSendBuf = 0
//@INPUT:uOptlen = sizeof(nGetSendBuf)
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, nLevel, nOptname,pnOptval, uOptlen),设置CSUDI_SO_SNDBUF选项值，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, nLevel, nOptname,pnOptval, &uOptlen),获取CSUDI_SO_SNDBUF选项值，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SetGetSockOpt_0002(void)
{   
	int nSockRet = -1;
	int nSetSendBuf = 16*1024;  
	int nGetSendBuf = 0;
	unsigned int uGetSendBufLen = sizeof(nGetSendBuf);

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKSetSockOpt(nSockRet, CSUDI_SOL_SOCKET, CSUDI_SO_SNDBUF,&nSetSendBuf, sizeof(nSetSendBuf)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKGetSockOpt(nSockRet, CSUDI_SOL_SOCKET, CSUDI_SO_SNDBUF,&nGetSendBuf, &uGetSendBufLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:1、CSUDISOCKSetSockOpt  
//@CASEGROUP:2、CSUDISOCKGetSockOpt  
//@DESCRIPTION: 成功设置和获取套接字选项CSUDI_SO_REUSEADDR 的值
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以成功创建IPv4数据报套接字
//@INPUT:1、CSUDISOCKSetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_REUSEADDR
//@INPUT:pnOptval = &nOnOff，其中  nOnOff=1  
//@INPUT:uOptlen = sizeof(nOnOff)
//@INPUT:2、CSUDISOCKGetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_REUSEADDR
//@INPUT:pnOptval = &nOnOff
//@INPUT:uOptlen = sizeof(nOnOff)
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, nLevel, nOptname,pnOptval, uOptlen),设置CSUDI_SO_REUSEADDR选项值，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, nLevel, nOptname,pnOptval, &uOptlen),获取CSUDI_SO_REUSEADDR选项值，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SetGetSockOpt_0003(void)
{   
	int nSockRet = -1;
	int nSetOnOff = 1;  
	int nGetOnOff = 0;
	unsigned int nGetOnOffLen = sizeof(nGetOnOff);

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKSetSockOpt(nSockRet, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR,&nSetOnOff, sizeof(nSetOnOff)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKGetSockOpt(nSockRet, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR,&nGetOnOff, &nGetOnOffLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:1、CSUDISOCKSetSockOpt  
//@CASEGROUP:2、CSUDISOCKGetSockOpt  
//@DESCRIPTION: 成功设置和获取套接字选项CSUDI_SO_BROADCAST 的值
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以成功创建IPv4数据报套接字
//@INPUT:1、CSUDISOCKSetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_BROADCAST
//@INPUT:pnOptval = &nOnOff，其中  nOnOff=1  
//@INPUT:uOptlen = sizeof(nOnOff)
//@INPUT:2、CSUDISOCKGetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_BROADCAST
//@INPUT:pnOptval = &nOnOff
//@INPUT:uOptlen = sizeof(nOnOff)
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, nLevel, nOptname,pnOptval, uOptlen),设置CSUDI_SO_BROADCAST选项值，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, nLevel, nOptname,pnOptval, &uOptlen),获取CSUDI_SO_BROADCAST选项值，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SetGetSockOpt_0004(void)
{   
	int nSockRet = -1;
	int nSetOnOff = 1;  
	int nGetOnOff = 0;
	unsigned int nGetOnOffLen = sizeof(nGetOnOff);

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKSetSockOpt(nSockRet, CSUDI_SOL_SOCKET, CSUDI_SO_BROADCAST,&nSetOnOff, sizeof(nSetOnOff)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKGetSockOpt(nSockRet, CSUDI_SOL_SOCKET, CSUDI_SO_BROADCAST,&nGetOnOff, &nGetOnOffLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:1、CSUDISOCKSetSockOpt  
//@CASEGROUP:2、CSUDISOCKGetSockOpt  
//@DESCRIPTION: 成功设置和获取套接字选项CSUDI_SO_SNDTIMEO 的值
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以成功创建IPv4数据报套接字
//@INPUT:1、CSUDISOCKSetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_SNDTIMEO
//@INPUT:pnOptval = &sSendTimeout，其中  sSendTimeout为5秒  
//@INPUT:uOptlen = sizeof(nSetSendTimeOut)
//@INPUT:2、CSUDISOCKGetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_SNDTIMEO
//@INPUT:pnOptval = &sGetSendTimeout
//@INPUT:uOptlen = sizeof(nGetSendTimeOut)
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, nLevel, nOptname,pnOptval, uOptlen),设置CSUDI_SO_SNDTIMEO选项值，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, nLevel, nOptname,pnOptval, &uOptlen),获取CSUDI_SO_SNDTIMEO选项值，成功返回0
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SetGetSockOpt_0005(void)
{   
	int nSockRet = -1;
	CSUDITimeval_S sSendTimeout = {5, 0};
	CSUDITimeval_S sGetSendTimeout = {0, 0};
	unsigned int nGetSendTimeOutLen = sizeof(sGetSendTimeout);

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet, "步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKSetSockOpt(nSockRet, CSUDI_SOL_SOCKET, CSUDI_SO_SNDTIMEO, &sSendTimeout, sizeof(sSendTimeout)), "步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKGetSockOpt(nSockRet, CSUDI_SOL_SOCKET, CSUDI_SO_SNDTIMEO, &sGetSendTimeout, &nGetSendTimeOutLen), "步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}
//**********************************************************************************//
//******************************** End  Test  CSUDISOCKSetSockOpt*************************//
//**********************************************************************************//


//**********************************************************************************//
//********************************* Begin  Test  CSUDISOCKSetSockOpt **********************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKSetSockOpt  
//@DESCRIPTION: 选项层不匹配导致设置套接字选项失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以成功创建IPv4数据报套接字
//@INPUT:1、CSUDISOCKSetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_IP
//@INPUT:nOptname = CSUDI_SO_RCVBUF
//@INPUT:pnOptval = &nRecvBuf，其中 nRecvBuf=16*1024  
//@INPUT:uOptlen = sizeof(nRecvBuf)
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, nLevel, nOptname,pnOptval, uOptlen),设置CSUDI_SO_RCVBUF选项值为，失败返回-1
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SetSockOpt_0001(void)
{   
	int nSockRet = -1;
	int nSetRecvBuf = 16*1024;  

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKSetSockOpt(nSockRet, CSUDI_SOL_IP, CSUDI_SO_RCVBUF,&nSetRecvBuf, sizeof(nSetRecvBuf)),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSetSockOpt  
//@DESCRIPTION: 选项值指针为空导致设置套接字选项失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以成功创建IPv4数据报套接字
//@INPUT:1、CSUDISOCKSetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_RCVBUF
//@INPUT:pnOptval = CSUDI_NULL
//@INPUT:uOptlen = sizeof(nRecvBuf) ，其中 nRecvBuf=16*1024  
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, nLevel, nOptname,pnOptval, uOptlen),设置CSUDI_SO_RCVBUF选项值为，失败返回-1
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SetSockOpt_0002(void)
{   
	int nSockRet = -1;
	int nSetRecvBuf = 16*1024;  

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKSetSockOpt(nSockRet, CSUDI_SOL_IP, CSUDI_SO_RCVBUF,CSUDI_NULL, sizeof(nSetRecvBuf)),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKSetSockOpt  
//@DESCRIPTION: 缓存为0导致设置套接字选项失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以成功创建IPv4数据报套接字
//@INPUT:1、CSUDISOCKSetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_RCVBUF
//@INPUT:pnOptval = &nRecvBuf，其中 nRecvBuf=16*1024  
//@INPUT:uOptlen = 0
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, nLevel, nOptname,pnOptval, uOptlen),设置CSUDI_SO_RCVBUF选项值为，失败返回-1
//@EXECUTIONFLOW: 3、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_SetSockOpt_0003(void)
{   
	int nSockRet = -1;
	int nSetRecvBuf = 16*1024;  

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKSetSockOpt(nSockRet, CSUDI_SOL_IP, CSUDI_SO_RCVBUF,&nSetRecvBuf, 0),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}
//**********************************************************************************//
//******************************** End  Test  CSUDISOCKSetSockOpt*************************//
//**********************************************************************************//



//**********************************************************************************//
//********************************* Begin  Test  CSUDISOCKGetSockOpt **********************//
//**********************************************************************************//
//@CASEGROUP:1、CSUDISOCKGetSockOpt  
//@DESCRIPTION: 选项层不匹配导致获取套接字选项CSUDI_SO_RCVBUF 失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以成功创建IPv4数据报套接字
//@PRECONDITION:3、可以成功设置套接字选项CSUDI_SO_RCVBUF
//@INPUT:1、CSUDISOCKSetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_RCVBUF
//@INPUT:pnOptval = &nRecvBuf，其中 nRecvBuf=16*1024  
//@INPUT:uOptlen = sizeof(nRecvBuf)
//@INPUT:2、CSUDISOCKGetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_IP
//@INPUT:nOptname = CSUDI_SO_RCVBUF
//@INPUT:pnOptval = &nRecvBuf
//@INPUT:uOptlen = sizeof(nRecvBuf)
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, nLevel, nOptname,pnOptval, uOptlen),设置CSUDI_SO_RCVBUF选项值，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, nLevel, nOptname,pnOptval, &uOptlen),失败返回-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_GetSockOpt_0001(void)
{   
	int nSockRet = -1;
	int nSetRecvBuf = 16*1024;  
	int nGetRecvBuf = 0;
	unsigned int uGetRecvBufLen = sizeof(nGetRecvBuf);

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKSetSockOpt(nSockRet, CSUDI_SOL_SOCKET, CSUDI_SO_RCVBUF,&nSetRecvBuf, sizeof(nSetRecvBuf)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKGetSockOpt(nSockRet, CSUDI_SOL_IP, CSUDI_SO_RCVBUF,&nGetRecvBuf, &uGetRecvBufLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:1、CSUDISOCKGetSockOpt  
//@DESCRIPTION: 未指定选项名导致获取套接字选项CSUDI_SO_RCVBUF 失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以成功创建IPv4数据报套接字
//@PRECONDITION:3、可以成功设置套接字选项CSUDI_SO_RCVBUF
//@INPUT:1、CSUDISOCKSetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_RCVBUF
//@INPUT:pnOptval = &nRecvBuf，其中 nRecvBuf=16*1024  
//@INPUT:uOptlen = sizeof(nRecvBuf)
//@INPUT:2、CSUDISOCKGetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = 0
//@INPUT:pnOptval = &nRecvBuf
//@INPUT:uOptlen = sizeof(nRecvBuf)
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, nLevel, nOptname,pnOptval, uOptlen),设置CSUDI_SO_RCVBUF选项值，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, nLevel, nOptname,pnOptval, &uOptlen),失败返回-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_GetSockOpt_0002(void)
{   
	int nSockRet = -1;
	int nSetRecvBuf = 16*1024;  
	int nGetRecvBuf = 0;
	unsigned int uGetRecvBufLen = sizeof(nGetRecvBuf);

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKSetSockOpt(nSockRet, CSUDI_SOL_SOCKET, CSUDI_SO_RCVBUF,&nSetRecvBuf, sizeof(nSetRecvBuf)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKGetSockOpt(nSockRet, CSUDI_SOL_SOCKET, 0,&nGetRecvBuf, &uGetRecvBufLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:1、CSUDISOCKGetSockOpt  
//@DESCRIPTION: 选项内容指针为空导致获取套接字选项CSUDI_SO_RCVBUF 失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以成功创建IPv4数据报套接字
//@PRECONDITION:3、可以成功设置套接字选项CSUDI_SO_RCVBUF
//@INPUT:1、CSUDISOCKSetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_RCVBUF
//@INPUT:pnOptval = &nRecvBuf，其中 nRecvBuf=16*1024  
//@INPUT:uOptlen = sizeof(nRecvBuf)
//@INPUT:2、CSUDISOCKGetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_RCVBUF
//@INPUT:pnOptval = CSUDI_NULL
//@INPUT:uOptlen = sizeof(nRecvBuf)
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, nLevel, nOptname,pnOptval, uOptlen),设置CSUDI_SO_RCVBUF选项值，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, nLevel, nOptname,pnOptval, &uOptlen),失败返回-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_GetSockOpt_0003(void)
{   
	int nSockRet = -1;
	int nSetRecvBuf = 16*1024;  
	int nGetRecvBuf = 0;
	unsigned int uGetRecvBufLen = sizeof(nGetRecvBuf);

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKSetSockOpt(nSockRet, CSUDI_SOL_SOCKET, CSUDI_SO_RCVBUF,&nSetRecvBuf, sizeof(nSetRecvBuf)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKGetSockOpt(nSockRet, CSUDI_SOL_SOCKET, CSUDI_SO_RCVBUF,CSUDI_NULL, &uGetRecvBufLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}

//@CASEGROUP:1、CSUDISOCKGetSockOpt  
//@DESCRIPTION: 套接字不匹配导致获取套接字选项CSUDI_SO_RCVBUF 失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以成功创建IPv4数据报套接字
//@PRECONDITION:3、可以成功设置套接字选项CSUDI_SO_RCVBUF
//@INPUT:1、CSUDISOCKSetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_SOL_SOCKET
//@INPUT:nOptname = CSUDI_SO_RCVBUF
//@INPUT:pnOptval = &nRecvBuf，其中 nRecvBuf=16*1024  
//@INPUT:uOptlen = sizeof(nRecvBuf)
//@INPUT:2、CSUDISOCKGetSockOpt 函数的参数说明:
//@INPUT:nFd1 与CSUDISOCKSetSockOpt中的nFd不同
//@INPUT:nLevel = CSUDI_SOL_IP
//@INPUT:nOptname = CSUDI_SO_RCVBUF
//@INPUT:pnOptval = &nRecvBuf
//@INPUT:uOptlen = sizeof(nRecvBuf)
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, nLevel, nOptname,pnOptval, uOptlen),设置CSUDI_SO_RCVBUF选项值，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd1, nLevel, nOptname,pnOptval, &uOptlen),失败返回-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_GetSockOpt_0004(void)
{   
	int nSockRet = -1;
	int nSetRecvBuf = 16*1024;  
	int nGetRecvBuf = 0;
	unsigned int uGetRecvBufLen = sizeof(nGetRecvBuf);

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKSetSockOpt(nSockRet, CSUDI_SOL_SOCKET, CSUDI_SO_RCVBUF,&nSetRecvBuf, sizeof(nSetRecvBuf)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKGetSockOpt(nSockRet+1, CSUDI_SOL_SOCKET, CSUDI_SO_RCVBUF,&nGetRecvBuf, &uGetRecvBufLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 
}
//**********************************************************************************//
//******************************** End  Test  CSUDISOCKGetSockOpt*************************//
//**********************************************************************************//



//**********************************************************************************//
//***************************** Begin  Test  CSUDISOCKGetProtoByName **********************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKGetProtoByName
//@DESCRIPTION: 根据协议名称成功获取协议结构体信息
//@PRECONDITION:协议栈初始化成功
//@INPUT:szProtoName[8] = "icmp"
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKGetProtoByName(szProtoName) ，成功返回协议的CSUDIProtoent_S结构体信息
CSUDI_BOOL CSTC_SOCKET_IT_GetProtoByName_0001(void)
{   
	char szProtoName[] = "icmp";
	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_NULL != CSUDISOCKGetProtoByName(szProtoName),"步骤1失败");

	CSTK_FATAL_POINT
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKGetProtoByName
//@DESCRIPTION:协议名为空时获取协议结构体信息
//@PRECONDITION:协议栈初始化成功
//@INPUT:pcProtoName = CSUDI_NULL
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKGetProtoByName(pcProtoName)，失败返回CSUDI_NULL
CSUDI_BOOL CSTC_SOCKET_IT_GetProtoByName_0002(void)
{   
	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_NULL == CSUDISOCKGetProtoByName(CSUDI_NULL),"步骤1失败");

	CSTK_FATAL_POINT
	return CSUDI_TRUE; 
}
//**********************************************************************************//
//**************************** End  Test  CSUDISOCKGetProtoByName*************************//
//**********************************************************************************//

//**********************************************************************************//
//***************************** Begin  Test  CSUDISOCKGetServByName **********************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKGetServByName
//@DESCRIPTION: 通过"radius" 服务和"udp" 协议成功获取CSUDIServent_S 结构体信息
//@PRECONDITION:协议栈初始化成功
//@INPUT:1、szServName = "radius" 远端拨入验证服务
//@INPUT:2、szProtoName = "udp"
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKGetServByName (szServName, szProtoName)，成功返回CSUDIServent_S结构体
CSUDI_BOOL CSTC_SOCKET_IT_GetServByName_0001(void)
{   
	char szServName[] = "radius";
	char szProtoName[] = "udp";
	CSTK_ASSERT_TRUE_FATAL(CSUDI_NULL != CSUDISOCKGetServByName(szServName,szProtoName),"步骤1失败");

	CSTK_FATAL_POINT
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKGetServByName
//@DESCRIPTION: 通过"telnet" 服务和"tcp" 协议成功获取CSUDIServent_S 结构体信息
//@PRECONDITION:协议栈初始化成功
//@INPUT:1、szServName = "telnets" 远端拨入验证服务
//@INPUT:2、szProtoName = "tcp"
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKGetServByName (szServName, szProtoName)，成功返回CSUDIServent_S结构体
CSUDI_BOOL CSTC_SOCKET_IT_GetServByName_0002(void)
{   
	char szServName[] = "telnets";
	char szProtoName[] = "tcp";
	CSTK_ASSERT_TRUE_FATAL(CSUDI_NULL != CSUDISOCKGetServByName(szServName,szProtoName),"步骤1失败");

	CSTK_FATAL_POINT
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKGetServByName
//@DESCRIPTION: 未置服务名导致获取CSUDIServent_S 结构体信息失败
//@PRECONDITION:协议栈初始化成功
//@INPUT:1、pcServName = CSUDI_NULL
//@INPUT:2、szProtoName = "udp"
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKGetServByName (pcServName, szProtoName)，失败返回CSUDI_NULL
CSUDI_BOOL CSTC_SOCKET_IT_GetServByName_0003(void)
{   
	char szProtoName[] = "tcp";
	CSTK_ASSERT_TRUE_FATAL(CSUDI_NULL == CSUDISOCKGetServByName(CSUDI_NULL,szProtoName),"步骤1失败");

	CSTK_FATAL_POINT
	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKGetServByName
//@DESCRIPTION: 未置协议名获取CSUDIServent_S 结构体信息失败
//@PRECONDITION:协议栈初始化成功
//@INPUT:1、szServName = "telnets" 
//@INPUT:2、pcProtoName = CSUDI_NULL
//@EXPECTATION:失败返回非CSUDI_NULL
//@EXECUTIONFLOW: 1、调用CSUDISOCKGetServByName (szServName, pcProtoName)，成功返回CSUDIServent_S结构体
CSUDI_BOOL CSTC_SOCKET_IT_GetServByName_0004(void)
{   
	char szServName[] = "telnets";
	
	#ifdef PLATFORM_ST40
		CSTK_ASSERT_TRUE_FATAL(CSUDI_NULL == CSUDISOCKGetServByName(szServName,CSUDI_NULL),"步骤1失败");
	#else
		CSTK_ASSERT_TRUE_FATAL(CSUDI_NULL != CSUDISOCKGetServByName(szServName,CSUDI_NULL),"步骤1失败");
	#endif
	
	CSTK_FATAL_POINT
	return CSUDI_TRUE; 
}
//**********************************************************************************//
//**************************** End  Test  CSUDISOCKGetServByName*************************//
//**********************************************************************************//


//**********************************************************************************//
//***************************** Begin  Test  CSUDISOCKGetPeerName **********************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKGetPeerName
//@DESCRIPTION: 成功获取服务端地址
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以创建套接字成功
//@PRECONDITION:3、机顶盒与PC机可以连接成功
//@INPUT:1、nFd 创建一个IPv4流式套接字
//@INPUT:2、CSUDISockAddr_IN_S sPeerAddr
//@INPUT:3、uAddrLen =sizeof(sPeerAddr) 
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,&sServAddr,sizeof(CSUDISockAddr_S))机顶盒向PC机发起连接请求,CSUDISockAddr_IN_S sServAddr{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(szServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}，成功返回0
//@EXECUTIONFLOW: 3、调用SUDISOCKGetPeerName(nFd, (CSUDISockAddr_S*)&sPeerAddr,&uAddrLen) ，成功返回0
//@EXECUTIONFLOW: 4、获取连接端socket地址族错误
//@EXECUTIONFLOW: 5、获取连接端socket端口错误
//@EXECUTIONFLOW: 6、获取连接端socketIP地址错误
//@EXECUTIONFLOW: 7、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_GetPeerName_0001(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sPeerAddr;
	WintcpipConfig_S sConfig;

	unsigned int uAddrLen  = sizeof(sPeerAddr);
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);
	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKGetPeerName(nSockRet, (CSUDISockAddr_S*)&sPeerAddr,&uAddrLen),"步骤3失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_AF_INET == sPeerAddr.sin_family, "步骤4失败");
	CSTK_ASSERT_TRUE_FATAL(g_nServPort == CSUDISOCKNtohs(sPeerAddr.sin_port), "步骤5失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDISOCKInet_addr(g_szServIp) == sPeerAddr.sin_addr.s_addr, "步骤6失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKGetPeerName
//@DESCRIPTION: 套接字错误导致获取服务端地址失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以创建套接字成功
//@PRECONDITION:3、机顶盒与PC机可以连接成功
//@INPUT:1、nFd = -1
//@INPUT:2、sPeerAddr
//@INPUT:3、uAddrLen =sizeof(sPeerAddr) 
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,&sServAddr,sizeof(CSUDISockAddr_S))机顶盒向PC机发起连接请求,CSUDISockAddr_IN_S sServAddr{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(szServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}，成功返回0
//@EXECUTIONFLOW: 3、调用SUDISOCKGetPeerName(nFd, (CSUDISockAddr_S*)&sPeerAddr,&uAddrLen) ，失败返回-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_GetPeerName_0002(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sPeerAddr;
	WintcpipConfig_S sConfig;

	unsigned int uAddrLen  = sizeof(sPeerAddr);
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);
	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKGetPeerName(-1, (CSUDISockAddr_S*)&sPeerAddr,&uAddrLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKGetPeerName
//@DESCRIPTION:结构体指针为空导致获取服务端地址失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以创建套接字成功
//@PRECONDITION:3、机顶盒与PC机可以连接成功
//@INPUT:1、nFd 创建一个IPv4流式套接字
//@INPUT:2、psPeerAddr = CSUDI_NULL
//@INPUT:3、uAddrLen =sizeof(CSUDISockAddr_S) 
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,&sServAddr,sizeof(CSUDISockAddr_S))机顶盒向PC机发起连接请求,CSUDISockAddr_IN_S sServAddr{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(szServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}，成功返回0
//@EXECUTIONFLOW: 3、调用SUDISOCKGetPeerName(nFd, psPeerAddr,&uAddrLen) ，失败返回-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_GetPeerName_0003(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sPeerAddr;
	WintcpipConfig_S sConfig;

	unsigned int uAddrLen  = sizeof(sPeerAddr);
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);
	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKGetPeerName(nSockRet, CSUDI_NULL,&uAddrLen),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:CSUDISOCKGetPeerName
//@DESCRIPTION:结构体长度指针为空导致获取服务端地址失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、机顶盒可以创建套接字成功
//@PRECONDITION:3、机顶盒与PC机可以连接成功
//@INPUT:1、nFd 创建一个IPv4流式套接字
//@INPUT:2、sPeerAddr
//@INPUT:3、puAddrLen =CSUDI_NULL
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,&sServAddr,sizeof(CSUDISockAddr_S))机顶盒向PC机发起连接请求,CSUDISockAddr_IN_S sServAddr{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(szServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}，成功返回0
//@EXECUTIONFLOW: 3、调用SUDISOCKGetPeerName(nFd, (CSUDISockAddr_S*)&sPeerAddr,puAddrLen) ，失败返回-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_GetPeerName_0004(void)
{   
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sPeerAddr;
	WintcpipConfig_S sConfig;

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);
	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKGetPeerName(nSockRet, (CSUDISockAddr_S*)&sPeerAddr,CSUDI_NULL),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}

	return CSUDI_TRUE;	
}
//**********************************************************************************//
//**************************** End  Test  CSUDISOCKGetPeerName*************************//
//**********************************************************************************//


//**********************************************************************************//
//****************************** Begin  Test  CSUDISOCKGetSockName ***********************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKGetSockName
//@DESCRIPTION: 获得机顶盒地址
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建套接字成功，返回套接字nFd
//@PRECONDITION:3、套接字可以与机顶盒绑定成功
//@INPUT:1、nFd 创建套接字返回值
//@INPUT:2、sAddr 存储机顶盒地址结构体
//@INPUT:3、uAddrLen =sizeof(CSUDISockAddr_S) 
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind(nFd,(CSUDISockAddr_S*)sClientAddr, sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定。CSUDISockAddr_IN_S{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKInet_addr(g_szClientIp)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockName(nFd,(CSUDISockAddr_S*)&sAddr, &uAddrLen)，成功返回0
//@EXECUTIONFLOW: 4、获取socket地址族错误
//@EXECUTIONFLOW: 5、获取socket端口错误
//@EXECUTIONFLOW: 6、获取socketIP地址错误
//@EXECUTIONFLOW: 7、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_GetSockName_0001(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sClientAddr;
	CSUDISockAddr_IN_S sAddr;

	unsigned int uAddrLen = sizeof(sAddr);
	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons( g_nStbPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKGetSockName(nSockRet,(CSUDISockAddr_S*)&sAddr, &uAddrLen),"步骤3失败");

	CSTK_ASSERT_TRUE_FATAL(CSUDI_AF_INET == sAddr.sin_family, "步骤4失败");
	CSTK_ASSERT_TRUE_FATAL(g_nStbPort == CSUDISOCKNtohs(sAddr.sin_port), "步骤5失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_INADDR_ANY == sAddr.sin_addr.s_addr, "步骤6失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 	
}

//@CASEGROUP:CSUDISOCKGetSockName
//@DESCRIPTION: 套接字非法导致获取机顶盒地址失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建套接字成功，返回套接字nFd
//@PRECONDITION:3、套接字可以与机顶盒绑定成功
//@INPUT:1、nFd+1
//@INPUT:2、sAddr 存储机顶盒地址结构体
//@INPUT:3、uAddrLen =sizeof(CSUDISockAddr_S) 
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind(nFd,(CSUDISockAddr_S*)sClientAddr, sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定。CSUDISockAddr_IN_S{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKInet_addr(g_szClientIp)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockName(nFd+1,(CSUDISockAddr_S*)&sAddr, &uAddrLen)，失败返回错误码
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_GetSockName_0002(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sClientAddr;
	CSUDISockAddr_IN_S sAddr;

	unsigned int uAddrLen = sizeof(sAddr);
	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons( g_nStbPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKGetSockName(nSockRet+1,(CSUDISockAddr_S*)&sAddr, &uAddrLen),"步骤3失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 	
}

//@CASEGROUP:CSUDISOCKGetSockName
//@DESCRIPTION: 地址结构体指针为空导致获取机顶盒地址失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建套接字成功，返回套接字nFd
//@PRECONDITION:3、套接字可以与机顶盒绑定成功
//@INPUT:1、nFd 创建套接字返回值
//@INPUT:2、psAddr = CSUDI_NULL
//@INPUT:3、uAddrLen =sizeof(CSUDISockAddr_S) 
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind(nFd,(CSUDISockAddr_S*)sClientAddr, sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定。CSUDISockAddr_IN_S{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKInet_addr(g_szClientIp)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockName(nFd,psAddr, &uAddrLen)，失败返回错误码
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_GetSockName_0003(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	CSUDISockAddr_IN_S sClientAddr;
	CSUDISockAddr_IN_S sAddr;

	unsigned int uAddrLen = sizeof(sAddr);
	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons( g_nStbPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKGetSockName(nSockRet,CSUDI_NULL, &uAddrLen),"步骤3失败");
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}
	return CSUDI_TRUE; 	
}

//@CASEGROUP:CSUDISOCKGetSockName
//@DESCRIPTION: 长度指针为空导致获取机顶盒地址失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建套接字成功，返回套接字nFd
//@PRECONDITION:3、套接字可以与机顶盒绑定成功
//@INPUT:1、nFd 创建套接字返回值
//@INPUT:2、sAddr 存储机顶盒地址的结构体
//@INPUT:3、puAddrLen =CSUDI_NULL 
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind(nFd,(CSUDISockAddr_S*)sClientAddr, sizeof(CSUDISockAddr_S))将机顶盒端口与套接字绑定。CSUDISockAddr_IN_S{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nStbPort);sin_addr = CSUDISOCKInet_addr(g_szClientIp)}，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockName(nFd,(CSUDISockAddr_S*)&sAddr, puAddrLen)，失败返回错误码
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_GetSockName_0004(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	CSUDISockAddr_IN_S sClientAddr;
	CSUDISockAddr_IN_S sAddr;

	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons( g_nStbPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKBind(nSockRet, (CSUDISockAddr_S*)&sClientAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKGetSockName(nSockRet,(CSUDISockAddr_S*)&sAddr, CSUDI_NULL),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}

	return CSUDI_TRUE; 	
}
//**********************************************************************************//
//***************************** End  Test  CSUDISOCKGetSockName**************************//
//**********************************************************************************//


//**********************************************************************************//
//****************************** Begin  Test  CSUDISOCKGetHostName ***********************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKGetHostName
//@DESCRIPTION: 成功获得本地主机名
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:1、szHostName[16]
//@INPUT:2、uAddrLen = sizeof(szHostName)
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKGetHostName(szHostName,uAddrLen) 获得机顶盒主机名，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_GetHostName_0001(void)
{
	char szHostName[16];

	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKGetHostName(szHostName,16) ,"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKGetHostName
//@DESCRIPTION: 缓存为空导致获取本地主机名失败
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:1、pcHostName = CSUDI_NULL
//@INPUT:2、uAddrLen = 16
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKGetHostName(pcHostName,uAddrLen) 获取机顶盒主机名，失败返回错误码
CSUDI_BOOL CSTC_SOCKET_IT_GetHostName_0002(void)
{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS != CSUDISOCKGetHostName(CSUDI_NULL,16) ,"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}
//**********************************************************************************//
//***************************** End  Test  CSUDISOCKGetHostName**************************//
//**********************************************************************************//


//**********************************************************************************//
//************************** Begin  Test  CSUDISOCKGetHostByAddr ***************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKGetHostByAddr
//@DESCRIPTION:成功获得主机结构体其它信息
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以把点分IP 转换为网络字节序值
//@INPUT:1、CSUDISOCKInet_aton 函数的参数说明:
//@INPUT:szClientAddr = g_szClientIp
//@INPUT:sClientAddr 网络字节序值
//@INPUT:2、CSUDISOCKGetHostByAddr 函数的参数说明:
//@INPUT:sClientAddr 网络字节序值
//@INPUT:uAddrLen = sizeof(sClientAddr)
//@INPUT:nType = CSUDI_AF_INET
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用 CSUDISOCKInet_aton( szClientAddr, &sClientAddr) 把点分ip转换为网络字节序，成功返回非0值
//@EXECUTIONFLOW: 2、调用CSUDISOCKGetHostByAddr (&sClientAddr, uAddrLen, nType)，成功返回指向CSUDIHostent_S结构指针
CSUDI_BOOL CSTC_SOCKET_IT_GetHostByAddr_0001(void)
{
	CSUDIInAddr_S sClientAddr;
	CSUDIHostent_S *p;

	CSTK_ASSERT_TRUE_FATAL(0 != CSUDISOCKInet_aton("127.0.0.1", &sClientAddr) ,"步骤1失败");
	p = CSUDISOCKGetHostByAddr ((void*)(&sClientAddr.s_addr), sizeof(sClientAddr), CSUDI_AF_INET);

#if defined (PLATFORM_ST40)|| defined (PLATFORM_ST20) || defined (PLATFORM_ZORAN)
	if(p == CSUDI_NULL)
	{
		return CSUDI_TRUE; 
	}
#else
	if((p == CSUDI_NULL)&&(CSUDISOCKGetLastError() == 2))
	{
		return CSUDI_TRUE; 
	}
#endif	

	CSTK_ASSERT_TRUE_FATAL(CSUDI_NULL !=p ,"步骤2失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKGetHostByAddr
//@DESCRIPTION:IP地址不是网络字节序导致获得主机其它信息失败
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:1、szClientAddr = g_szClientIp
//@INPUT:2、uAddrLen = sizeof(szClientAddr)
//@INPUT:3、nType = CSUDI_AF_INET
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKGetHostByAddr (szClientAddr, uAddrLen, nType)，失败返回错误码
CSUDI_BOOL CSTC_SOCKET_IT_GetHostByAddr_0002(void)
{
	CSTK_ASSERT_TRUE_FATAL(CSUDI_NULL == CSUDISOCKGetHostByAddr (&g_szStbIp, sizeof(g_szStbIp), CSUDI_AF_INET),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}
//**********************************************************************************//
//**************************** End  Test  CSUDISOCKGetHostByAddr ***************************//
//**********************************************************************************//



//**********************************************************************************//
//**************************** Begin  Test  CSUDISOCKInet_addr *****************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKInet_addr
//@DESCRIPTION:成功把点分IP地址转换为网络字节序地址
//@INPUT:1、szIp[] = "10.10.98.124"
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用 CSUDISOCKInet_addr(szIp)，成功返回0x7c620a0a
CSUDI_BOOL CSTC_SOCKET_IT_Inet_addr_0001(void)
{
	unsigned int uNetIp = 0x7c620a0a;
	char szIp[] = "010.010.098.124"; // 加0的目的是检测驱动是否会误认为是八进制数，一般都认为是点分十进制
	
	CSTK_ASSERT_TRUE_FATAL(uNetIp == CSUDISOCKInet_addr(szIp),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKInet_addr
//@DESCRIPTION:IP地址格式错误导致转换失败
//@INPUT:1、szIP[] = "10.10.98.256"
//@INPUT:2、szDomain[] = "www.baidu.com"
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用 CSUDISOCKInet_addr (szIP)，失败返回-1
//@EXECUTIONFLOW: 2、调用 CSUDISOCKInet_addr (szDomain)，失败返回-1
CSUDI_BOOL CSTC_SOCKET_IT_Inet_addr_0002(void)
{
	char szIp[] = "10.10.98.256";
	char szDomain[] = "www.baidu.com";

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKInet_addr(szIp), "步骤1失败");

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKInet_addr(szDomain), "步骤2失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKInet_addr
//@DESCRIPTION:不支持IP地址导致转换失败
//@INPUT:1、szIP[]  = "255.255.255.255"
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用 CSUDISOCKInet_addr(szIP)，失败返回-1
CSUDI_BOOL CSTC_SOCKET_IT_Inet_addr_0003(void)
{ 
	char szIp[] = "255.255.255.255";

	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKInet_addr(szIp),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}
//**********************************************************************************//
//***************************** End  Test  CSUDISOCKInet_addr *****************************//
//**********************************************************************************//



//**********************************************************************************//
//***************************** Begin  Test  CSUDISOCKInet_aton ****************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKInet_aton 
//@DESCRIPTION:成功把点分IP地址转换为网络字节序地址
//@INPUT:1、szIP[] = "10.10.98.124"
//@INPUT:2、CSUDIInAddr_S sIpNet
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用 CSUDISOCKInet_aton (szIP, &sIpNet)，成功返回非0
//@EXECUTIONFLOW: 2、判断转换结果sIpNet.s_addr应该为0x7c620a0a
CSUDI_BOOL CSTC_SOCKET_IT_Inet_aton_0001(void)
{
	char szIp[] = "010.010.98.124";	/* 改为 "010.010.98.124" 可以检测驱动是否做了8进制转换 */
	CSUDIInAddr_S sIpNet;
	
	CSTK_ASSERT_TRUE_FATAL(0 != CSUDISOCKInet_aton(szIp, &sIpNet), "步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(0x7c620a0a == sIpNet.s_addr, "步骤2失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKInet_aton 
//@DESCRIPTION:IP 地址格式错误导致转换失败
//@INPUT:1、szIP[] = "10.10.98.256"
//@INPUT:2、CSUDIInAddr_S sIpNet
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用 CSUDISOCKInet_aton (szIP, &sIpNet)，失败返回0
CSUDI_BOOL CSTC_SOCKET_IT_Inet_aton_0002(void)
{
	char szIp[] = "10.10.98.256";
	CSUDIInAddr_S sIpNet;
	
	CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKInet_aton(szIp,&sIpNet),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKInet_aton 
//@DESCRIPTION:成功把点分IP地址转换为网络字节序地址
//@INPUT:1、szIP[] = "255.255.255.255"
//@INPUT:2、CSUDIInAddr_S sIpNet
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用 CSUDISOCKInet_aton (szIP, &sIpNet)，成功返回非0
CSUDI_BOOL CSTC_SOCKET_IT_Inet_aton_0003(void)
{
	char szIp[] = "255.255.255.255";
	CSUDIInAddr_S sIpNet;
	
	CSTK_ASSERT_TRUE_FATAL(0 != CSUDISOCKInet_aton(szIp,&sIpNet),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}
//**********************************************************************************//
//****************************** End  Test  CSUDISOCKInet_aton *****************************//
//**********************************************************************************//


//**********************************************************************************//
//***************************** Begin  Test  CSUDISOCKInet_ntoa ****************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKInet_ntoa 
//@DESCRIPTION:成功把网络字节序地址转换为点分IP地址
//@INPUT:1、CSUDIInAddr_S sIpNet ;sIpNet.s_addr = 0x7c620a0a
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKInet_ntoa( s_addr) ，成功返回 10.10.98.124
CSUDI_BOOL CSTC_SOCKET_IT_Inet_ntoa_0001(void)
{
	CSUDIInAddr_S sIpNet ;
	sIpNet.s_addr = 0x7c620a0a;
	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_NULL != CSUDISOCKInet_ntoa(sIpNet),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKInet_ntoa 
//@DESCRIPTION:成功把网络字节序地址转换为点分IP地址
//@INPUT:1、CSUDIInAddr_S sIpNet ;sIpNet.s_addr = 0xffffffff
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKInet_ntoa( s_addr) ，成功返回 255.255.255.255 
CSUDI_BOOL CSTC_SOCKET_IT_Inet_ntoa_0002(void)
{
	CSUDIInAddr_S sIpNet ;
	sIpNet.s_addr = 0xffffffff;
	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_NULL != CSUDISOCKInet_ntoa(sIpNet),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}

//**********************************************************************************//
//****************************** End  Test  CSUDISOCKInet_ntoa *****************************//
//**********************************************************************************//


//**********************************************************************************//
//***************************** Begin  Test  CSUDISOCKInet_pton ****************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKInet_pton 
//@DESCRIPTION:成功把字符串转换成网络地址
//@INPUT:1、szIP[] = "10.10.98.124"
//@INPUT:2、CSUDIInAddr_S sIpNet
//@EXPECTATION:成功返回1
//@EXECUTIONFLOW: 1、调用CSUDISOCKInet_pton(CSUDI_AF_INET, szIp, &sIpNet) ，成功返回1
//@EXECUTIONFLOW: 2、比较网络地址
CSUDI_BOOL CSTC_SOCKET_IT_Inet_pton_0001(void)
{
	char szIp[] = "010.010.98.124"; /* 改为 "010.010.98.124" 可以检测驱动是否做了8进制转换 */
	CSUDIInAddr_S sIpNet ;

	CSTK_ASSERT_TRUE_FATAL(1 == CSUDISOCKInet_pton(CSUDI_AF_INET, szIp, (void*)&sIpNet), "步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(0x7c620a0a == sIpNet.s_addr, "步骤2失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKInet_pton 
//@DESCRIPTION:IP 地址格式错误导致转换失败
//@INPUT:1、szIP[] = "10.10.98.256"
//@INPUT:2、CSUDIInAddr_S sIpNet
//@EXPECTATION:失败返回0
//@EXECUTIONFLOW: 1、调用CSUDISOCKInet_pton(CSUDI_AF_INET, szIp, (void*)&sIpNet) ，失败返回0
CSUDI_BOOL CSTC_SOCKET_IT_Inet_pton_0002(void)
{
	char szIp[] = "10.10.98.256";
	CSUDIInAddr_S sIpNet ;
	
	CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKInet_pton(CSUDI_AF_INET, szIp, (void*)&sIpNet),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}

//**********************************************************************************//
//****************************** End  Test  CSUDISOCKInet_pton *****************************//
//**********************************************************************************//


//**********************************************************************************//
//***************************** Begin  Test  CSUDISOCKInet_ntop ****************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKInet_ntop 
//@DESCRIPTION:成功把网络二进制结构地址转换成字符串地址
//@INPUT:1、char szIp[16] = {0}
//@INPUT:2、CSUDIInAddr_S sIpNet, sIpNet.s_addr = 0x7c620a0a
//@EXPECTATION:成功返回非空地址
//@EXECUTIONFLOW: 1、调用CSUDISOCKInet_ntoa(CSUDI_AF_INET, (void*)&sIpNet, szIp, sizeof(szIp)) ，成功返回非空
//@EXECUTIONFLOW: 2、比较字符串
//@EXECUTIONFLOW: 3、比较字符串地址
CSUDI_BOOL CSTC_SOCKET_IT_Inet_ntop_0001(void)
{
	char szIp[16] = {0};
	const char *pcRet = CSUDI_NULL;
	CSUDIInAddr_S sIpNet ;
	sIpNet.s_addr = 0x7c620a0a;

	pcRet = CSUDISOCKInet_ntop(CSUDI_AF_INET, (void*)&sIpNet, szIp, sizeof(szIp));
	CSTK_ASSERT_TRUE_FATAL(CSUDI_NULL != pcRet, "步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(0 == memcmp("10.10.98.124", szIp, sizeof("10.10.98.124")), "步骤2失败");
	CSTK_ASSERT_TRUE_FATAL((const char *)&szIp == pcRet, "步骤3失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKInet_ntop 
//@DESCRIPTION:成功把网络二进制结构地址转换成字符串地址
//@INPUT:1、char szIp[16] = {0}
//@INPUT:2、CSUDIInAddr_S sIpNet, sIpNet.s_addr = 0xffffffff
//@EXPECTATION:成功返回非空地址
//@EXECUTIONFLOW: 1、调用CSUDISOCKInet_ntoa(CSUDI_AF_INET, (void*)&sIpNet, szIp, sizeof(szIp)) ，成功返回非空
//@EXECUTIONFLOW: 2、比较字符串
//@EXECUTIONFLOW: 3、比较字符串地址
CSUDI_BOOL CSTC_SOCKET_IT_Inet_ntop_0002(void)
{
	char szIp[16] = {0};
	const char *pcRet = CSUDI_NULL;
	CSUDIInAddr_S sIpNet ;
	sIpNet.s_addr = 0xffffffff;

	pcRet = CSUDISOCKInet_ntop(CSUDI_AF_INET, (void*)&sIpNet, szIp, sizeof(szIp));
	CSTK_ASSERT_TRUE_FATAL(CSUDI_NULL != pcRet, "步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(0 == memcmp("255.255.255.255", szIp, sizeof("255.255.255.255")), "步骤2失败");
	CSTK_ASSERT_TRUE_FATAL((const char *)&szIp == pcRet, "步骤3失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 
}

//**********************************************************************************//
//****************************** End  Test  CSUDISOCKInet_ntop *****************************//
//**********************************************************************************//


//**********************************************************************************//
//******************************* Begin  Test  CSUDISOCKNtohs *****************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKNtohs
//@DESCRIPTION:成功把short型的网络字节序转化为主机字节序
//@INPUT:1、ushNet = 41136(0xa0b0)
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用 CSUDISOCKNtohs(ushNet)，成功返回0xb0a0(45216)
CSUDI_BOOL CSTC_SOCKET_IT_Ntohs_0001(void)
{
	CSTK_ASSERT_TRUE_FATAL(0xb0a0 == CSUDISOCKNtohs(0xa0b0),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 	
}

//@CASEGROUP:CSUDISOCKNtohs
//@DESCRIPTION:成功把short型的网络字节序转化为主机字节序
//@INPUT:1、ushNet = 65535(0xffff)
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用 CSUDISOCKNtohs(ushNet)，成功返回65535(0xffff)
CSUDI_BOOL CSTC_SOCKET_IT_Ntohs_0002(void)
{
	CSTK_ASSERT_TRUE_FATAL(0xffff == CSUDISOCKNtohs(0xffff),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 	
}
//**********************************************************************************//
//******************************** End  Test  CSUDISOCKNtohs ******************************//
//**********************************************************************************//


//**********************************************************************************//
//******************************* Begin  Test  CSUDISOCKNtohl *****************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKNtohl
//@DESCRIPTION:成功把long 型的网络字节序转化为主机字节序
//@INPUT:1、ulNet = 2695938256(0xa0b0c0d0)
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用 CSUDISOCKNtohl(ulNet)，成功返回0xd0c0b0a0(3502289056)
CSUDI_BOOL CSTC_SOCKET_IT_Ntohl_0001(void)
{
	CSTK_ASSERT_TRUE_FATAL(0xd0c0b0a0 == CSUDISOCKNtohl(0xa0b0c0d0),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 	
}

//@CASEGROUP:CSUDISOCKNtohl
//@DESCRIPTION:成功把long 型的网络字节序转化为主机字节序
//@INPUT:1、ulNet = 4294967295(0xffffffff)
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用 CSUDISOCKNtohl(ulNet)，成功返回4294967295(0xffffffff)
CSUDI_BOOL CSTC_SOCKET_IT_Ntohl_0002(void)
{
	CSTK_ASSERT_TRUE_FATAL(0xffffffff == CSUDISOCKNtohl(0xffffffff),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 	
}
//**********************************************************************************//
//******************************** End  Test  CSUDISOCKNtohl ******************************//
//**********************************************************************************//


//**********************************************************************************//
//******************************* Begin  Test  CSUDISOCKHtons *****************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKHtons
//@DESCRIPTION:成功把short 型的主机字节序转换为网络字节序
//@INPUT:1、ushHost = 41136(0xa0b0)
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用 CSUDISOCKHtons(ushHost)，成功返回0xb0a0(45216)
CSUDI_BOOL CSTC_SOCKET_IT_Htons_0001(void)
{
	CSTK_ASSERT_TRUE_FATAL(0xb0a0 == CSUDISOCKHtons(0xa0b0),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 	
}

//@CASEGROUP:CSUDISOCKHtons
//@DESCRIPTION:成功把short 型的主机字节序转换为网络字节序
//@INPUT:1、ushHost = 65535(0xffff)
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用 CSUDISOCKHtons(ushHost)，成功返回65535(0xffff)
CSUDI_BOOL CSTC_SOCKET_IT_Htons_0002(void)
{
	CSTK_ASSERT_TRUE_FATAL(0xffff == CSUDISOCKHtons(0xffff),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 	
}
//**********************************************************************************//
//******************************** End  Test  CSUDISOCKHtons ******************************//
//**********************************************************************************//


//**********************************************************************************//
//******************************* Begin  Test  CSUDISOCKHtonl *****************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKHtonl 
//@DESCRIPTION:成功把long 型的主机字节序转换为网络字节序
//@INPUT:1、ulHost = 2695938256(0xa0b0c0d0)
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用 CSUDISOCKHtonl(ulHost)，成功返回0xd0c0b0a0(3502289056)
CSUDI_BOOL CSTC_SOCKET_IT_Htonl_0001(void)
{
	CSTK_ASSERT_TRUE_FATAL(0xd0c0b0a0 == CSUDISOCKHtonl(0xa0b0c0d0),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 	
}

//@CASEGROUP:CSUDISOCKHtonl 
//@DESCRIPTION:成功把long 型的主机字节序转换为网络字节序
//@INPUT:1、ulHost = 4294967295(0xffffffff)
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用 CSUDISOCKHtonl (ulHost)， 成功返回4294967295(0xffffffff)
CSUDI_BOOL CSTC_SOCKET_IT_Htonl_0002(void)
{
	CSTK_ASSERT_TRUE_FATAL(0xffffffff == CSUDISOCKHtonl(0xffffffff),"步骤1失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 	
}
//**********************************************************************************//
//******************************** End  Test  CSUDISOCKHtonl******************************//
//**********************************************************************************//


//**********************************************************************************//
//***************************** Begin  Test  CSUDISOCKShutDown ****************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKShutDown
//@DESCRIPTION:在指定套接字上禁止数据接收成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建字节流套接字成功
//@PRECONDITION:3、套接字可以发送、接收数据
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、nHow = 0
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，成功返回0
//@EXECUTIONFLOW: 3、调用 CSUDISOCKShutDown( nFd, nHow)，成功返回0
//@EXECUTIONFLOW: 4、调用 CSUDISOCKClose ( nFd)，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_ShutDown_0001(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	int nRet;
	CSUDISockAddr_IN_S sServAddr;
	WintcpipConfig_S sConfig;

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);
	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == (nRet=CSUDISOCKShutDown(nSockRet,0)),"步骤3失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKShutDown
//@DESCRIPTION:在指定套接字上禁止数据接收成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建字节流套接字成功
//@PRECONDITION:3、套接字可以发送、接收数据
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、nHow = 1
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，成功返回0
//@EXECUTIONFLOW: 3、调用 CSUDISOCKShutDown( nFd, nHow)，成功返回0
//@EXECUTIONFLOW: 4、调用 CSUDISOCKClose ( nFd)，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_ShutDown_0002(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	CSUDISockAddr_IN_S sServAddr;
	WintcpipConfig_S sConfig;

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);
	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKShutDown(nSockRet,1),"步骤3失败");
	
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKShutDown
//@DESCRIPTION:在指定套接字上同时禁止数据接收和发送成功
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建字节流套接字成功
//@PRECONDITION:3、套接字可以发送、接收数据
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、nHow = 2
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，成功返回0
//@EXECUTIONFLOW: 3、调用 CSUDISOCKShutDown( nFd, nHow)，成功返回0
//@EXECUTIONFLOW: 4、调用 CSUDISOCKClose ( nFd)，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_ShutDown_0003(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	CSUDISockAddr_IN_S sServAddr;
	WintcpipConfig_S sConfig;

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);
	
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,( CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKShutDown(nSockRet,2),"步骤3失败");
	
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKShutDown
//@DESCRIPTION:非创建套接字导致在指定套接字上禁止数据接收失败
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:1、nFd +1(非创建套接字的返回值)
//@INPUT:2、nHow = 0
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用 CSUDISOCKShutDown( nFd+1, nHow)，失败返回-1
//@EXECUTIONFLOW: 3、调用 CSUDISOCKClose ( nFd)，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_ShutDown_0004(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKShutDown(nSockRet+1,0),"步骤2失败");
	
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}

//@CASEGROUP:CSUDISOCKShutDown
//@DESCRIPTION:关闭方式值错误导致在指定套接字上禁止数据接收失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建字节流套接字成功
//@PRECONDITION:3、套接字可以发送、接收数据
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、nHow = 3
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用 CSUDISOCKShutDown( nFd, nHow)，失败返回-1
//@EXECUTIONFLOW: 3、调用 CSUDISOCKClose ( nFd)，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_ShutDown_0005(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKShutDown(nSockRet,3),"步骤2失败");
	
	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS== CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}
//**********************************************************************************//
//****************************** End  Test  CSUDISOCKShutDown*****************************//
//**********************************************************************************//


//**********************************************************************************//
//******************************* Begin  Test  CSUDISOCKClose ******************************//
//**********************************************************************************//
//@CASEGROUP:CSUDISOCKClose
//@DESCRIPTION:成功关闭指定的套接字
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建字节流套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用 CSUDISOCKClose ( nFd)，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Close_0001(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	
	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤2失败");

	CSTK_FATAL_POINT

	return CSUDI_TRUE; 	
}

//@CASEGROUP:CSUDISOCKClose
//@DESCRIPTION:非创建套接字导致套接字关闭失败
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:1、nFd+1 (非套接字描述符)
//@EXPECTATION:失败返回CSUDI_FAILURE
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用 CSUDISOCKClose ( nFd+1)，失败返回-1
//@EXECUTIONFLOW: 3、调用 CSUDISOCKClose ( nFd)，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Close_0002(void)
{
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE == CSUDISOCKClose(nSockRet+1),"步骤2失败");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}

//**********************************************************************************//
//****************************** End  Test  CSUDISOCKClose*****************************//
//**********************************************************************************//


//**********************************************************************************//
//******************************Begin Test  Guitool*******************************//
//**********************************************************************************//

//@CASEGROUP:Web浏览器场景测试
//@DESCRIPTION:非阻塞模式connect成功场景测试
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、启动tcp服务器
//@PRECONDITION:3、g_nServPort为服务器端的IP,g_szServIp为服务器端的端口
//@INPUT:1、nFd为创建的IPv4流式套接字句柄
//@INPUT:2、g_szServIp  可以连通
//@INPUT:3、nTimeOut = 8;
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、初始化相关变量
//@EXECUTIONFLOW: 2、创建socket
//@EXECUTIONFLOW: 3、设置socket为非阻塞模式
//@EXECUTIONFLOW: 4、输入CSUDISockAddr_IN_S并初始化
//@EXECUTIONFLOW: 5、CSUDISOCKConnect连接服务器，若返回-1，转去步骤6；否则转去步骤10
//@EXECUTIONFLOW: 6、CSUDISOCKGetLastError，若错误码为CSUDI_EINPROGRESS | CSUDI_EWOULDBLOCK，转去步骤7；否则转去步骤10
//@EXECUTIONFLOW: 7、CSUDIOSGetTime获取当前时间
//@EXECUTIONFLOW: 8、CSUDISOCKSelect，若返回值小于等于0，转去步骤9；否则转去步骤10
//@EXECUTIONFLOW: 9、CSUDIOSGetTime获取当前时间，如果连接没有超时，转去步骤8,如果超时，转去步骤10
//@EXECUTIONFLOW: 10、恢复环境返回
CSUDI_BOOL CSTC_SOCKET_IT_GT_0001(void)
{
	int nFd = 0;
	CSUDISockAddr_IN_S sServAddr = {0};
	CSUDIFdSet_S sWritenFds;
	CSUDITimeval_S sWaitTime = {0};
	CSUDIOSTimeVal_S sTime1 = {0};
	CSUDIOSTimeVal_S sTime2 = {0};
	int nRet = 0;
	int nConnTimeOut = 8;
	WintcpipConfig_S sConfig;

	nFd = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0);
	CSTK_ASSERT_TRUE_FATAL(nFd != CSUDI_INVALID_SOCKET, "步骤2失败");

	nRet = CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, CSUDI_O_NONBLOCK , 0);
	CSTK_ASSERT_TRUE_FATAL(nRet != -1, "步骤3失败");
	
	memset(&sServAddr,0,sizeof(CSUDISockAddr_IN_S));
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);
	CSTK_ASSERT_TRUE_FATAL(sServAddr.sin_addr.s_addr != -1, "输入2失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);

	nRet = CSUDISOCKConnect(nFd, (CSUDISockAddr_S *)&sServAddr, sizeof(CSUDISockAddr_S));
	if (nRet == -1)
	{
		int nLastError = CSUDISOCKGetLastError();
		switch (nLastError) {
			case CSUDI_EINPROGRESS:
			case CSUDI_EWOULDBLOCK:
			case CSUDI_EALREADY:

				CSUDIOSGetTime(&sTime1);
				do {
					sWaitTime.tv_sec = 0;
					sWaitTime.tv_usec = 50000;

					CSUDI_FD_ZERO(&sWritenFds);
					CSUDI_FD_SET(nFd, &sWritenFds);

					nRet = CSUDISOCKSelect(nFd + 1, NULL, &sWritenFds, NULL, &sWaitTime);
					CSTK_ASSERT_TRUE_FATAL(nRet != -1,"步骤8失败");
					if ( nRet > 0)
					{
						if (CSUDI_FD_ISSET(nFd,&sWritenFds))
						{
							CSUDIOSGetTime(&sTime2);
							break;
						}
					}

					CSUDIOSGetTime(&sTime2);
				}while((sTime2.m_nSecond-sTime1.m_nSecond) < nConnTimeOut);

				CSTK_ASSERT_TRUE_FATAL((sTime2.m_nSecond-sTime1.m_nSecond) < nConnTimeOut,"步骤8失败");

				break;	
			default:
				CSTK_ASSERT_TRUE_FATAL(0,"connect失败");
				break;
		}
	}
	
	CSTK_FATAL_POINT
	if (nFd != -1)
	{
		nRet =  CSUDISOCKClose(nFd);
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == nRet,"关闭套接字失败");
	}
		
	return CSUDI_TRUE;	
}

//@CASEGROUP:Web浏览器场景测试
//@DESCRIPTION:socket能成功设置非阻塞模式场景测试
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:1、nFd为创建的IPv4流式套接字句柄
//@INPUT:2、g_unReachedIp  无法连通
//@INPUT:3、nTimeOut = 3;
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、初始化相关变量
//@EXECUTIONFLOW: 2、创建socket
//@EXECUTIONFLOW: 3、设置socket为非阻塞模式
//@EXECUTIONFLOW: 4、输入CSUDISockAddr_IN_S并初始化
//@EXECUTIONFLOW: 5、CSUDIOSGetTime 获取当前时间
//@EXECUTIONFLOW: 6、CSUDISOCKConnect连接服务器，若返回-1，转去步骤7；否则转去步骤8
//@EXECUTIONFLOW: 7、获取当前时间，并计算connect前后的时间差值，如果差值大于3秒，设置非阻塞模式失败
//@EXECUTIONFLOW: 8、恢复环境返回
CSUDI_BOOL CSTC_SOCKET_IT_GT_0002(void)
{
	int nFd = 0;
	CSUDISockAddr_IN_S sServAddr = {0};
	CSUDIOSTimeVal_S sBeginTime = {0};
	CSUDIOSTimeVal_S sAfterTime = {0};
	int nRet = 0;
	int nTimeOut = 3000;

	nFd = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0);
	CSTK_ASSERT_TRUE_FATAL(nFd != CSUDI_INVALID_SOCKET, "步骤2失败");

	nRet = CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, CSUDI_O_NONBLOCK , 0);
	CSTK_ASSERT_TRUE_FATAL(nRet != -1, "步骤3失败");

	memset(&sServAddr,0,sizeof(CSUDISockAddr_IN_S));
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_unReachedIp);
	CSTK_ASSERT_TRUE_FATAL(sServAddr.sin_addr.s_addr != -1, "输入2失败");

	CSUDIOSGetTime(&sBeginTime);

	nRet = CSUDISOCKConnect(nFd, (CSUDISockAddr_S *)&sServAddr, sizeof(CSUDISockAddr_S));
	CSTK_ASSERT_TRUE_FATAL(nRet == -1, "步骤6失败");
	if (nRet == -1)
	{
		CSUDIOSGetTime(&sAfterTime);
		nRet = (sAfterTime.m_nSecond - sBeginTime.m_nSecond) * 1000 + sAfterTime.m_nMiliSecond - sBeginTime.m_nMiliSecond;
		CSTK_ASSERT_TRUE_FATAL(nRet < nTimeOut, "设置非阻塞模式失败");
	}

	CSTK_FATAL_POINT
	if (nFd != -1)
	{
		nRet =  CSUDISOCKClose(nFd);
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == nRet,"关闭套接字失败");
	}
		
	return CSUDI_TRUE;
}

//@CASEGROUP:Web浏览器场景测试
//@DESCRIPTION:网络不可达的情况下select返回值场景测试
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、g_unReachedIp为服务器端的IP,g_nServPort为服务器端的端口
//@INPUT:1、nFd为创建的IPv4流式套接字句柄
//@INPUT:2、g_unReachedIp 不可达
//@INPUT:3、nTimeOut = 8;
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、初始化相关变量
//@EXECUTIONFLOW: 2、创建socket
//@EXECUTIONFLOW: 3、设置socket为非阻塞模式
//@EXECUTIONFLOW: 4、输入CSUDISockAddr_IN_S并初始化
//@EXECUTIONFLOW: 5、CSUDISOCKConnect连接服务器，若返回-1，转去步骤6；否则转去步骤10
//@EXECUTIONFLOW: 6、CSUDISOCKGetLastError，若错误码为CSUDI_EINPROGRESS | CSUDI_EWOULDBLOCK，转去步骤7；否则转去步骤10
//@EXECUTIONFLOW: 7、CSUDIOSGetTime获取当前时间
//@EXECUTIONFLOW: 8、CSUDISOCKSelect，若返回值小于等于0，转去步骤9；否则转去步骤10
//@EXECUTIONFLOW: 9、CSUDIOSGetTime获取当前时间，如果连接没有超时，转去步骤8,如果超时，转去步骤10
//@EXECUTIONFLOW: 10、恢复环境返回
CSUDI_BOOL CSTC_SOCKET_IT_GT_0003(void)
{
	int nFd = 0;
	CSUDISockAddr_IN_S sServAddr = {0};
	CSUDIFdSet_S sWritenFds;
	CSUDITimeval_S sWaitTime;
	CSUDIOSTimeVal_S sTime1 = {0};
	CSUDIOSTimeVal_S sTime2 = {0};
	int nRet = 0;
	int nConnTimeOut = 8;

	nFd = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0);
	CSTK_ASSERT_TRUE_FATAL(nFd != CSUDI_INVALID_SOCKET, "步骤2失败");

	nRet = CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, CSUDI_O_NONBLOCK , 0);
	CSTK_ASSERT_TRUE_FATAL(nRet != -1, "步骤3失败");

	memset(&sServAddr,0,sizeof(CSUDISockAddr_IN_S));
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_unReachedIp);
	CSTK_ASSERT_TRUE_FATAL(sServAddr.sin_addr.s_addr != -1, "输入2失败");

	nRet = CSUDISOCKConnect(nFd, (CSUDISockAddr_S *)&sServAddr, sizeof(CSUDISockAddr_S));
	CSTK_ASSERT_TRUE_FATAL(nRet == -1, "步骤5失败");
	if (nRet == -1)
	{
		int nLastError = CSUDISOCKGetLastError();
		switch (nLastError) {
			case CSUDI_EINPROGRESS:
			case CSUDI_EWOULDBLOCK:
			case CSUDI_EALREADY:

				CSUDIOSGetTime(&sTime1);
				do {
					sWaitTime.tv_sec = 0;
					sWaitTime.tv_usec = 50000;

					CSUDI_FD_ZERO(&sWritenFds);
					CSUDI_FD_SET(nFd, &sWritenFds);

					nRet = CSUDISOCKSelect(nFd + 1, NULL, &sWritenFds, NULL, &sWaitTime);
					CSTK_ASSERT_TRUE_FATAL(nRet != -1,"步骤8失败");
					if ( nRet > 0)
					{
						if (CSUDI_FD_ISSET(nFd,&sWritenFds))
						{
							int nOptVal = 0;
							unsigned int nOptLen = sizeof(nOptVal);
							int nGetOptRet = CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_ERROR, (void*)&nOptVal, &nOptLen);
							CSTK_ASSERT_TRUE_FATAL(nGetOptRet == 0, "步骤8.5失败");
							CSTCPrint("get socket opt error:%d\n", nOptVal);
							if (nOptVal != 0)
							{
								continue;
							}
							CSUDIOSGetTime(&sTime2);
							break;
						}
					}

					CSUDIOSGetTime(&sTime2);
				}while((sTime2.m_nSecond-sTime1.m_nSecond) < nConnTimeOut);

				CSTK_ASSERT_TRUE_FATAL((sTime2.m_nSecond-sTime1.m_nSecond) >= nConnTimeOut, "步骤9失败");

				break;	
			default:
				CSTK_ASSERT_TRUE_FATAL(0,"connect失败");
				break;
		}
	}

	CSTK_FATAL_POINT
	if (nFd != -1)
	{
		nRet =  CSUDISOCKClose(nFd);
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == nRet,"关闭套接字失败");
	}
		
	return CSUDI_TRUE;
}

//@CASEGROUP:Web浏览器场景测试
//@DESCRIPTION:多个socket同时创建、发送、接受数据场景测试
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、启动tcp服务器
//@PRECONDITION:3、g_szServIp为服务器端的IP,g_nServPort为服务器端的端口
//@INPUT:1、nFd1、nFd2、nFd3、nFd4为创建的IPv4流式套接字句柄
//@INPUT:2、GT_SERVER_IP "172.30.40.26" 可以连通
//@INPUT:3、nTimeOut = 8;
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、初始化相关变量
//@EXECUTIONFLOW: 2、创建socket nFd1、nFd2、nFd3、nFd4
//@EXECUTIONFLOW: 3、设置socket nFd1、nFd2、nFd3、nFd4为非阻塞模式
//@EXECUTIONFLOW: 4、输入CSUDISockAddr_IN_S并初始化
//@EXECUTIONFLOW: 5、从nFd1到nFd4循环步骤6到步骤13
//@EXECUTIONFLOW: 6、CSUDISOCKConnect连接服务器，若返回-1，转去步骤6；否则转去步骤10
//@EXECUTIONFLOW: 7、CSUDISOCKGetLastError，若错误码为CSUDI_EINPROGRESS | CSUDI_EWOULDBLOCK，转去步骤7；否则转去步骤13
//@EXECUTIONFLOW: 8、CSUDIOSGetTime获取当前时间
//@EXECUTIONFLOW: 9、CSUDISOCKSelect，等待链接成功
//@EXECUTIONFLOW: 10、CSUDIOSGetTime获取当前时间，如果连接没有超时，转去步骤8,如果超时，转去步骤13
//@EXECUTIONFLOW: 11、CSUDISOCKSend发送http get请求
//@EXECUTIONFLOW: 12、等待接受数据
//@EXECUTIONFLOW: 13、读数据
//@EXECUTIONFLOW: 14、恢复环境返回
CSUDI_BOOL CSTC_SOCKET_IT_GT_0004(void)
{
	int nFd[5] = {0};
	CSUDISockAddr_IN_S sServAddr = {0};
	CSUDIFdSet_S sWritenFds;
	CSUDIFdSet_S sReadFds;
	CSUDITimeval_S sWaitTime = {0};
	CSUDIOSTimeVal_S sTime1 = {0};
	CSUDIOSTimeVal_S sTime2 = {0};
	int nRet = 0;
	int nConnTimeOut = 8;  //s
	int nReadTimeOut = 60; //s
	int nSelectTimeOut  = 50000; //us  
	int nLen = sizeof(s_aucRecvBuf);//
	int nConnNums = 5;  //同时创建socket的个数
	int i = 0;
	int j = 0;
	int nRestLen = 0; //要发送的剩余数据大小
	int nCounts = 0;
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	sConfig.bDualDataTransport = CSUDI_TRUE;
	SOCKET_iInitWintcpip(&sConfig);

	//创建nConnNums socket
	for (i=0; i<nConnNums; i++)
	{
		nFd[i] = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0);
		CSTK_ASSERT_TRUE_FATAL(nFd[i] != CSUDI_INVALID_SOCKET, "步骤2失败");
	}

	for (i=0; i<nConnNums; i++)
	{
		nRet = CSUDISOCKFcntl(nFd[i], CSUDI_F_SETFL, CSUDI_O_NONBLOCK , 0);
		CSTK_ASSERT_TRUE_FATAL(nRet != -1, "步骤3失败");
	}

	memset(&sServAddr,0,sizeof(CSUDISockAddr_IN_S));
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);
	CSTK_ASSERT_TRUE_FATAL(sServAddr.sin_addr.s_addr != -1, "输入2失败");

	//连接nConnNums socket
	for (i=0; i<nConnNums; i++)
	{
		nRet = CSUDISOCKConnect(nFd[i], (CSUDISockAddr_S *)&sServAddr, sizeof(CSUDISockAddr_S));
		if (nRet == -1)
		{
			int nLastError = CSUDISOCKGetLastError();
			switch (nLastError) {
				case CSUDI_EINPROGRESS:
				case CSUDI_EWOULDBLOCK:
				case CSUDI_EALREADY:

					CSUDIOSGetTime(&sTime1);
					do {
						sWaitTime.tv_sec = 0;
						sWaitTime.tv_usec = nSelectTimeOut;

						CSUDI_FD_ZERO(&sWritenFds);
						CSUDI_FD_SET(nFd[i], &sWritenFds);

						nRet = CSUDISOCKSelect(nFd[i] + 1, NULL, &sWritenFds, NULL, &sWaitTime);
						CSTK_ASSERT_TRUE_FATAL(nRet != -1,"步骤8失败");
						if ( nRet > 0)
						{
							if (CSUDI_FD_ISSET(nFd[i],&sWritenFds))
							{
								CSUDIOSGetTime(&sTime2);
								break;
							}
						}

						CSUDIOSGetTime(&sTime2);
					}while((sTime2.m_nSecond-sTime1.m_nSecond) < nConnTimeOut);

					CSTK_ASSERT_TRUE_FATAL((sTime2.m_nSecond-sTime1.m_nSecond) < nConnTimeOut,"步骤8失败");
					break;	
				default:
					CSTK_ASSERT_TRUE_FATAL(0,"步骤5失败");
					break;
			}
		}

	}

	//nConnNums socket 顺次发送数据
	for (i=0; i<nConnNums; i++)
	{
		nRestLen = nLen;
		for(j=0; nRestLen>0; j++)
		{
			nCounts = (nRestLen > SOCK_TEST_SEND_LEN) ? SOCK_TEST_SEND_LEN : nRestLen;
			nRet = CSUDISOCKSend(nFd[i], s_aucSendBuf+SOCK_TEST_SEND_LEN*j, nCounts, 0);
			CSTK_ASSERT_TRUE_FATAL(nRet != -1,"步骤10失败");
			nRestLen -= nRet;
			CSTCPrint("socket:%d, send:%d\n", nFd[i], nRet);
			CSUDIOSThreadSleep(50);
		}
	}

	//nConnNums socket 顺次发送数据
	for (i=0; i<nConnNums; i++)
	{
		CSUDIOSGetTime(&sTime1);

		//模拟浏览器场景，等待select成功才能调用recv
		do {
			sWaitTime.tv_sec = 0;
			sWaitTime.tv_usec = 50000;

			CSUDI_FD_ZERO(&sReadFds);
			CSUDI_FD_SET(nFd[i], &sReadFds);

			nRet = CSUDISOCKSelect(nFd[i] + 1, &sReadFds, NULL, NULL, &sWaitTime);
			if (nRet > 0)
			{
				if (CSUDI_FD_ISSET(nFd[i],&sReadFds))
				{
					CSUDIOSGetTime(&sTime2);
					break;
				}
			}

			CSUDIOSGetTime(&sTime2);
		}while((sTime2.m_nSecond-sTime1.m_nSecond) < nReadTimeOut);

		CSTK_ASSERT_TRUE_FATAL((sTime2.m_nSecond-sTime1.m_nSecond) < nReadTimeOut,"步骤11失败");

		//接受数据
		nCounts = 0;
		CSUDIOSGetTime(&sTime1);
		do {
			nRet = CSUDISOCKRecv(nFd[i], s_aucRecvBuf+nCounts, nLen-nCounts, 0);
			CSTCPrint("socket:%d, recv:%d\n", nFd[i], nRet);
			if (nRet > 0)
			{
				nCounts += nRet;
			}
			else if (nRet == -1)
			{
				CSTK_ASSERT_TRUE_FATAL(CSUDISOCKGetLastError() == CSUDI_EWOULDBLOCK, "步骤12失败：接收数据失败");
				CSUDIOSGetTime(&sTime2);
				if ((sTime2.m_nSecond-sTime1.m_nSecond) > nReadTimeOut)
				{
					break;
				}
				continue;
			}
			else
			{
				break;
			}
		}while((nLen-nCounts) > 0);
		CSTK_ASSERT_TRUE_FATAL((nLen-nCounts) == 0,"步骤13失败");

		nRet = strncmp(s_aucSendBuf,s_aucRecvBuf,nLen);
		CSTK_ASSERT_TRUE_FATAL(nRet == 0,"步骤14失败");
	}

	CSTK_FATAL_POINT
	for (i=0; i<nConnNums; i++)
	{
		if (nFd[i] != -1)
		{
			nRet =  CSUDISOCKClose(nFd[i]);
			
			CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == nRet,"关闭套接字失败");
		}
	}

	return CSUDI_TRUE;	
}

//**********************************************************************************//
//****************************** End  Test  Guitool*****************************//
//**********************************************************************************//


//**********************************************************************************//
//*************************** Begin  Test  MIDP*************************************//
//**********************************************************************************//

//@CASEGROUP:UDI2 Socket集成测试
//@DESCRIPTION:客户端向服务端发起连接成功。场景来源：midp访问股票
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建IPv4流式套接字成功
//@PRECONDITION:3、对套接字设置接收超时成功(超时时间为2000ms)
//@PRECONDITION:4、对套接字设置发送超时成功(超时时间为5000ms)
//@PRECONDITION:5、对套接字设置可重复使用本地地址成功
//@PRECONDITION:6、选择Win_Tcpip.exe作为服务器，启动Win_Tcpip.exe，选择TCP模式，选择服务器端模式，"接收缓存"设置为1460，"服务端口"设置为5678，选择"双向数据传输"，创建线程
//@PRECONDITION:7、对配置文件进行配置。配置服务器IP(CS_UDI2SOCKET_MIDP_SERVER_IP)为Win_Tcpip.exe的IP，配置服务器端口(CS_UDI2SOCKET_MIDP_SERVER_PORT)为5678
//@PRECONDITION:8、g_nServPort为从配置文件中读取的服务器端的端口，g_szServIp为从配置文件中读取的服务器端的IP
//@INPUT:1、nFd为创建的IPv4流式套接字句柄
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:3、nTimeout=2000(连接超时时间为2000ms)
//@INPUT:4、nMaxSendTimes=3(向服务器端发起的连接次数最多为3次)
//@EXPECTATION:  成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW:1、调用CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0)创建套接字nFd
//@EXECUTIONFLOW:2、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVTIMEO, (char *)&sRecvTimeout, sizeof(sRecvTimeout))设置接收超时
//@EXECUTIONFLOW:3、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDTIMEO, (char *)&sSendTimeout, sizeof(sSendTimeout))设置发送超时
//@EXECUTIONFLOW:4、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR, (char*)&bAddrReused, sizeof(bAddrReused))设置可重复使用本地地址
//@EXECUTIONFLOW:5、调用CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0)|CSUDI_O_NONBLOCK, 0)设置为非阻塞模式
//@EXECUTIONFLOW:6、判断连接是否超时，即nTimeout是否小于0。若是，则跳转至第20步；否则，执行下一步操作
//@EXECUTIONFLOW:7、调用CSUDISOCKConnect(nFd, (CSUDISockAddr_S *)&sServAddr, sizeof(CSUDISockAddr_IN_S))连接服务器，并判断连接是否成功。若是，则跳转至第20步；否则，执行下一步操作
//@EXECUTIONFLOW:8、调用CSUDISOCKGetLastError()获取last error，并判断last error是否为CSUDI_EINPROGRESS、CSUDI_EALREADY或者CSUDI_EWOULDBLOCK。若是，跳转至第11步；否则，执行下一步操作
//@EXECUTIONFLOW:9、判断是否达到最大的连接次数。若是，则跳转至第20步；否则，执行下一步操作
//@EXECUTIONFLOW:10、调用CSUDIOSThreadSleep(500)让当前线程睡眠500ms，然后跳转至第6步
//@EXECUTIONFLOW:11、判断nTimeout是否等于0。若是，则跳转至第13步；否则，执行下一步操作
//@EXECUTIONFLOW:12、设置CSUDISOCKSelect()的等待时间(sWaitTime):{tv_sec=(200+i*200)/1000, tv_usec=((200+i*200)%1000)*1000}，然后跳转至第14步
//@EXECUTIONFLOW:13、设置CSUDISOCKSelect()的等待时间(sWaitTime):{tv_sec=0, tv_usec=0}
//@EXECUTIONFLOW:14、调用CSUDI_FD_ZERO(&sWritenFds)将sWritenFds清零
//@EXECUTIONFLOW:15、调用CSUDI_FD_SET(nFd, &sWritenFds)将nFd加入sWritenFds
//@EXECUTIONFLOW:16、通过调用CSUDISOCKSelect(nFd + 1, NULL, &sWritenFds, NULL, &sWaitTime)再次判断套接字nFd是否连接服务器成功。若是，则执行下一步操作；否则，跳转至第19步
//@EXECUTIONFLOW:17、调用CSUDI_FD_ISSET(nFd, &sWritenFds)检查套接字nFd是否在sWritenFds中(加强判断，确定没有异常发生)。若是，则执行下一步操作；否则，跳转至第19步
//@EXECUTIONFLOW:18、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_ERROR, (void*)&nError, (unsigned int *)&nErrorLength)判断套接字nFd是否有异常发生。若是，则执行下一步操作；否则跳转至第20步
//@EXECUTIONFLOW:19、更新超时时间nTimeout，nTimeout=nTimeout-200*(i+1)；然后跳转至第6步
//@EXECUTIONFLOW:20、调用CSUDISOCKClose(nFd)关闭套接字
CSUDI_BOOL CSTC_SOCKET_IT_MIDP_0001(void)
{
	int i = 0;
	int nFd	 = -1;
	int nRet = -1;
	int nTimeout = 2000;
	int nSendTimes = 0;
	int nMaxSendTimes = 3;
	BOOL bAddrReused	= TRUE;
	CSUDITimeval_S sRecvTimeout = {2, 0};
	CSUDITimeval_S sSendTimeout = {5, 0};
	CSUDIFdSet_S sWritenFds ;
	CSUDITimeval_S sWaitTime = {0};	
	CSUDISockAddr_IN_S sServAddr;
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = g_nServPort;
	sConfig.bDualDataTransport = CSUDI_TRUE;
	SOCKET_iInitWintcpip(&sConfig);

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nFd = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0);
	CSTK_ASSERT_TRUE_FATAL(nFd != CSUDI_INVALID_SOCKET, "步骤1失败：创建套接字失败");

	// 设置接收超时
	nRet = CSUDISOCKSetSockOpt(
		nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVTIMEO, (char *)&sRecvTimeout, sizeof(sRecvTimeout));
	CSTK_ASSERT_TRUE_FATAL(nRet == 0, "步骤2失败：设置接收超时失败");

	// 设置发送超时
	nRet = CSUDISOCKSetSockOpt(
		nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDTIMEO, (char *)&sSendTimeout, sizeof(sSendTimeout));	
	CSTK_ASSERT_TRUE_FATAL(nRet == 0, "步骤3失败：设置发送超时失败");

	// 设置可重复使用本地地址
	nRet = CSUDISOCKSetSockOpt(
		nFd, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR, (char*)&bAddrReused, sizeof(bAddrReused));
	CSTK_ASSERT_TRUE_FATAL(nRet == 0, "步骤4失败：设置可重复使用本地地址失败");

	// 设置套接字为非阻塞模式
	nRet = CSUDISOCKFcntl(
		nFd, CSUDI_F_SETFL, CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0)|CSUDI_O_NONBLOCK, 0);
	CSTK_ASSERT_TRUE_FATAL(nRet != -1, "步骤5失败：设置套接字为非阻塞模式失败");

	while (TRUE)
	{
		CSTK_ASSERT_TRUE_FATAL(nTimeout >= 0, "步骤6失败：超时导致连接失败");

		nRet = CSUDISOCKConnect(
			nFd, (CSUDISockAddr_S *)&sServAddr, sizeof(CSUDISockAddr_IN_S));

		if (nRet != 0)
		{
			int nLastError = CSUDISOCKGetLastError();
			if( nLastError != CSUDI_EINPROGRESS 
				&& nLastError != CSUDI_EALREADY 
				&& nLastError != CSUDI_EWOULDBLOCK)
			{
				nSendTimes++;
				
				CSTK_ASSERT_TRUE_FATAL(
					nSendTimes < nMaxSendTimes, 
					"步骤9失败：超过最大连接次数导致连接失败");
					
				CSUDIOSThreadSleep(500);
				continue;
			}

			if(nTimeout == 0)
			{			
				sWaitTime.tv_sec = 0;
				sWaitTime.tv_usec = 0;
			}
			else
			{
				sWaitTime.tv_sec = (200 + i * 200) / 1000;
				sWaitTime.tv_usec = ((200 + i * 200) % 1000) * 1000;
			}

			CSUDI_FD_ZERO(&sWritenFds);
			CSUDI_FD_SET(nFd, &sWritenFds);

			nRet = CSUDISOCKSelect(nFd + 1, NULL, &sWritenFds, NULL, &sWaitTime);
			if (nRet > 0)           
			{
				if (CSUDI_FD_ISSET(nFd, &sWritenFds))
				{
					int nError;
					int nErrorLength = sizeof(nError);

					// 查看套接字nFd是否发生异常
					CSUDISOCKGetSockOpt(
						nFd, 
						CSUDI_SOL_SOCKET, 
						CSUDI_SO_ERROR, 
						(void*)&nError, 
						(unsigned int *)&nErrorLength);

					if(nError == 0)
					{
						break;
					}
				}
			}
		} 
		else
		{
			break;
		}

		nTimeout -= 200 * (i + 1);
		i++;
	}
	
	CSTK_FATAL_POINT
	if (nFd != CSUDI_INVALID_SOCKET)
	{
		CSTK_ASSERT_TRUE_FATAL(
			CSUDISOCKClose(nFd) == CSUDI_SUCCESS,
			"步骤20失败：关闭套接字失败");
	}
	
	return CSUDI_TRUE;
}

/*
	函数：	CSSOCKET_MIDP_iConnect
	描述：	将套接字连接到指定服务器上
	输入：
			nFd - 套接字句柄
			pcServerAddr - 服务器端ip地址
			ushServerPort - 服务器端端口号
			nTimeout - 连接超时时间
	输出：
			无
	返回：
			TRUE - 连接成功
			FALSE - 连接失败
	备注：
			无
*/
static BOOL CSSOCKET_MIDP_iConnect(
								   int nFd, 
								   char * pcServerAddr, 
								   USHORT ushServerPort, 
								   int nTimeout)
{
	int i = 0;
	int nRet = -1;
	int nPreMode = -1;
	int nSendTimes = 0;

	CSUDIFdSet_S sWritenFds ;
	CSUDITimeval_S sWaitTime = {0};
	CSUDISockAddr_IN_S sServerAddr = {0};

	if (nFd == CSUDI_INVALID_SOCKET || pcServerAddr == NULL || nTimeout < 0)
	{
		CSTCPrint("[%s.%d] arguments illegal\n", __FUNCTION__, __LINE__);
		return FALSE;
	}

	sServerAddr.sin_family = CSUDI_AF_INET;
	sServerAddr.sin_port = CSUDISOCKHtons(ushServerPort);
	sServerAddr.sin_addr.s_addr = CSUDISOCKInet_addr(pcServerAddr);

	nPreMode = CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0);
	if (nPreMode == -1)
	{
		CSTCPrint("[%s.%d] CSUDISOCKFcntl failed\n", __FUNCTION__, __LINE__);
		return FALSE;
	}

	// 设置套接字为非阻塞模式
	nRet = CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, nPreMode|CSUDI_O_NONBLOCK, 0);
	if (nRet == -1)
	{
		CSTCPrint("[%s.%d] CSUDISOCKFcntl failed\n", __FUNCTION__, __LINE__);
		return FALSE;
	}

	while (nTimeout >= 0)
	{
		nRet = CSUDISOCKConnect(
			nFd, (CSUDISockAddr_S *)&sServerAddr, sizeof(CSUDISockAddr_IN_S));

		if (nRet != 0)
		{
			int nLastError = CSUDISOCKGetLastError();
			if( nLastError != CSUDI_EINPROGRESS 
				&& nLastError != CSUDI_EALREADY 
				&& nLastError != CSUDI_EWOULDBLOCK)
			{
				nSendTimes++;

				if (nSendTimes >= 3)
				{
					break;
				}

				CSUDIOSThreadSleep(500);
				continue;
			}

			if(nTimeout == 0)
			{			
				sWaitTime.tv_sec = 0;
				sWaitTime.tv_usec = 0;
			}
			else
			{
				sWaitTime.tv_sec = (200 + i * 200) / 1000;
				sWaitTime.tv_usec = ((200 + i * 200) % 1000) * 1000;
			}

			CSUDI_FD_ZERO(&sWritenFds);
			CSUDI_FD_SET(nFd, &sWritenFds);

			nRet = CSUDISOCKSelect(nFd + 1, NULL, &sWritenFds, NULL, &sWaitTime);
			if (nRet > 0)           
			{
				if (CSUDI_FD_ISSET(nFd, &sWritenFds))
				{
					int nError;
					int nErrorLength = sizeof(nError);

					// 查看套接字nFd是否发生异常
					CSUDISOCKGetSockOpt(
						nFd, 
						CSUDI_SOL_SOCKET, 
						CSUDI_SO_ERROR, 
						(void*)&nError, 
						(unsigned int *)&nErrorLength);

					if(nError == 0)
					{
						// 还原套接字为原始模式
						nRet = CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, nPreMode, 0);
						if (nRet == -1)
						{
							CSTCPrint("[%s.%d] CSUDISOCKFcntl failed\n", __FUNCTION__, __LINE__);
							return FALSE;
						}
						return TRUE;
					}
				}
			}
		} 
		else
		{
			// 还原套接字为原始模式
			nRet = CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, nPreMode, 0);
			if (nRet == -1)
			{
				CSTCPrint("[%s.%d] CSUDISOCKFcntl failed\n", __FUNCTION__, __LINE__);
				return FALSE;
			}
			return TRUE;
		}

		nTimeout -= 200 * (i + 1);
		i++;
	}

	CSTCPrint("[%s.%d] failed\n", __FUNCTION__, __LINE__);

	return FALSE;
}

/*
	函数：	CSSOCKET_MIDP_iOpen
	描述：	创建IPv4流式套接字，并将其连接到服务器上
	输入：
			pcServerAddr - 服务器端ip地址
			ushServerPort - 服务器端端口号
	输出：
			pnFd - IPv4流式套接字
	返回：
			TRUE - 成功
			FALSE - 失败
	备注：
			1、函数调用失败时，*pnFd为CSUDI_INVALID_SOCKET
*/
static BOOL CSSOCKET_MIDP_iOpen(
								char * pcServerAddr, 
								unsigned short ushServerPort, 
								int * pnFd)
{
	int nRet = -1;
	int nFd = -1;
	BOOL bAddrReused = TRUE;
	CSUDITimeval_S sRecvTimeout = {2, 0}; 
	CSUDITimeval_S sSendTimeout = {5, 0}; 	

	if (pcServerAddr == NULL || pnFd == NULL)
	{
		CSTCPrint("[%s.%d] arguments illegal\n", __FUNCTION__, __LINE__);
		return FALSE;
	}

	nFd = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0);
	if (nFd == CSUDI_INVALID_SOCKET)
	{
		CSTCPrint("[%s.%d] CSUDISOCKSocket failed\n", __FUNCTION__, __LINE__);
		return FALSE;
	}

	// 设置接收超时
	nRet = CSUDISOCKSetSockOpt(
		nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVTIMEO, (char *)&sRecvTimeout, sizeof(sRecvTimeout));
	if (nRet != 0)
	{
		CSTCPrint("[%s.%d] CSUDISOCKSetSockOpt CSUDI_SO_RCVTIMEO failed\n", __FUNCTION__, __LINE__);
		goto ErrOut;
	}

	// 设置发送超时
	nRet = CSUDISOCKSetSockOpt(
		nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDTIMEO, (char *)&sSendTimeout, sizeof(sSendTimeout));	
	if (nRet != 0)
	{
		CSTCPrint("[%s.%d] CSUDISOCKSetSockOpt CSUDI_SO_SNDTIMEO failed\n", __FUNCTION__, __LINE__);
		goto ErrOut;
	}

	// 设置可重复使用本地地址
	nRet = CSUDISOCKSetSockOpt(
		nFd, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR, (char*)&bAddrReused, sizeof(bAddrReused));
	if (nRet != 0)
	{
		CSTCPrint("[%s.%d] CSUDISOCKSetSockOpt CSUDI_SO_REUSEADDR failed\n", __FUNCTION__, __LINE__);
		goto ErrOut;
	}

	if (!CSSOCKET_MIDP_iConnect(nFd, pcServerAddr, ushServerPort, 2000))
	{
		CSTCPrint("[%s.%d] CSSOCKET_MIDP_iConnect failed\n", __FUNCTION__, __LINE__);
		goto ErrOut;
	}

	*pnFd = nFd;

	return TRUE;

ErrOut:
	if (nFd != -1)
	{
		nRet = CSUDISOCKClose(nFd);
		if (nRet != 0)
		{
			CSTCPrint("[%s.%d] CSUDISOCKClose failed\n", __FUNCTION__, __LINE__);
		}
	}

	return FALSE;
}

//@CASEGROUP:UDI2 Socket集成测试
//@DESCRIPTION:阻塞模式，循环收发TCP数据，发送的数据与收到的数据相同。场景来源：midp访问股票
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建IPv4流式套接字成功
//@PRECONDITION:3、对套接字设置接收超时成功(超时时间为2000ms)
//@PRECONDITION:4、对套接字设置发送超时成功(超时时间为5000ms)
//@PRECONDITION:5、对套接字设置可重复使用本地地址成功
//@PRECONDITION:6、选择Win_Tcpip.exe作为服务器，启动Win_Tcpip.exe，选择TCP模式，选择服务器端模式，"接收缓存"设置为1460，"服务端口"设置为5678，选择"双向数据传输"，创建线程
//@PRECONDITION:7、对配置文件进行配置。配置服务器IP(CS_UDI2SOCKET_MIDP_SERVER_IP)为Win_Tcpip.exe的IP，配置服务器端口(CS_UDI2SOCKET_MIDP_SERVER_PORT)为5678
//@PRECONDITION:8、g_nServPort为从配置文件中读取的服务器端的端口，g_szServIp为从配置文件中读取的服务器端的IP
//@PRECONDITION:9、客户端连接服务器端成功
//@INPUT:1、nFd为成功连接到服务器端的IPv4流式套接字
//@INPUT:2、szSendBuffer[] = "hello world"为待发送数据
//@INPUT:3、szRecvBuffer[16]为用于接收数据的缓存
//@INPUT:4、nTimes = 100(循环收发数据次数为100次)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW:1、创建套接字nFd，设置接收超时，设置发送超时，设置本地地址可重用，将套接字连接到服务器上
//@EXECUTIONFLOW:2、判断收发数据次数是否达到nTimes次。若是，跳转至第8步；否则，执行下一步操作
//@EXECUTIONFLOW:3、调用CSUDISOCKSendCSUDISOCKSend(nFd, szSendBuffer, sizeof(szSendBuffer), 0)向服务器发送数据
//@EXECUTIONFLOW:4、调用CSUDIOSThreadSleep(1)让当前线程睡眠1ms
//@EXECUTIONFLOW:5、调用CSUDISOCKRecv(nFd, szRecvBuffer, sizeof(szRecvBuffer), 0)接收来自服务器的消息
//@EXECUTIONFLOW:6、判断向服务器端发送的数据szSendBuffer和从服务器端接收到的数据szRecvBuffer是否相等。若是，执行下一步操作；否则，跳转至第8步
//@EXECUTIONFLOW:7、调用memset(szRecvBuffer, 0, sizeof(szRecvBuffer))填充用于接收数据的缓存，然后跳转至第2步
//@EXECUTIONFLOW:8、调用CSUDISOCKClose(nFd)关闭套接字
CSUDI_BOOL CSTC_SOCKET_IT_MIDP_0002(void)
{
	int i = 0;
	int nFd = -1;
	int nTimes = 100;
	char szSendBuffer[] = "hello world";
	char szRecvBuffer[16] = {0};
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = g_nServPort;
	sConfig.bDualDataTransport = CSUDI_TRUE;
	SOCKET_iInitWintcpip(&sConfig);

	// 创建套接字nFd，并将其连接到指定服务器上
	CSTK_ASSERT_TRUE_FATAL
		(CSSOCKET_MIDP_iOpen(g_szServIp, g_nServPort, &nFd), 
		"步骤1失败：创建套接字并将其连接到服务器上失败");

	for (i = 0; i < nTimes; i++)
	{
		CSTK_ASSERT_TRUE_FATAL(
			CSUDISOCKSend(nFd, szSendBuffer, sizeof(szSendBuffer), 0) == sizeof(szSendBuffer),
			"步骤3失败：发送数据失败");

		CSUDIOSThreadSleep(1);

		CSTK_ASSERT_TRUE_FATAL(
			CSUDISOCKRecv(nFd, szRecvBuffer, sizeof(szRecvBuffer), 0) == sizeof(szSendBuffer), 
			"步骤5失败：接收数据失败");
		
		CSTK_ASSERT_TRUE_FATAL(
			memcmp(szSendBuffer, szRecvBuffer, sizeof(szSendBuffer)) == 0, 
			"步骤6失败：接收到的数据与发送的数据不相等");
		
		memset(szRecvBuffer, 0, sizeof(szRecvBuffer));
	}
	
	CSTK_FATAL_POINT
	if(nFd != CSUDI_INVALID_SOCKET)
	{
		CSTK_ASSERT_TRUE_FATAL(
			CSUDI_SUCCESS == CSUDISOCKClose(nFd), 
			"步骤8：关闭套接字失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:UDI2 Socket集成测试
//@DESCRIPTION:非阻塞模式，循环收发TCP数据，发送的数据与收到的数据相同。场景来源：midp访问股票
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建IPv4流式套接字成功
//@PRECONDITION:3、对套接字设置接收超时成功(超时时间为2000ms)
//@PRECONDITION:4、对套接字设置发送超时成功(超时时间为5000ms)
//@PRECONDITION:5、对套接字设置可重复使用本地地址成功
//@PRECONDITION:6、选择Win_Tcpip.exe作为服务器，启动Win_Tcpip.exe，选择TCP模式，选择服务器端模式，"接收缓存"设置为1460，"服务端口"设置为5678，选择"双向数据传输"，创建线程
//@PRECONDITION:7、对配置文件进行配置。配置服务器IP(CS_UDI2SOCKET_MIDP_SERVER_IP)为Win_Tcpip.exe的IP，配置服务器端口(CS_UDI2SOCKET_MIDP_SERVER_PORT)为5678
//@PRECONDITION:8、g_nServPort为从配置文件中读取的服务器端的端口，g_szServIp为从配置文件中读取的服务器端的IP
//@PRECONDITION:9、客户端连接服务器端成功
//@INPUT:1、nFd为成功连接到服务器端的IPv4流式套接字
//@INPUT:2、s_szSendBuffer[30000]为待发送数据的缓存
//@INPUT:3、s_szRecvBuffer[40000]为用于接收数据的缓存
//@INPUT:4、nTimes = 10(循环收发数据次数为10次)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW:1、调用memset()，用0xff填充发送缓存s_szSendBuffer，用0填充接收缓存s_szRecvBuffer
//@EXECUTIONFLOW:2、创建套接字nFd，设置接收超时，设置发送超时，设置本地地址可重用，将套接字连接到服务器上
//@EXECUTIONFLOW:3、调用CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0)|CSUDI_O_NONBLOCK, 0)设置套接字为非阻塞模式
//@EXECUTIONFLOW:4、判断收发数据次数是否达到nTimes(10)次。若是，跳转至第17步；否则，执行下一步操作
//@EXECUTIONFLOW:5、设置nSendLength(已发送的数据的长度)为0
//@EXECUTIONFLOW:6、调用CSUDISOCKSend(nFd, s_szSendBuffer + nSendLength, nSendBufferSize - nSendLength, 0)向服务器发送数据
//@EXECUTIONFLOW:7、判断所有数据是否已发送完成(通过nSendLength与nSendBufferSize来判断)。若是，执行下一步操作；否则，跳转至第6步
//@EXECUTIONFLOW:8、判断数据发送是否发生错误(通过nSendLength与nSendBufferSize来判断)。若是，跳转至第17步；否则，执行下一步操作
//@EXECUTIONFLOW:9、调用CSUDIOSGetTime()获取系统时间nStartTime
//@EXECUTIONFLOW:10、设置nRecvLength(已接收到的数据的长度)为0
//@EXECUTIONFLOW:11、调用CSUDISOCKRecv(nFd, s_szRecvBuffer + nRecvLength, nRecvBufferSize - nRecvLength, 0)接收数据
//@EXECUTIONFLOW:12、判断所有数据是否已接收完成。若是，跳转至第15步；否则，执行下一步操作
//@EXECUTIONFLOW:13、调用CSUDIOSGetTime()获取系统时间nFinishTime
//@EXECUTIONFLOW:14、判断接收是否超时(nFinishTime-nStartTime>=8000)。若是，跳转至第17步；否则，跳转至第11步
//@EXECUTIONFLOW:15、调用memcmp()判断向服务器发送的数据和从服务器接收到的数据是否相等。若是，执行下一步操作；否则，跳转至第17步
//@EXECUTIONFLOW:16、调用memset(s_szRecvBuffer, 0, nRecvBufferSize)填充用于接收数据的缓存，然后跳转至第4步
//@EXECUTIONFLOW:17、调用CSUDISOCKClose(nFd)关闭套接字
CSUDI_BOOL CSTC_SOCKET_IT_MIDP_0003(void)
{
	int i = 0;
	int nFd = -1;
	int nRet = -1;
	int nTimes = 10;
	int nStartTime = 0;
	int nFinishTime = 0;
	CSUDIOSTimeVal_S sTime = {0};
	int nRecvLength = 0;
	int nSendLength = 0;
	int nSendEachLen = 0; //每次发送数据的大小
	int nRestLen = 0; //要发送的剩余数据大小
	static char s_szSendBuffer[30000] = {0};	// 静态变量，发送数据缓存
	static char s_szRecvBuffer[40000] = {0};	// 静态变量，接收数据缓存
	int nSendBufferSize = sizeof(s_szSendBuffer);
	int nRecvBufferSize = sizeof(s_szRecvBuffer);
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = g_nServPort;
	sConfig.bDualDataTransport = CSUDI_TRUE;
	SOCKET_iInitWintcpip(&sConfig);

	memset(s_szSendBuffer, 0xff, nSendBufferSize);
	memset(s_szRecvBuffer, 0, nRecvBufferSize);

	// 创建套接字nFd，并将其连接到指定服务器上
	CSTK_ASSERT_TRUE_FATAL(
		CSSOCKET_MIDP_iOpen(g_szServIp, g_nServPort, &nFd), 
		"步骤2失败：创建套接字并将其连接到服务器上失败");

	// 设置套接字为非阻塞模式
	CSTK_ASSERT_TRUE_FATAL(
		CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0)|CSUDI_O_NONBLOCK, 0) != -1, 
		"步骤3失败：设置套接字为非阻塞模式失败");

	// 循环收发数据nTimes次
	for (i = 0; i < nTimes; i++)
	{
		nSendEachLen = 0;
		nRestLen = nSendBufferSize;
		// 确保发送nSendBufferSize字节数据
		for (nSendLength = 0; nSendLength < nSendBufferSize; nSendLength += nRet)
		{
			nSendEachLen = (nRestLen > SOCK_TEST_SEND_LEN) ? SOCK_TEST_SEND_LEN : nRestLen;
			nRet = CSUDISOCKSend(nFd, s_szSendBuffer + nSendLength, nSendEachLen, 0);
			CSTK_ASSERT_TRUE_FATAL(nRet != -1, "步骤6失败：发送数据失败");
			CSTCPrint("send:%d\n", nRet);
			nRestLen -= nRet;
			CSUDIOSThreadSleep(50);
		}

		CSTK_ASSERT_TRUE_FATAL(
			nSendLength == nSendBufferSize, 
			"步骤8失败：实际发送的数据与预期发送的数据不一致");

		CSTK_ASSERT_TRUE_FATAL(
			CSUDIOSGetTime(&sTime) == CSUDI_SUCCESS, 
			"步骤9失败：获取系统时间失败");

		nStartTime = sTime.m_nSecond * 1000 + sTime.m_nMiliSecond + sTime.m_lUSecond / 1000;

		// 接收回传数据
		for (nRecvLength = 0; nRecvLength < nRecvBufferSize && nRecvLength < nSendLength; )
		{
			nRet = CSUDISOCKRecv(nFd, s_szRecvBuffer + nRecvLength, nRecvBufferSize - nRecvLength, 0);

			CSTK_ASSERT_TRUE_FATAL(
				nRet >= 0  
				|| (nRet == -1 && CSUDISOCKGetLastError() == CSUDI_EWOULDBLOCK), 
				"步骤11失败：接收数据失败");

			if (nRet > 0)
			{
				nRecvLength += nRet;
				CSTCPrint("recv:%d\n", nRet);
			}
			else if (nRet == 0)					// nRet == 0作为判断数据接收完成的条件之一
			{
				break;
			}
			else								// nRet == -1 AND last-error-value == CSUDI_EWOULDBLOCK
			{
				CSUDIOSThreadSleep(5);
			}

			CSTK_ASSERT_TRUE_FATAL(
				CSUDIOSGetTime(&sTime) == CSUDI_SUCCESS, 
				"步骤13失败：获取系统时间失败");

			nFinishTime = sTime.m_nSecond * 1000 + sTime.m_nMiliSecond + sTime.m_lUSecond / 1000;

			CSTK_ASSERT_TRUE_FATAL(
				nFinishTime - nStartTime < 8000, 
				"步骤14失败：接收超时");
		}

		CSTK_ASSERT_TRUE_FATAL(
			nRecvLength <= nRecvBufferSize 
			&& nRecvLength == nSendLength 
			&& memcmp(s_szRecvBuffer, s_szSendBuffer, nRecvLength) == 0, 
			"步骤15失败：接收到的数据与发送的数据不一致");

		memset(s_szRecvBuffer, 0, nRecvBufferSize);
	}

	CSTK_FATAL_POINT
	if(nFd != CSUDI_INVALID_SOCKET)
	{
		CSTK_ASSERT_TRUE_FATAL(
			CSUDI_SUCCESS == CSUDISOCKClose(nFd), 
			"步骤17失败：关闭套接字失败");
	}

	return CSUDI_TRUE;	
}


//@CASEGROUP:UDI2 Socket集成测试
//@DESCRIPTION:非阻塞模式，服务器未发送数据，CSUDISOCKRecv()调用立刻返回。场景来源：midp访问股票
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建IPv4流式套接字成功
//@PRECONDITION:3、对套接字设置可重复使用本地地址成功
//@PRECONDITION:4、选择Win_Tcpip.exe作为服务器，启动Win_Tcpip.exe，选择TCP模式，选择服务器端模式，"接收缓存"设置为1460，"服务端口"设置为5678，选择"双向数据传输"，创建线程
//@PRECONDITION:5、对配置文件进行配置。配置服务器IP(CS_UDI2SOCKET_MIDP_SERVER_IP)为Win_Tcpip.exe的IP，配置服务器端口(CS_UDI2SOCKET_MIDP_SERVER_PORT)为5678
//@PRECONDITION:6、g_nServPort为从配置文件中读取的服务器端的端口，g_szServIp为从配置文件中读取的服务器端的IP
//@INPUT:1、nFd为创建的IPv4流式套接字句柄
//@INPUT:2、szRecvBuffer[64]为用于接收数据的缓存
//@INPUT:3、nTimeout=2000(连接超时时间为2000ms)
//@EXPECTATION:  成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW:1、调用CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0)创建套接字nFd
//@EXECUTIONFLOW:2、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR, (char*)&bAddrReused, sizeof(bAddrReused))设置套接字nFd本地地址可重用
//@EXECUTIONFLOW:3、调用CSSOCKET_MIDP_iConnect(nFd, g_szServIp, g_nServPort, 2000)将套接字nFd连接到服务器
//@EXECUTIONFLOW:4、调用CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0)|CSUDI_O_NONBLOCK, 0)设置套接字nFd为非阻塞模式
//@EXECUTIONFLOW:5、调用CSUDIOSGetTime()获取时间nStartTime
//@EXECUTIONFLOW:6、调用CSUDISOCKRecv(nFd, szRecvBuffer, sizeof(szRecvBuffer), 0)接收数据
//@EXECUTIONFLOW:7、调用CSUDIOSGetTime()获取时间nFinishTime
//@EXECUTIONFLOW:8、通过nFinishTime及nStartTime获取CSUDISOCKRecv()运行时间，并判断该运行时间是否满足要求
//@EXECUTIONFLOW:9、调用CSUDISOCKClose(nFd)关闭套接字
CSUDI_BOOL CSTC_SOCKET_IT_MIDP_0004(void)
{
	int nFd = -1;
	int nRet = -1;
	BOOL bAddrReused = TRUE;
	char szRecvBuffer[64] = {0};	
	int nStartTime = 0;
	int nFinishTime = 0;
	CSUDIOSTimeVal_S sTime = {0};
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = g_nServPort;
	sConfig.bDualDataTransport = CSUDI_TRUE;
	SOCKET_iInitWintcpip(&sConfig);

	nFd = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0);
	CSTK_ASSERT_TRUE_FATAL(nFd != CSUDI_INVALID_SOCKET, "步骤1失败：创建套接字失败");

	// 设置可重复使用本地地址
	nRet = CSUDISOCKSetSockOpt(
		nFd, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR, (char*)&bAddrReused, sizeof(bAddrReused));
	CSTK_ASSERT_TRUE_FATAL(nRet == 0, "步骤2失败：设置本地地址可重用失败");

	// 连接到指定服务器
	CSTK_ASSERT_TRUE_FATAL(
		CSSOCKET_MIDP_iConnect(nFd, g_szServIp, g_nServPort, 2000), 
		"步骤3失败：连接服务器失败");

	// 设置套接字为非阻塞模式
	CSTK_ASSERT_TRUE_FATAL(
		CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0)|CSUDI_O_NONBLOCK, 0) != -1, 
		"步骤4失败：设置套接字为非阻塞模式失败");

	CSTK_ASSERT_TRUE_FATAL(
		CSUDIOSGetTime(&sTime) == CSUDI_SUCCESS, 
		"步5骤失败：获取系统时间失败");

	nStartTime = sTime.m_nSecond * 1000 + sTime.m_nMiliSecond + sTime.m_lUSecond / 1000;

	nRet = CSUDISOCKRecv(nFd, szRecvBuffer, sizeof(szRecvBuffer), 0);

	CSTK_ASSERT_TRUE_FATAL(
		CSUDIOSGetTime(&sTime) == CSUDI_SUCCESS, 
		"步骤7失败：获取系统时间失败");

	nFinishTime = sTime.m_nSecond * 1000 + sTime.m_nMiliSecond + sTime.m_lUSecond / 1000;
	
	CSTK_ASSERT_TRUE_FATAL(
		(nFinishTime - nStartTime < 100) 
		&& nRet == -1 
		&& CSUDISOCKGetLastError() == CSUDI_EWOULDBLOCK, 
		"步骤8失败：设置非阻塞模式没有生效");

	CSTK_FATAL_POINT
	if(nFd != CSUDI_INVALID_SOCKET)
	{
		CSTK_ASSERT_TRUE_FATAL(
			CSUDI_SUCCESS == CSUDISOCKClose(nFd), 
			"步骤9失败：关闭套接字失败");
	}

	return CSUDI_TRUE;	
}

//@CASEGROUP:UDI2 Socket集成测试
//@DESCRIPTION:阻塞模式下设置接收超时，服务器未发送数据，CSUDISOCKRecv()调用在达到超时时间后返回。场景来源：midp访问股票
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建IPv4流式套接字成功
//@PRECONDITION:3、对套接字设置可重复使用本地地址成功
//@PRECONDITION:4、选择Win_Tcpip.exe作为服务器，启动Win_Tcpip.exe，选择TCP模式，选择服务器端模式，"接收缓存"设置为1460，"服务端口"设置为5678，选择"双向数据传输"，创建线程
//@PRECONDITION:5、对配置文件进行配置。配置服务器IP(CS_UDI2SOCKET_MIDP_SERVER_IP)为Win_Tcpip.exe的IP，配置服务器端口(CS_UDI2SOCKET_MIDP_SERVER_PORT)为5678
//@PRECONDITION:6、g_nServPort为从配置文件中读取的服务器端的端口，g_szServIp为从配置文件中读取的服务器端的IP
//@INPUT:1、nFd为创建的IPv4流式套接字句柄
//@INPUT:2、szRecvBuffer[64]为用于接收数据的缓存
//@INPUT:3、nTimeout=2000(连接超时时间为2000ms)
//@INPUT:4、sRecvTimeout={5, 0}(接收超时时间为5s)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW:1、调用CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0)创建套接字nFd
//@EXECUTIONFLOW:2、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR, (char*)&bAddrReused, sizeof(bAddrReused))设置套接字nFd本地地址可重用
//@EXECUTIONFLOW:3、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVTIMEO, (char *)&sRecvTimeout, sizeof(sRecvTimeout))设置接收超时时间
//@EXECUTIONFLOW:4、调用CSSOCKET_MIDP_iConnect(nFd, g_szServIp, g_nServPort, 2000)将套接字nFd连接到服务器
//@EXECUTIONFLOW:5、调用CSUDIOSGetTime()获取时间nStartTime
//@EXECUTIONFLOW:6、调用CSUDISOCKRecv(nFd, szRecvBuffer, sizeof(szRecvBuffer), 0)接收数据
//@EXECUTIONFLOW:7、调用CSUDIOSGetTime()获取时间nFinishTime
//@EXECUTIONFLOW:8、通过nFinishTime及nStartTime获取CSUDISOCKRecv()运行时间，并判断该运行时间是否满足要求
//@EXECUTIONFLOW:9、调用CSUDISOCKClose(nFd)关闭套接字
CSUDI_BOOL CSTC_SOCKET_IT_MIDP_0005(void)
{
	int nFd = -1;
	int nRet = -1;
	BOOL bAddrReused = TRUE;
	char szRecvBuffer[64] = {0};
	int nStartTime = 0;
	int nFinishTime = 0;
	CSUDIOSTimeVal_S sTime = {0};
	CSUDITimeval_S sRecvTimeout = {5, 0};
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = g_nServPort;
	sConfig.bDualDataTransport = CSUDI_TRUE;
	SOCKET_iInitWintcpip(&sConfig);

	nFd = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0);
	CSTK_ASSERT_TRUE_FATAL(nFd != CSUDI_INVALID_SOCKET, "步骤1失败：创建套接字失败");

	// 设置可重复使用本地地址
	nRet = CSUDISOCKSetSockOpt(
		nFd, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR, (char*)&bAddrReused, sizeof(bAddrReused));
	CSTK_ASSERT_TRUE_FATAL(nRet == 0, "步骤2失败：设置本地地址可重用失败");	
	
	// 设置接收超时
	nRet = CSUDISOCKSetSockOpt(
		nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVTIMEO, (char *)&sRecvTimeout, sizeof(sRecvTimeout));
	CSTK_ASSERT_TRUE_FATAL(nRet == 0, "步骤3失败：设置接收超时失败");

	// 连接到指定服务器
	CSTK_ASSERT_TRUE_FATAL(
		CSSOCKET_MIDP_iConnect(nFd, g_szServIp, g_nServPort, 2000), 
		"步骤4失败：连接服务器失败");

	CSTK_ASSERT_TRUE_FATAL(
		CSUDIOSGetTime(&sTime) == CSUDI_SUCCESS, 
		"步5骤失败：获取系统时间失败");

	nStartTime = sTime.m_nSecond * 1000 + sTime.m_nMiliSecond + sTime.m_lUSecond / 1000;

	nRet = CSUDISOCKRecv(nFd, szRecvBuffer, sizeof(szRecvBuffer), 0);

	CSTK_ASSERT_TRUE_FATAL(
		CSUDIOSGetTime(&sTime) == CSUDI_SUCCESS, 
		"步骤7失败：获取系统时间失败");

	nFinishTime = sTime.m_nSecond * 1000 + sTime.m_nMiliSecond + sTime.m_lUSecond / 1000;

	CSTK_ASSERT_TRUE_FATAL(
		(nFinishTime - nStartTime > 4000) 
		&& (nFinishTime - nStartTime < 6000) 
		&& nRet == -1 
		&& ((CSUDISOCKGetLastError() == CSUDI_ETIMEDOUT) || (CSUDISOCKGetLastError() == CSUDI_EAGAIN)), 
		"步骤8失败：设置超时没有生效");

	CSTK_FATAL_POINT
	if(nFd != CSUDI_INVALID_SOCKET)
	{
		CSTK_ASSERT_TRUE_FATAL(
			CSUDI_SUCCESS == CSUDISOCKClose(nFd), 
			"步骤9失败：关闭套接字失败");
	}

	return CSUDI_TRUE;	
}


//**********************************************************************************//
//**************************** End  Test  MIDP**************************************//
//**********************************************************************************//






//**********************************************************************************//
//*************************** Begin  Test  JVM**************************************//
//**********************************************************************************//


//@CASEGROUP: UDI2 Socket集成测试
//@DESCRIPTION:非阻塞模式，循环收发UDP数据，发送的数据和收到的数据相同
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、创建基于数据报的套接字成功
//@PRECONDITION:3、选择Win_Tcpip.exe作为服务器，启动Win_Tcpip.exe，选择UDP模式，选择服务器端模式，"客户端IP"设置为客户端的IP地址，"接收缓存"设置为1460，"服务端口"设置为6000，"对端端口"设置为6001，选择"双向数据传输"，创建线程
//@PRECONDITION:4、对配置文件进行配置。配置服务器IP(CS_UDI2SOCKET_JVM_SERVER_IP)为Win_Tcpip.exe的IP，配置服务器端口(CS_UDI2SOCKET_JVM_SERVER_PORT)为6000，配置客户端端口(CS_UDI2SOCKET_JVM_CLIENT_PORT)为6001
//@PRECONDITION:5、g_szServIp为从配置文件中读取的服务器端的IP
//@INPUT:2、sClientAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(6000);sin_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY)}
//@INPUT:3、sServerAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(6001);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:4、s_szSendBuffer[1460]为待发送数据的缓存
//@INPUT:5、s_szRecvBuffer[2048]为用于接收数据的缓存
//@INPUT:6、nTimes = 10(循环收发数据次数为10次)
//@EXPECTATION:  成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW:1、调用memset()，用0xff填充发送缓存s_szSendBuffer，用0填充接收缓存s_szRecvBuffer
//@EXECUTIONFLOW:2、调用CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_DGRAM, 0)创建套接字nFd
//@EXECUTIONFLOW:3、调用CSUDISOCKBind(nFd, (CSUDISockAddr_S *)&sClientAddr, sizeof(sClientAddr))将nFd与sClientAddr绑定在一起
//@EXECUTIONFLOW:4、调用CSUDISOCKGetSockName(nFd, (CSUDISockAddr_S *)&sClientAddr, &nClientAddrLen)再次确保绑定成功
//@EXECUTIONFLOW:5、调用CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0)|CSUDI_O_NONBLOCK, 0)设置套接字nFd为非阻塞模式
//@EXECUTIONFLOW:6、判断收发数据次数是否达到nTimes(10)次。若是，跳转至第16步；否则，执行下一步操作
//@EXECUTIONFLOW:7、调用CSUDISOCKSendTo(nFd, s_szSendBuffer, nSendBufferSize, 0, (CSUDISockAddr_S *)&sServerAddr, sizeof(sServerAddr))向服务器发送数据
//@EXECUTIONFLOW:8、调用CSUDIOSGetTime()获取系统时间nStartTime
//@EXECUTIONFLOW:9、设置nRecvLength(已接收到的数据的长度)为0
//@EXECUTIONFLOW:10、调用CSUDISOCKRecvFrom(nFd, s_szRecvBuffer + nRecvLength, nRecvBufferSize - nRecvLength, 0, (CSUDISockAddr_S *)&sServerAddr, &nServerAddrLen)接收数据
//@EXECUTIONFLOW:11、判断所有数据是否已接收完成。若是，跳转至第14步；否则，执行下一步操作
//@EXECUTIONFLOW:12、调用CSUDIOSGetTime()获取系统时间nFinishTime
//@EXECUTIONFLOW:13、判断接收是否超时(nFinishTime-nStartTime>=8000)。若是，跳转至第16步；否则，跳转至第10步
//@EXECUTIONFLOW:14、调用memcmp()判断向服务器发送的数据和从服务器接收到的数据是否相等。若是，执行下一步操作；否则，跳转至第16步
//@EXECUTIONFLOW:15、调用memset(s_szRecvBuffer, 0, nRecvBufferSize)填充用于接收数据的缓存，然后跳转至第6步
//@EXECUTIONFLOW:16、调用CSUDISOCKClose(nFd)关闭套接字
CSUDI_BOOL CSTC_SOCKET_IT_JVM_0001(void)
{
	int i = 0;
	int nFd = -1;
	int nRet = -1;
	int nTimes = 10;	
	int nStartTime = 0;
	int nFinishTime = 0;
	CSUDIOSTimeVal_S sTime = {0};
	int nRecvLength = 0;
	int nSendLength = 0;
	static char s_szRecvBuffer[2048] = {0};		// 静态变量，接收数据缓存
	static char s_szSendBuffer[1460] = {0};		// 静态变量，发送数据缓存
	int nRecvBufferSize = sizeof(s_szRecvBuffer);
	int nSendBufferSize = sizeof(s_szSendBuffer);
	CSUDISockAddr_IN_S sClientAddr = {0};
	CSUDISockAddr_IN_S sServerAddr = {0};
	unsigned int nClientAddrLen = sizeof(sClientAddr);
	unsigned int nServerAddrLen = sizeof(sServerAddr);
	WintcpipConfig_S sConfig;

	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons(6001);
	sClientAddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);

	sServerAddr.sin_family = CSUDI_AF_INET;
	sServerAddr.sin_port = CSUDISOCKHtons(6000);
	sServerAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	memset(s_szSendBuffer, 0xff, nSendBufferSize);
	memset(s_szRecvBuffer, 0, nRecvBufferSize);

	nFd = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_DGRAM, 0);
	CSTK_ASSERT_TRUE_FATAL(nFd != CSUDI_INVALID_SOCKET, "步骤2失败：创建套接字失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_UDP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 6000;
	sConfig.wClientPort = 6001;
	sConfig.bDualDataTransport = CSUDI_TRUE;
	SOCKET_iInitWintcpip(&sConfig);
	
	nRet = CSUDISOCKBind(nFd, (CSUDISockAddr_S *)&sClientAddr, sizeof(sClientAddr));
	CSTK_ASSERT_TRUE_FATAL(nRet != -1, "步骤3失败：绑定失败");
	
	// 再次确保bind成功;若套接字没有bind成功,则调用CSUDISOCKGetSockName()会失败
	nRet = CSUDISOCKGetSockName(nFd, (CSUDISockAddr_S *)&sClientAddr, &nClientAddrLen);
	CSTK_ASSERT_TRUE_FATAL(nRet != -1, "步骤4失败：绑定再次确定失败");

	// 设置套接字为非阻塞模式
	nRet = CSUDISOCKFcntl(
		nFd, CSUDI_F_SETFL, CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0)|CSUDI_O_NONBLOCK, 0);
	CSTK_ASSERT_TRUE_FATAL(nRet != -1, "步骤5失败：设置为非阻塞模式失败");

	for (i = 0; i < nTimes; i++)
	{
		nSendLength = CSUDISOCKSendTo(
			nFd,
			s_szSendBuffer,
			nSendBufferSize,
			0,
			(CSUDISockAddr_S *)&sServerAddr,
			sizeof(sServerAddr));

		CSTK_ASSERT_TRUE_FATAL(nSendLength == nSendBufferSize, "步骤7失败：发送数据失败");

		CSTK_ASSERT_TRUE_FATAL(
			CSUDIOSGetTime(&sTime) == CSUDI_SUCCESS, 
			"步骤8失败：获取系统时间失败");

		nStartTime = sTime.m_nSecond * 1000 + sTime.m_nMiliSecond + sTime.m_lUSecond / 1000;

		// 接收回传数据
		for (nRecvLength = 0; nRecvLength < nRecvBufferSize && nRecvLength < nSendLength; )
		{
			nRet = CSUDISOCKRecvFrom(
				nFd, 
				s_szRecvBuffer + nRecvLength, 
				nRecvBufferSize - nRecvLength, 
				0, 
				(CSUDISockAddr_S *)&sServerAddr, 
				&nServerAddrLen);

			CSTK_ASSERT_TRUE_FATAL(
				nRet >= 0 
				|| (nRet == -1 && CSUDISOCKGetLastError() == CSUDI_EWOULDBLOCK), 
				"步骤10失败：接收数据失败");

			if (nRet > 0)
			{
				nRecvLength += nRet;							
			}
			else if (nRet == 0)					// nRet == 0作为判断数据接收完成的条件之一
			{
				break;
			}
			else								// nRet == -1 AND last-error-value == CSUDI_EWOULDBLOCK
			{
				CSUDIOSThreadSleep(5);
			}

			CSTK_ASSERT_TRUE_FATAL(
				CSUDIOSGetTime(&sTime) == CSUDI_SUCCESS, 
				"步骤12失败：获取系统时间失败");

			nFinishTime = sTime.m_nSecond * 1000 + sTime.m_nMiliSecond + sTime.m_lUSecond / 1000;

			CSTK_ASSERT_TRUE_FATAL(
				nFinishTime - nStartTime < 8000, 
				"步骤13失败：接收超时");
		}

		CSTK_ASSERT_TRUE_FATAL
			(nRecvLength <= nRecvBufferSize 
			&& nRecvLength == nSendLength 
			&& memcmp(s_szRecvBuffer, s_szSendBuffer, nRecvLength) == 0, 
			"步骤14失败：接收到的数据与发送的数据不一致");

		memset(s_szRecvBuffer, 0, nRecvBufferSize);
	}

	CSTK_FATAL_POINT
	if(nFd != CSUDI_INVALID_SOCKET)
	{
		CSTK_ASSERT_TRUE_FATAL(
			CSUDI_SUCCESS == CSUDISOCKClose(nFd), 
			"步骤失败：关闭套接字失败");
	}

	return CSUDI_TRUE;	
}


//**********************************************************************************//
//*************************** End  Test  JVM****************************************//
//**********************************************************************************//

//@CASEGROUP: socket测试
//@DESCRIPTION:  流式套接字在非阻塞模式下connect一个不存在的服务器地址
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:1、nFd :成功创建流式套接字的返回值
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr("172.30.18.256")}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION: 每一步得到期望值
//@EXPECTATION:成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4字节流的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0)获取socket套接字属性，返回为nArg;
//@EXECUTIONFLOW: 3、CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, nArg | CSUDI_O_NONBLOCK, 0)设置socket套接字属性为非阻塞模式，成功返回值不为-1;
//@EXECUTIONFLOW: 4、调用CSUDIOSGetTime获取自系统启动后经过的时间 t1。
//@EXECUTIONFLOW: 5、CSUDISOCKConnect(nFd, (CSUDISockAddr_S *)&sServAddr, sizeof(CSUDISockAddr_S))向不存在的服务器发起连接请求
//@EXECUTIONFLOW: 6、调用CSUDIOSGetTime获取自系统启动后经过的时间 t2。
//@EXECUTIONFLOW: 7、比较t2和t1,如果t2-t1>3s，表示设置非阻塞未生效，返回失败
//@EXECUTIONFLOW: 8、调用CSUDISOCKClose关闭socket
CSUDI_BOOL CSTC_SOCKET_IT_0001(void)
{
	int nFd = -1;
	int nRet = -1;
	int nArg = 0;
	CSUDISockAddr_IN_S sServAddr;
	CSUDIOSTimeVal_S sTime1 = {0,0};	
	CSUDIOSTimeVal_S sTime2 = {0,0};

	memset(&sServAddr,0,sizeof(sServAddr));
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(52000);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr("172.30.18.256");

	nFd = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) ;
	CSTK_ASSERT_TRUE_FATAL(nFd != -1,"步骤1失败");

	nArg = CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0);
	CSTK_ASSERT_TRUE_FATAL(nArg != -1,"步骤2失败");

	nRet = CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, nArg | CSUDI_O_NONBLOCK, 0);
	CSTK_ASSERT_TRUE_FATAL(nRet != -1,"步骤3失败");

	nRet = CSUDIOSGetTime(&sTime1);
	CSTK_ASSERT_TRUE_FATAL(nRet == CSUDI_SUCCESS,"步骤4失败");

	nRet = CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(sServAddr));
	CSTK_ASSERT_TRUE_FATAL(nRet == -1,"步骤5失败");

	nRet = CSUDIOSGetTime(&sTime2);
	CSTK_ASSERT_TRUE_FATAL(nRet == CSUDI_SUCCESS,"步骤6失败");

	CSTK_ASSERT_TRUE_FATAL(sTime2.m_nSecond-sTime1.m_nSecond <= 3,"步骤7失败");

	CSTK_FATAL_POINT
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nFd),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}


//@CASEGROUP: socket测试
//@DESCRIPTION:  设置套接字选项和获取套接字选项，设置允许发送广播数据，CSUDI_SO_BROADCAST，数据包类型socket
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = 所设置的选项的级别，包括CSUDI_SOL_SOCKET、CSUDI_SOL_IP、和CSUDI_SOL_TCP,该测试用例主要测试CSUDI_SOL_SOCKET级选项
//@INPUT:nOptname = 选项名称，包括各个level级别中常用的选项
//@INPUT:pnOptval = 设置的选项值
//@INPUT:uOptlen = 保存选项值长度，set的时候做为输入参数，get的时候既作为输入参数又作为输出参数
//@EXPECTATION: 每一步得到期望值，创建一个数据报套接字
//@EXPECTATION:成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个数据包套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_BROADCAST,&bBroadcast, sizeof(BOOL))设置socket套接字属性，设置发送的数据具有广播特性，将bBcastFlag设置为true，成功返回为0;
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_BROADCAST,&bFlag, &nLen)成功返回0
//@EXECUTIONFLOW: 4、比较设置的nBcastFlag和获取的nFlag是否相等，相等返回成功，否则返回失败
//@EXECUTIONFLOW: 5、调用CSUDISOCKClose关闭socket
CSUDI_BOOL CSTC_SOCKET_IT_0015(void)
{
	int nFd=-1;
	int nRet=-1;
	BOOL bBroadCastIn = TRUE;
	BOOL bBroadCastOut = FALSE;
	unsigned int nOptLen = 0;

	nFd = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0);
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd,"步骤1失败");

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_BROADCAST,&bBroadCastIn, sizeof(BOOL));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤2失败");

	nOptLen = sizeof(bBroadCastOut);
	nRet = CSUDISOCKGetSockOpt(nFd,CSUDI_SOL_SOCKET,CSUDI_SO_BROADCAST,&bBroadCastOut,&nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤3失败");

	CSTK_ASSERT_TRUE_FATAL(bBroadCastIn == bBroadCastOut,"步骤4失败，获取的值和设置的值不相等");

	CSTK_FATAL_POINT    
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nFd),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}


//@CASEGROUP: socket测试
//@DESCRIPTION:  设置套接字选项和获取套接字选项，设置允许发送广播数据，paket类型socket
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = 所设置的选项的级别，包括CSUDI_SOL_SOCKET、CSUDI_SOL_IP、和CSUDI_SOL_TCP,该测试用例主要测试CSUDI_SOL_SOCKET级选项
//@INPUT:nOptname = 选项名称，包括各个level级别中常用的选项
//@INPUT:pnOptval = 设置的选项值
//@INPUT:uOptlen = 保存选项值长度，set的时候做为输入参数，get的时候既作为输入参数又作为输出参数
//@EXPECTATION: 每一步得到期望值,创建一个packet类型套接字，发送广播包成功
//@EXPECTATION:成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_PF_PACKET,CSUDI_SOCK_PACKET,CSUDISOCKHtons(CSUDI_ETH_P_ALL)) 创建一个packet类型套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_BROADCAST,&bBroadcast, sizeof(BOOL))设置socket套接字属性，设置发送的数据具有广播特性，将bBcastFlag设置为true，成功返回为0;
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_BROADCAST,&nFlag, &nLen)成功返回0
//@EXECUTIONFLOW: 4、比较设置的nBcastFlag和获取的nFlag是否相等，相等返回成功，否则返回失败
//@EXECUTIONFLOW: 5、调用CSUDISOCKClose关闭socket
CSUDI_BOOL CSTC_SOCKET_IT_0016(void)
{
	int nFd = -1;
	BOOL bBroadCastIn = TRUE;
	BOOL bBroadCastOut = FALSE;
	unsigned int nOptLen = 0;
	int nRet = -1;

	nFd = CSUDISOCKSocket(CSUDI_PF_PACKET, CSUDI_SOCK_PACKET, CSUDI_ETH_P_ALL) ;
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd,"步骤1失败");

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_BROADCAST,&bBroadCastIn, sizeof(BOOL));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤2失败");

	nOptLen = sizeof(bBroadCastOut);
	nRet = CSUDISOCKGetSockOpt(nFd,CSUDI_SOL_SOCKET,CSUDI_SO_BROADCAST,&bBroadCastOut,&nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤3失败");

	CSTK_ASSERT_TRUE_FATAL(bBroadCastIn == bBroadCastOut,"步骤4失败，获取的值和设置的值不相等");

	CSTK_FATAL_POINT   
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nFd),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}

//@CASEGROUP: socket测试
//@DESCRIPTION:  设置套接字选项和获取套接字选项，设置允许单个进程绑定相同的端口到多个socket上，但是每个socket绑定的ip地址不同
//@PRECONDITION:1、协议栈初始化成功，机顶盒设置了有效的ip地址
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = 所设置的选项的级别，包括CSUDI_SOL_SOCKET、CSUDI_SOL_IP、和CSUDI_SOL_TCP,该测试用例主要测试CSUDI_SOL_SOCKET级选项
//@INPUT:nOptname = 选项名称，包括各个level级别中常用的选项
//@INPUT:pnOptval = 设置的选项值
//@INPUT:uOptlen = 保存选项值长度，set的时候做为输入参数，get的时候既作为输入参数又作为输出参数
//@EXPECTATION: 每一步得到期望值
//@EXPECTATION:成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_PF_PACKET,CSUDI_SOCK_STREAM,0) 创建一个流式套接字,返回值为nFd1
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd1, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR,&nReuse, sizeof(nReuse))设置socket套接字属性，设置地址可重用，将nReuse设置为1，成功返回为0;
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd1, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR,&nReuse, &nLen)成功返回0
//@EXECUTIONFLOW: 4、比较设置的nReuse和获取的nReuse是否相等，相等返回成功，否则返回失败
//@EXECUTIONFLOW: 5、调用CSUDISOCKSocket(CSUDI_PF_PACKET,CSUDI_SOCK_STREAM,0) 创建一个流式套接字,返回值为nFd2
//@EXECUTIONFLOW: 6、调用CSUDISOCKSetSockOpt(nFd2, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR,&nReuse, sizeof(nReuse))设置socket套接字属性，设置地址可重用，将nReuse设置为1，成功返回为0;
//@EXECUTIONFLOW: 7、调用CSUDISOCKGetSockOpt(nFd2, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR,&nReuse, &nLen)成功返回0
//@EXECUTIONFLOW: 8、比较设置的nReuse和获取的nReuse是否相等，相等返回成功，否则返回失败
//@EXECUTIONFLOW: 9、调用CSUDISOCKBind(nFd1,sAddr,sizeof(sAddr)),绑定到sAddr，sAddr地址为127.0.0.1，端口为51000，绑定成功
//@EXECUTIONFLOW: 10、调用CSUDISOCKBind(nFd2,sAddr,sizeof(sAddr)),绑定到sAddr，sAddr地址为机顶盒ip，端口为51000，绑定成功
//@EXECUTIONFLOW: 11、调用CSUDISOCKClose关闭socket nFd1
//@EXECUTIONFLOW: 12、调用CSUDISOCKClose关闭socket nFd2
CSUDI_BOOL CSTC_SOCKET_IT_0017(void)
{
	BOOL bReuseIn = TRUE,bReuseOut = FALSE;
	unsigned int nOptLen = 0;
	int nFd1 = -1;
	int nRet = -1;
	int nFd2 = -1;
	CSUDISockAddr_IN_S sAddr1;
	CSUDISockAddr_IN_S sAddr2;

	CSTCPrint("本测试用例需要启动环回设备lo(ifconfig lo up)\n");

	memset(&sAddr1,0,sizeof(sAddr1));
	memset(&sAddr2,0,sizeof(sAddr2));

	sAddr1.sin_family = CSUDI_AF_INET;
	sAddr1.sin_port = CSUDISOCKHtons(g_nStbPort);
	sAddr1.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	sAddr2.sin_family = CSUDI_AF_INET;
	sAddr2.sin_port = CSUDISOCKHtons(g_nStbPort);
	sAddr2.sin_addr.s_addr = CSUDISOCKInet_addr("127.0.0.1");

	nFd1 = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) ;
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd1,"步骤1失败");

	nRet = CSUDISOCKSetSockOpt(nFd1, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR,&bReuseIn, sizeof(bReuseIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤2失败");

	nOptLen = sizeof(bReuseOut);
	nRet = CSUDISOCKGetSockOpt(nFd1,CSUDI_SOL_SOCKET,CSUDI_SO_REUSEADDR,&bReuseOut,&nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤3失败");
	CSTK_ASSERT_TRUE_FATAL(bReuseIn == bReuseOut,"步骤4失败，获取到的值与设置的值不相等"); 

	nFd2 = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) ;
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd2,"步骤5失败");

	nRet = CSUDISOCKSetSockOpt(nFd2, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR,&bReuseIn, sizeof(bReuseIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤6失败");

	nOptLen = sizeof(bReuseOut); 
	nRet = CSUDISOCKGetSockOpt(nFd2,CSUDI_SOL_SOCKET,CSUDI_SO_REUSEADDR,&bReuseOut,&nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤7失败");
	CSTK_ASSERT_TRUE_FATAL(bReuseIn == bReuseOut,"步骤8失败,获取到的值与设置的值不相等"); 

	sAddr1.sin_family = CSUDI_AF_INET;
	sAddr1.sin_port = CSUDISOCKHtons(g_nStbPort);
	sAddr1.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	sAddr2.sin_family = CSUDI_AF_INET;
	sAddr2.sin_port = CSUDISOCKHtons(g_nStbPort);
	sAddr2.sin_addr.s_addr = CSUDISOCKInet_addr("127.0.0.1");

	nRet = CSUDISOCKBind(nFd1,(CSUDISockAddr_S * )&sAddr1,sizeof(sAddr1));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤9失败");

	nRet = CSUDISOCKBind(nFd2,(CSUDISockAddr_S * )&sAddr2,sizeof(sAddr2));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤10失败");

	CSTK_FATAL_POINT   
	if(nFd1 != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd1),"关闭套接字1失败");
	}

	if(nFd2 != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd2),"关闭套接字2失败");
	}

	return CSUDI_TRUE; 
}


//@note: CSUDI_SO_LINGER作用是:如果要已经处于连接状态的soket在调用closesocket后强制关闭，不经历TIME_WAIT的过程：
//@CASEGROUP: socket 测试
//@DESCRIPTION:  设置套接字选项和获取套接字选项，CSUDI_SO_LINGER选项用来指定面向连接协议close的时候如何操作
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = 所设置的选项的级别，包括CSUDI_SOL_SOCKET、CSUDI_SOL_IP、和CSUDI_SOL_TCP,该测试用例主要测试CSUDI_SOL_SOCKET级选项
//@INPUT:nOptname = 选项名称，包括各个level级别中常用的选项
//@INPUT:pnOptval = 设置的选项值
//@INPUT:uOptlen = 保存选项值长度，set的时候做为输入参数，get的时候既作为输入参数又作为输出参数
//@EXPECTATION: 每一步得到期望值
//@EXPECTATION:成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_LINGER,&nLinger, sizeof(nLinger))设置socket套接字属性，设置为30s，表示关闭插口之前会把剩余数据发送完，然后再发送FIN包
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_LINGER,&nLinger, &nLen)成功返回0
//@EXECUTIONFLOW: 4、比较set的值和get的值是否相等，相等则返回成功，否则返回失败
//@EXECUTIONFLOW: 5、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServerAddr,sizeof(sServerAddr))连接远程服务器，成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd) 关闭socket，成功返回CSUDI_SUCCESS，抓包查看是否等数据发送完才发送FIN包
//@EXECUTIONFLOW: 7、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 8、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_LINGER,&nLinger, sizeof(nLinger))设置socket套接字属性，设置为0s，表示关闭插口直接发送reset包，不等之前的数据发送完毕
//@EXECUTIONFLOW: 9、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_LINGER,&nLinger, &nLen)成功返回0
//@EXECUTIONFLOW: 10、比较set的值和get的值是否相等，相等则返回成功，否则返回失败
//@EXECUTIONFLOW: 11、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServerAddr,sizeof(sServerAddr))连接远程服务器，成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 12、调用CSUDISOCKClose(nFd) 关闭socket，成功返回CSUDI_SUCCESS，抓包查看是否等数据发送完才发送FIN包
CSUDI_BOOL CSTC_SOCKET_IT_0018(void)
{
	int nFd = -1;
	Linger_S sLingerTimeIn;
	Linger_S sLingerTimeOut; 
	unsigned int nOptLen = 0;
	int nRet = -1;
	CSUDISockAddr_IN_S sServerAddr;
	WintcpipConfig_S sConfig;

	CSTCPrint("请启动抓包工具，设置为抓取与STB相连的网口\n");
	CSTKWaitAnyKey();

	nFd = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) ;
	CSTK_ASSERT_TRUE_FATAL(nFd != -1,"步骤1失败");

	memset(&sLingerTimeIn,0,sizeof(sLingerTimeIn));
	memset(&sLingerTimeOut,0,sizeof(sLingerTimeIn));

	sLingerTimeIn.m_onoff = TRUE;
	sLingerTimeIn.m_linger = 30;  

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_LINGER,&sLingerTimeIn, sizeof(sLingerTimeIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤2失败");

	nOptLen = sizeof(sLingerTimeOut);
	nRet = CSUDISOCKGetSockOpt(nFd,CSUDI_SOL_SOCKET,CSUDI_SO_LINGER,&sLingerTimeOut,&nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤3失败");

	CSTK_ASSERT_TRUE_FATAL(sLingerTimeIn.m_onoff == sLingerTimeOut.m_onoff,"步骤4失败");
	CSTK_ASSERT_TRUE_FATAL(sLingerTimeIn.m_linger == sLingerTimeOut.m_linger,"步骤4失败");

	sServerAddr.sin_family = CSUDI_AF_INET;
	sServerAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);
	sServerAddr.sin_port = CSUDISOCKHtons(g_nServPort);

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);

	nRet = CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServerAddr,sizeof(sServerAddr));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤5失败");

	nRet = CSUDISOCKClose(nFd);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤6失败");
	nFd = -1;

	//抓包查看，如果协议栈有数据，会等待协议栈发送完数据之后再发送fin包，如果协议栈30s内还未发送完毕，则发送fin包
	CSTCPrint("查看抓包工具中是否有FIN包，如果有，则按yes，否则按no。\n");
	CSTK_ASSERT_TRUE_FATAL(CSTKWaitYes(), "没有FIN包");

	CSTCPrint("请重新启动抓包工具，设置为抓取与STB相连的网口\n");
	CSTKWaitAnyKey();

	nFd = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) ;
	CSTK_ASSERT_TRUE_FATAL(nFd != -1,"步骤7失败");

	sLingerTimeIn.m_onoff = TRUE;
	sLingerTimeIn.m_linger = 0;   

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_LINGER,&sLingerTimeIn, sizeof(sLingerTimeIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤8失败");

	nOptLen = sizeof(sLingerTimeOut);
	nRet=CSUDISOCKGetSockOpt(nFd,CSUDI_SOL_SOCKET,CSUDI_SO_LINGER,&sLingerTimeOut,&nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤9失败");
	CSTK_ASSERT_TRUE_FATAL(sLingerTimeIn.m_onoff == sLingerTimeOut.m_onoff,"步骤10失败");
	CSTK_ASSERT_TRUE_FATAL(sLingerTimeIn.m_linger == sLingerTimeOut.m_linger,"步骤10失败");

	sServerAddr.sin_family = CSUDI_AF_INET;
	sServerAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);
	sServerAddr.sin_port = CSUDISOCKHtons(g_nServPort);

	nRet = CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServerAddr,sizeof(sServerAddr));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤11失败");

	CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd),"关闭套接字失败");
	nFd = -1;

	//抓包查看，如果协议栈有数据，不会等待协议栈发送完数据之后再发送fin包，而是立即发送reset包
	CSTCPrint("查看抓包工具中是否有RST包，如果有，则按yes，否则按no。\n");
	CSTK_ASSERT_TRUE_FATAL(CSTKWaitYes(), "没有RST包");

	CSTK_FATAL_POINT   
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}


//@note: CSUDI_SO_KEEPALIVE作用是:保持连接检测对方主机是否崩溃，避免（服务器）永远阻塞于TCP连接的输入。设置该选项后，如果2小时内在此套接口的任一方向都没有数据交换，TCP就自动给对方 发一个保持存活探测包
//@CASEGROUP: socket测试
//@DESCRIPTION:  设置套接字选项和获取套接字选项，CSUDI_SO_KEEPALIVE
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = 所设置的选项的级别，包括CSUDI_SOL_SOCKET、CSUDI_SOL_IP、和CSUDI_SOL_TCP,该测试用例主要测试CSUDI_SOL_SOCKET级选项
//@INPUT:nOptname = 选项名称，包括各个level级别中常用的选项
//@INPUT:pnOptval = 设置的选项值
//@INPUT:uOptlen = 保存选项值长度，set的时候做为输入参数，get的时候既作为输入参数又作为输出参数
//@EXPECTATION: 每一步得到期望值
//@EXPECTATION:成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_KEEPALIVE,&nKeep, sizeof(nKeep))设置socket套接字属性，设置tcp保活
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_KEEPALIVE,&nKeep, &nLen)成功返回0
//@EXECUTIONFLOW: 4、比较set的值和get的值是否相等，相等则返回成功，否则返回失败
//@EXECUTIONFLOW: 5、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_TCP, CSUDI_TCP_KEEPIDLE,&nKeep, sizeof(nKeep))设置tcp属性，设置第一次发包时间为30s
//@EXECUTIONFLOW: 6、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_TCP, CSUDI_TCP_KEEPIDLE,&nKeep, &nLen)成功返回0
//@EXECUTIONFLOW: 7、比较set的值和get的值是否相等，相等则返回成功，否则返回失败
//@EXECUTIONFLOW: 8、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_TCP, CSUDI_TCP_KEEPINTVL,&nKeep, sizeof(nKeep))设置tcp属性，设置两次发包间隔为10s
//@EXECUTIONFLOW: 9、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_TCP, CSUDI_TCP_KEEPINTVL,&nKeep, &nLen)成功返回0
//@EXECUTIONFLOW: 10、比较set的值和get的值是否相等，相等则返回成功，否则返回失败
//@EXECUTIONFLOW: 11、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_TCP, CSUDI_TCP_KEEPCNT,&nKeep, sizeof(nKeep))设置tcp属性，设置一共发包个数为15个
//@EXECUTIONFLOW: 12、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_TCP, CSUDI_TCP_KEEPCNT,&nKeep, &nLen)成功返回0
//@EXECUTIONFLOW: 13、比较set的值和get的值是否相等，相等则返回成功，否则返回失败
//@EXECUTIONFLOW: 14、调用CSUDISOCKConnect(nFd, (CSUDISockAddr_S*)&sServerAddr,sizeof(sServerAddr))与服务器建立连接，2小时后抓包查看是否有TCP探测包发出
//@EXECUTIONFLOW: 15、抓包查看是否有探测报文
//@EXECUTIONFLOW: 16、调用CSUDISOCKClose关闭socket
CSUDI_BOOL CSTC_SOCKET_IT_0019(void)
{
	int nRet = -1;
	unsigned int nOptLen = 0;
	int nFd = -1;
	CSUDISockAddr_IN_S sServerAddr;
	WintcpipConfig_S sConfig;
	int nKeepAliveIn = 1;
	int nKeepAliveOut = 0;
	int nKeepIdleIn = 30;
	int nKeepIdleOut = 0;
	int nKeepIntervalIn = 10;
	int nKeepIntervalOut = 0;
	int nKeepCountIn = 15;
	int nKeepCountOut = 0;

	CSTCPrint("请启动抓包工具，设置为抓取与STB相连的网口\n");
	CSTKWaitAnyKey();

	nFd = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0);
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd, "步骤1失败");

	nOptLen = sizeof(int);
	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_KEEPALIVE, &nKeepAliveIn, nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet, "步骤2失败");
	nRet = CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_KEEPALIVE, &nKeepAliveOut, &nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet, "步骤3失败");
	CSTK_ASSERT_TRUE_FATAL(nKeepAliveIn == nKeepAliveOut, "步骤4失败");

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_TCP, CSUDI_TCP_KEEPIDLE, &nKeepIdleIn, nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet, "步骤5失败");
	nRet = CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_TCP, CSUDI_TCP_KEEPIDLE, &nKeepIdleOut, &nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet, "步骤6失败");
	CSTK_ASSERT_TRUE_FATAL(nKeepIdleIn == nKeepIdleOut, "步骤7失败");

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_TCP, CSUDI_TCP_KEEPINTVL, &nKeepIntervalIn, nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet, "步骤8失败");
	nRet = CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_TCP, CSUDI_TCP_KEEPINTVL, &nKeepIntervalOut, &nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet, "步骤9失败");
	CSTK_ASSERT_TRUE_FATAL(nKeepIntervalIn == nKeepIntervalOut, "步骤10失败");

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_TCP, CSUDI_TCP_KEEPCNT, &nKeepCountIn, nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet, "步骤11失败");
	nRet = CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_TCP, CSUDI_TCP_KEEPCNT, &nKeepCountOut, &nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet, "步骤12失败");
	CSTK_ASSERT_TRUE_FATAL(nKeepCountIn == nKeepCountOut, "步骤13失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);

	sServerAddr.sin_family = CSUDI_AF_INET;
	sServerAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);
	sServerAddr.sin_port = CSUDISOCKHtons(g_nServPort);

	nRet = CSUDISOCKConnect(nFd, (CSUDISockAddr_S*)&sServerAddr, sizeof(sServerAddr));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤14失败");

	CSTCPrint("请先断开网线，再关闭Win_Tcpip工具，再插上网线\n");
	CSTCPrint("请等待3分钟，之后查看30s(从TCP 3次握手开始算)时是否有探测报文(TCP Keep-Alive)，后续每隔10s,一共15个探测报文，有请按yes，否则按no!\n");
	CSTK_ASSERT_TRUE_FATAL(CSTKWaitYes(), "步骤15失败，没有探测报文");

	CSTK_FATAL_POINT   
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd), "关闭套接字失败");
	}

	return CSUDI_TRUE; 
}


//@note: CSUDI_TCP_NODELAY作用是:不会将小包拼成大包后再发送，而是直接发送小包，适用于游戏等交互性较强的网络传输
//@CASEGROUP: socket测试
//@DESCRIPTION:  设置套接字选项和获取套接字选项，CSUDI_TCP_NODELAY
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = 所设置的选项的级别，包括CSUDI_SOL_SOCKET、CSUDI_SOL_IP、和CSUDI_SOL_TCP,该测试用例主要测试CSUDI_SOL_TCP级选项
//@INPUT:nOptname = 选项名称，包括各个level级别中常用的选项
//@INPUT:pnOptval = 设置的选项值
//@INPUT:uOptlen = 保存选项值长度，set的时候做为输入参数，get的时候既作为输入参数又作为输出参数
//@EXPECTATION: 每一步得到期望值
//@EXPECTATION:成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_TCP_NODELAY,&bNodelay, sizeof(bNodelay))设置socket套接字属性，设置tcp是否nodelay，如果设置为true，则表示
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_TCP_NODELAY,&bNodelay, &nLen)成功返回0
//@EXECUTIONFLOW: 4、比较set的值和get的值是否相等，相等则返回成功，否则返回失败
//@EXECUTIONFLOW: 5、调用CSUDISOCKClose关闭socket
CSUDI_BOOL CSTC_SOCKET_IT_0024(void)
{
	int nNodelayIn = 1,nNodelayOut = 0;
	int nRet = -1;
	unsigned int nOptLen = 0;
	int nFd = -1;

	nFd = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) ;
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd,"步骤1失败");

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_TCP_NODELAY,&nNodelayIn, sizeof(nNodelayIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤2失败");
	nOptLen = sizeof(nNodelayOut);

	nRet = CSUDISOCKGetSockOpt(nFd,CSUDI_SOL_SOCKET,CSUDI_TCP_NODELAY,&nNodelayOut,&nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤3失败");
	CSTK_ASSERT_TRUE_FATAL(nNodelayIn == nNodelayOut,"步骤4失败");

	CSTK_FATAL_POINT   
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd),"关闭套接字失败");//强制关闭，未发送完的数据将不再发送
	}

	return CSUDI_TRUE; 
}

//@CASEGROUP: socket测试
//@DESCRIPTION:  设置套接字选项和获取套接字选项，创建流式套接字，设置CSUDI_SO_SNDBUF大小
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = 所设置的选项的级别，包括CSUDI_SOL_SOCKET、CSUDI_SOL_IP、和CSUDI_SOL_TCP,该测试用例主要测试CSUDI_SOL_SOCKET级选项
//@INPUT:nOptname = 选项名称，包括各个level级别中常用的选项
//@INPUT:pnOptval = 设置的选项值
//@INPUT:uOptlen = 保存选项值长度，set的时候做为输入参数，get的时候既作为输入参数又作为输出参数
//@EXPECTATION: 每一步得到期望值
//@EXPECTATION:成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDBUF,&nBufSize, sizeof(nBufSize))设置socket套接字属性，设置send的buffer大小，将nBufSize设置为1460，成功返回为0;
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDBUF,&nBufSize, &nBufSize)成功返回0
//@EXECUTIONFLOW: 4、比较设置的nBufSize和获取的nBufSize是否相等，获取到的buf值应该大于等于设置的buf值
//@EXECUTIONFLOW: 5、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServerAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，connect失败返回-1，获取错误码
//@EXECUTIONFLOW: 6、调用CSUDISOCKSend(nFd, szBuf, uNum, nFlags)向服务器端发送数据，成功返回实际发送字节数本地主机向服务器发起连接请求，发送的数据大小小于1460,比较实际发送的数据大小和发送的buf大小相等，返回值应该等于实际发送的数据大小
//@EXECUTIONFLOW: 7、调用CSUDISOCKClose关闭socket
//@EXECUTIONFLOW: 8、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式套接字,返回值为nFd
//@EXECUTIONFLOW: 9、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDBUF,&nBufSize, sizeof(nBufSize))设置socket套接字属性，设置send的buffer大小，将nBufSize设置为10，成功返回为0;
//@EXECUTIONFLOW: 10、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDBUF,&nBufSize, &nBufSize)成功返回0
//@EXECUTIONFLOW: 11、比较设置的nBufSize和获取的nBufSize是否相等，获取到的buf值应该大于等于设置的buf值
//@EXECUTIONFLOW: 12、调用CSUDISOCKSend(nFd, szBuf, uNum, nFlags)向服务器端发送数据，成功返回实际发送字节数本地主机向服务器发起连接请求，
//@EXECUTIONFLOW: 13、比较实际发送的数据大小和设置的buf大小相等，返回值应该等于实际发送的数据大小
//@EXECUTIONFLOW: 14、调用CSUDISOCKClose关闭socket
CSUDI_BOOL CSTC_SOCKET_IT_0020(void)
{   
	int nFd = -1;
	int nRet = -1;    
	int nSendBufSizeIn = 1460,nSendBufSizeOut = 0;
	CSUDISockAddr_IN_S sServAddr;
	char acSendBuf[1460] = {0};
	unsigned int nOptLen = 0;
	WintcpipConfig_S sConfig;

	nFd = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) ;
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd,"步骤1失败");

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDBUF,&nSendBufSizeIn, sizeof(nSendBufSizeIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤2失败");

	nOptLen = sizeof(nSendBufSizeOut);
	nRet = CSUDISOCKGetSockOpt(nFd,CSUDI_SOL_SOCKET,CSUDI_SO_SNDBUF,&nSendBufSizeOut,&nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤3失败");

	CSTK_ASSERT_TRUE_FATAL(nSendBufSizeOut >= nSendBufSizeIn,"步骤4失败");

	memset(&sServAddr,0,sizeof(sServAddr));
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	sConfig.bDualDataTransport = CSUDI_TRUE;
	SOCKET_iInitWintcpip(&sConfig);

	nRet = CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(sServAddr));
	CSTK_ASSERT_TRUE_FATAL(nRet == 0,"步骤5失败");

	memset(acSendBuf,'c',sizeof(acSendBuf));

	nRet = CSUDISOCKSend(nFd,acSendBuf,17,0);
	CSTK_ASSERT_TRUE_FATAL(nRet == 17,"步骤6失败");

	nRet = CSUDISOCKClose(nFd);
	CSTK_ASSERT_TRUE_FATAL(nRet == 0 ,"步骤7失败");

	nSendBufSizeIn = 10; 
	nFd =-1;

	nFd = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) ;
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd,"步骤8失败");

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDBUF,&nSendBufSizeIn, sizeof(nSendBufSizeIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤9失败");

	nOptLen = sizeof(nSendBufSizeOut);
	nSendBufSizeOut = 0;

	nRet = CSUDISOCKGetSockOpt(nFd,CSUDI_SOL_SOCKET,CSUDI_SO_SNDBUF,&nSendBufSizeOut,&nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤10失败");
	CSTK_ASSERT_TRUE_FATAL(nSendBufSizeOut >= nSendBufSizeIn,"步骤11失败");

	nRet = CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(sServAddr));
	CSTK_ASSERT_TRUE_FATAL(nRet == 0,"步骤12失败");

	memset(acSendBuf,'c',1024);
	nRet = CSUDISOCKSend(nFd,acSendBuf,1024,0);
	CSTK_ASSERT_TRUE_FATAL(nRet == 1024,"步骤13失败");

	CSTK_FATAL_POINT   
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}

//@CASEGROUP: socket测试
//@DESCRIPTION:  设置套接字选项和获取套接字选项,创建数据报套接字，设置CSUDI_SO_SNDBUF大小
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = 所设置的选项的级别，包括CSUDI_SOL_SOCKET、CSUDI_SOL_IP、和CSUDI_SOL_TCP,该测试用例主要测试CSUDI_SOL_SOCKET级选项
//@INPUT:nOptname = 选项名称，包括各个level级别中常用的选项
//@INPUT:pnOptval = 设置的选项值
//@INPUT:uOptlen = 保存选项值长度，set的时候做为输入参数，get的时候既作为输入参数又作为输出参数
//@EXPECTATION: 每一步得到期望值
//@EXPECTATION:成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个数据报套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDBUF,&nBufSize, sizeof(nBufSize))设置socket套接字属性，设置send的buffer大小，将nBufSize设置为1460，成功返回为0;
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDBUF,&nBufSize, &nBufSize)成功返回0
//@EXECUTIONFLOW: 4、比较设置的nBufSize和获取的nBufSize是否相等，获取到的buf值应该大于等于设置的buf值
//@EXECUTIONFLOW: 5、调用CSUDISOCKBind(nFd,(CSUDISockAddr_S*)&sClientAddr,sizeof(sClientAddr))绑定本地ip地址和端口号
//@EXECUTIONFLOW: 6、调用CSUDISOCKSendTo(nFd, szBuf, uNum, nFlags)向服务器端发送数据，成功返回实际发送字节数本地主机向服务器发起连接请求，
//@EXECUTIONFLOW: 7、调用CSUDISOCKClose关闭socket
//@EXECUTIONFLOW: 8、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个数据报套接字,返回值为nFd
//@EXECUTIONFLOW: 9、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDBUF,&nBufSize, sizeof(nBufSize))设置socket套接字属性，设置send的buffer大小，将nBufSize设置为10，成功返回为0;
//@EXECUTIONFLOW: 10、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDBUF,&nBufSize, &nBufSize)成功返回0
//@EXECUTIONFLOW: 11、比较设置的nBufSize和获取的nBufSize是否相等，获取到的buf值应该大于等于设置的buf值
//@EXECUTIONFLOW: 12、调用CSUDISOCKSendTo(nFd, szBuf, uNum, nFlags)向服务器端发送数据，成功返回实际发送字节数本地主机向服务器发起连接请求，发送uNum为50000，返回失败
//@EXECUTIONFLOW: 13、调用CSUDISOCKClose关闭socket
CSUDI_BOOL CSTC_SOCKET_IT_0021(void)
{   
	int nFd = -1;
	int nRet = -1;    
	int nSendBufSizeIn = 1460,nSendBufSizeOut = 0;
	unsigned int nOptLen = 0;
	CSUDISockAddr_IN_S sServAddr,sClientAddr;
	char acSendBuf[5000] = {0};

	nFd = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) ;
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd,"步骤1失败");

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDBUF,&nSendBufSizeIn, sizeof(nSendBufSizeIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤2失败");
	nOptLen = sizeof(nSendBufSizeOut);

	nRet = CSUDISOCKGetSockOpt(nFd,CSUDI_SOL_SOCKET,CSUDI_SO_SNDBUF,&nSendBufSizeOut,&nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤3失败");
	CSTK_ASSERT_TRUE_FATAL(nSendBufSizeOut >= nSendBufSizeOut,"步骤4失败");

	memset(&sServAddr,0,sizeof(sServAddr));
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	memset(&sClientAddr,0,sizeof(sClientAddr));
	sClientAddr.sin_family = CSUDI_AF_INET;
	sClientAddr.sin_port = CSUDISOCKHtons(g_nStbPort);
	sClientAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	nRet = CSUDISOCKBind(nFd,(CSUDISockAddr_S*)&sClientAddr,sizeof(sClientAddr));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤5失败");

	memset(acSendBuf,'c',sizeof(acSendBuf));
	nRet = CSUDISOCKSendTo(nFd,acSendBuf,1460,0,(CSUDISockAddr_S*)&sServAddr,sizeof(sServAddr));
	CSTK_ASSERT_TRUE_FATAL(nRet == 1460,"步骤6失败");

	nRet = CSUDISOCKClose(nFd);
	CSTK_ASSERT_TRUE_FATAL(nRet == 0 ,"步骤7失败");

	nSendBufSizeIn = 10;

	nFd = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) ;
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd,"步骤8失败");

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDBUF,&nSendBufSizeIn, sizeof(nSendBufSizeIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤9失败");

	nOptLen = sizeof(nSendBufSizeOut);
	nSendBufSizeOut = 0;

	nRet = CSUDISOCKGetSockOpt(nFd,CSUDI_SOL_SOCKET,CSUDI_SO_SNDBUF,&nSendBufSizeOut,&nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤10失败");
	CSTK_ASSERT_TRUE_FATAL(nSendBufSizeOut >= nSendBufSizeIn,"步骤11失败");

	memset(acSendBuf,'c',sizeof(acSendBuf));
	nRet = CSUDISOCKSendTo(nFd,acSendBuf,5000,0,(CSUDISockAddr_S*)&sServAddr,sizeof(sServAddr)); //一般udp数据发送长度不要超过1500-20-8
	CSTK_ASSERT_TRUE_FATAL(nRet == -1,"步骤12失败");

	CSTK_FATAL_POINT   
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nFd),"关闭套接字失败");//强制关闭，未发送完的数据将不再发送
	}

	return CSUDI_TRUE; 
}

//@CASEGROUP: socket测试
//@DESCRIPTION:  设置套接字选项和获取套接字选项，创建流式套接字，设置CSUDI_SO_RCVBUF大小，作为tcp服务端，设置CSUDI_SO_RCVBUF大小为2000
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = 所设置的选项的级别，包括CSUDI_SOL_SOCKET、CSUDI_SOL_IP、和CSUDI_SOL_TCP,该测试用例主要测试CSUDI_SOL_SOCKET级选项
//@INPUT:nOptname = 选项名称，包括各个level级别中常用的选项
//@INPUT:pnOptval = 设置的选项值
//@INPUT:uOptlen = 保存选项值长度，set的时候做为输入参数，get的时候既作为输入参数又作为输出参数
//@EXPECTATION: 每一步得到期望值
//@EXPECTATION:成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVBUF,&nBufSize, sizeof(nBufSize))设置socket套接字属性，设置recv的buffer大小，将nBufSize设置为2000，成功返回为0;
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVBUF,&nBufSize, &nBufSize)成功返回0
//@EXECUTIONFLOW: 4、比较设置的nBufSize和获取的nBufSize是否相等，获取的buf大小应该大于设置的buf大小
//@EXECUTIONFLOW: 5、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR,&nBufSize2, sizeof(nBufSize2))设置socket套接字属性，设置reuse的buffer大小，将nBufSize设置为1，成功返回为0;
//@EXECUTIONFLOW: 6、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))绑定本机地址
//@EXECUTIONFLOW: 7、调用CSUDISOCKListen(nFd,10)启动监听
//@EXECUTIONFLOW: 8、调用CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,&nAccpetLen);接受连接,成功返回新套接字描述符nFd2
//@EXECUTIONFLOW: 9、调用CSUDISOCKRecv(nRetAcceptFd, nRecvBuf, sizeof(nRecvBuf), 0);开始接受数据，判断接收到数据即可
//@EXECUTIONFLOW: 10、调用CSUDISOCKClose(nFd2)关闭socket
//@EXECUTIONFLOW: 11、调用CSUDISOCKClose(nFd)关闭socket
CSUDI_BOOL CSTC_SOCKET_IT_0022(void)
{    
	int nFd = -1;
	int nRet = -1;
	int nRecvBufIn = 2000,nRecvBufOut = 0;
	unsigned int  nOptLen = 0;
	int nRetAcceptFd = -1;
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	char nRecvBuf[5000];
	unsigned int nAccpetLen = 0;
	int nReuseAddr = 1;
	WintcpipConfig_S sConfig;

	nFd = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,CSUDI_IPPROTO_TCP) ;
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd,"步骤1失败");

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVBUF,&nRecvBufIn, sizeof(nRecvBufIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤2失败");

	nOptLen = sizeof(nRecvBufOut);
	nRet = CSUDISOCKGetSockOpt(nFd,CSUDI_SOL_SOCKET,CSUDI_SO_RCVBUF,&nRecvBufOut,&nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤3失败");

	CSTCPrint("nRecvBufIn:%d, nRecvBufOut:%d\n", nRecvBufIn, nRecvBufOut);
	CSTK_ASSERT_TRUE_FATAL(nRecvBufOut >= nRecvBufIn,"步骤4失败");   

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR,&nReuseAddr, sizeof(nReuseAddr));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤5失败");

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nStbPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤6失败");
	CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKListen(nFd,10),"步骤7失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_CLIENT;
	sConfig.uBufLen = 1460;
	sConfig.wServerPortForClient = 51000;
	SOCKET_iInitWintcpip(&sConfig);

	nAccpetLen = sizeof(sClientAddr);
	nRetAcceptFd = CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,&nAccpetLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRetAcceptFd,"步骤8失败");

	nRet = CSUDISOCKRecv(nRetAcceptFd, nRecvBuf, sizeof(nRecvBuf), 0);
	CSTCPrint("nRet:%d\n", nRet);
	CSTK_ASSERT_TRUE_FATAL(nRet > 0, "步骤9失败");

	CSTK_FATAL_POINT   
	if(nRetAcceptFd !=-1)
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nRetAcceptFd),"步骤10释放连接套接字失败！");
	}
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd),"步骤11关闭套接字失败");
	}

	return CSUDI_TRUE; 
}

//@CASEGROUP: socket测试
//@DESCRIPTION:  设置套接字选项和获取套接字选项，创建流式套接字，设置CSUDI_SO_RCVBUF大小,作为tcp服务端，设置CSUDI_SO_RCVBUF大小为10
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = 所设置的选项的级别，包括CSUDI_SOL_SOCKET、CSUDI_SOL_IP、和CSUDI_SOL_TCP,该测试用例主要测试CSUDI_SOL_SOCKET级选项
//@INPUT:nOptname = 选项名称，包括各个level级别中常用的选项
//@INPUT:pnOptval = 设置的选项值
//@INPUT:uOptlen = 保存选项值长度，set的时候做为输入参数，get的时候既作为输入参数又作为输出参数
//@EXPECTATION: 每一步得到期望值
//@EXPECTATION:成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVBUF,&nBufSize, sizeof(nBufSize))设置socket套接字属性，设置recv的buffer大小，将nBufSize设置为10，成功返回为0;
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVBUF,&nBufSize, &nBufSize)成功返回0
//@EXECUTIONFLOW: 4、比较设置的nBufSize和获取的nBufSize是否相等，获取的buf大小应该大于设置的buf大小
//@EXECUTIONFLOW: 5、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR,&nBufSize, sizeof(nBufSize))设置socket套接字属性，设置CSUDI_SO_REUSEADDR的buffer大小，将nBufSize设置为1，成功返回为0;
//@EXECUTIONFLOW: 6、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))绑定本机地址
//@EXECUTIONFLOW: 7、调用CSUDISOCKListen(nFd,10)启动监听
//@EXECUTIONFLOW: 8、调用CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,&nAccpetLen);接受连接
//@EXECUTIONFLOW: 9、调用CSUDISOCKRecv(nRetAcceptFd, nRecvBuf, sizeof(nRecvBuf), 0);开始接受数据，判断接收导数据即可
//@EXECUTIONFLOW: 10、调用CSUDISOCKClose(nFd2)关闭socket
//@EXECUTIONFLOW: 11、调用CSUDISOCKClose(nFd)关闭socket
CSUDI_BOOL CSTC_SOCKET_IT_0023(void)
{    
	int nFd = -1;
	int nRet = -1;
	int nRecvBufIn = 10,nRecvBufOut = 0;
	unsigned int  nOptLen = 0;
	int nReuseAddr = 1;
	int nRetAcceptFd = -1;
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	char nRecvBuf[5000];
	unsigned int nAccpetLen = 0;
	WintcpipConfig_S sConfig;

	nFd = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,CSUDI_IPPROTO_TCP) ;
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd,"步骤1失败");

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVBUF,&nRecvBufIn, sizeof(nRecvBufIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤2失败");
	nOptLen = sizeof(nRecvBufOut);

	nRet = CSUDISOCKGetSockOpt(nFd,CSUDI_SOL_SOCKET,CSUDI_SO_RCVBUF,&nRecvBufOut,&nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤3失败");

	CSTCPrint("nRecvBufIn:%d, nRecvBufOut:%d\n", nRecvBufIn, nRecvBufOut);
	CSTK_ASSERT_TRUE_FATAL(nRecvBufOut >= nRecvBufIn,"步骤4失败");   

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_REUSEADDR,&nReuseAddr, sizeof(nReuseAddr));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤5失败");

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nStbPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤6失败");
	CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKListen(nFd,10),"步骤7失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_CLIENT;
	sConfig.uBufLen = 1460;
	sConfig.wServerPortForClient = 51000;
	SOCKET_iInitWintcpip(&sConfig);

	nAccpetLen = sizeof(sClientAddr);
	nRetAcceptFd = CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,&nAccpetLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRetAcceptFd,"步骤8失败");

	CSUDIOSThreadSleep(1000);

	nRet = CSUDISOCKRecv(nRetAcceptFd, nRecvBuf, sizeof(nRecvBuf), 0);
	CSTCPrint("nRet:%d\n", nRet);
	CSTK_ASSERT_TRUE_FATAL(nRet > 0, "步骤9失败");

	CSTK_FATAL_POINT   
	if(nRetAcceptFd !=-1)
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nRetAcceptFd),"步骤10关闭连接套接字失败");
	}
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd),"步骤11关闭套接字失败");
	}

	return CSUDI_TRUE; 

}


//@CASEGROUP: socket测试
//@DESCRIPTION:  设置套接字选项和获取套接字选项，设置CSUDI_SO_SNDTIMEO超时时间为3s,CSUDI_SO_RCVTIMEO为3s,向不存在的服务器收发数据
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = 所设置的选项的级别，包括CSUDI_SOL_SOCKET、CSUDI_SOL_IP、和CSUDI_SOL_TCP,该测试用例主要测试CSUDI_SOL_SOCKET级选项
//@INPUT:nOptname = 选项名称，包括各个level级别中常用的选项
//@INPUT:pnOptval = 设置的选项值
//@INPUT:uOptlen = 保存选项值长度，set的时候做为输入参数，get的时候既作为输入参数又作为输出参数
//@EXPECTATION: 每一步得到期望值
//@EXPECTATION:成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个数据报套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDTIMEO,&timeout, sizeof(timeout))设置socket套接字属性，设置send的超时时间为3s,成功返回为0;timeout类型为timeval类型
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDTIMEO,&timeout, &nLen)成功返回0
//@EXECUTIONFLOW: 4、比较设置的超时时间与获取的超时时间是否相等，相等则返回成功，否则返回失败
//@EXECUTIONFLOW: 5、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVTIMEO,&timeout, sizeof(timeout))设置socket套接字属性，设置recv的超时时间为3s,成功返回为0;timeout类型为timeval类型
//@EXECUTIONFLOW: 6、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVTIMEO,&timeout, &nLen)成功返回0
//@EXECUTIONFLOW: 7、比较设置的超时时间与获取的超时时间是否相等，相等则返回成功，否则返回失败
//@EXECUTIONFLOW: 8、调用CSUDISOCKSendTo(nFd,acSendBuf,5000,0,(CSUDISockAddr_S*)&sServAddr,sizeof(sServAddr));测试在3s内sendto是否返回
//@EXECUTIONFLOW: 9、调用CSUDISOCKRecvFrom(nFd, szBuf, 16, 0,(CSUDISockAddr_S*)&sClientAddr,&uAddrLen);测试在3s内recvfrom是否返回
//@EXECUTIONFLOW: 10、调用CSUDISOCKClose关闭socket
CSUDI_BOOL CSTC_SOCKET_IT_0002(void)
{
	int nFd = -1;
	CSUDITimeval_S sSendTmValueIn,sSendTmValueOut;
	CSUDITimeval_S sRecvTmValueIn,sRecvTmValueOut;
	int nRet = -1;
	unsigned int nOptLen = 0;
	char acBuf[1024];
	unsigned int nRecvLen = 0;
	CSUDIOSTimeVal_S sTime1 = {0};	
	CSUDIOSTimeVal_S sTime2 = {0};
	CSUDISockAddr_IN_S sServerAddr;

	memset(&sSendTmValueIn,0,sizeof(sSendTmValueIn));
	memset(&sSendTmValueOut,0,sizeof(sSendTmValueOut));

	nFd = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0);
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd,"步骤1失败");

	sSendTmValueIn.tv_sec = 3;
	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDTIMEO,&sSendTmValueIn, sizeof(sSendTmValueIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤2失败");
	nOptLen = sizeof(sSendTmValueOut);

	nRet = CSUDISOCKGetSockOpt(nFd,CSUDI_SOL_SOCKET,CSUDI_SO_SNDTIMEO,&sSendTmValueOut,&nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤3失败");

	CSTK_ASSERT_TRUE_FATAL(sSendTmValueIn.tv_sec == sSendTmValueOut.tv_sec,"步骤4失败");

	sServerAddr.sin_family = CSUDI_AF_INET;
	sServerAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);
	sServerAddr.sin_port = CSUDISOCKHtons(g_nServPort);

	memset(&sRecvTmValueIn,0,sizeof(sRecvTmValueIn));
	memset(&sRecvTmValueOut,0,sizeof(sRecvTmValueOut));
	sRecvTmValueIn.tv_sec = 3;

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVTIMEO,&sRecvTmValueIn, sizeof(sRecvTmValueIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤5失败");
	nOptLen = sizeof(sRecvTmValueOut);

	nRet=CSUDISOCKGetSockOpt(nFd,CSUDI_SOL_SOCKET,CSUDI_SO_RCVTIMEO,&sRecvTmValueOut,&nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤6失败");

	CSTK_ASSERT_TRUE_FATAL(sRecvTmValueIn.tv_sec == sRecvTmValueOut.tv_sec,"步骤7失败");

	memset(acBuf,0,sizeof(acBuf));
	CSUDIOSGetTime(&sTime1);

	nRet = CSUDISOCKSendTo(nFd,acBuf,sizeof(acBuf),0,(CSUDISockAddr_S*)&sServerAddr,sizeof(sServerAddr));
	CSUDIOSGetTime(&sTime2);

	CSTK_ASSERT_TRUE_FATAL(sTime2.m_nSecond-sTime1.m_nSecond <= 3,"步骤8失败");

	memset(acBuf,0,sizeof(acBuf));
	nRecvLen = sizeof(sServerAddr);
	CSUDIOSGetTime(&sTime1);

	nRet = CSUDISOCKRecvFrom(nFd,acBuf,sizeof(acBuf),0,(CSUDISockAddr_S*)&sServerAddr,&nRecvLen);
	CSUDIOSGetTime(&sTime2);
	CSTK_ASSERT_TRUE_FATAL(sTime2.m_nSecond-sTime1.m_nSecond <= 3,"步骤9失败");

	CSTK_FATAL_POINT   
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}

//@CASEGROUP: socket测试
//@DESCRIPTION:  设置套接字选项和获取套接字选项IP_ADD_MEMBERSHIP，加入组播组，接收组播组数据,离开组播组，无法接受组播数据
//@PRECONDITION:1、协议栈初始化成功
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = 所设置的选项的级别，包括CSUDI_SOL_SOCKET、CSUDI_SOL_IP、和CSUDI_SOL_TCP,该测试用例主要测试CSUDI_SOL_IP级选项
//@INPUT:nOptname = 选项名称，包括各个level级别中常用的选项
//@INPUT:pnOptval = 设置的选项值
//@INPUT:uOptlen = 保存选项值长度，set的时候做为输入参数，get的时候既作为输入参数又作为输出参数
//@EXPECTATION: 每一步得到期望值
//@EXPECTATION:成功返回CSUDI_SUCCESS
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_DGRAM,0) 创建一个IPv4数据报套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind(nFd, (CSUDISockAddr_S*)&sockaddr, sizeof(sockaddr))绑定组播地址
//@EXECUTIONFLOW: 3、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_IP, CSUDI_IP_MULTICAST_LOOP,&nLoop, sizeof(nLoop))设置为1，表示允许发送方接受自己发送的数据，成功返回为0;
//@EXECUTIONFLOW: 4、调用CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_IP, CSUDI_IP_MULTICAST_LOOP,&nLoop, &nLen)成功返回0
//@EXECUTIONFLOW: 5、比较设置的nLoop和获取的nLoop是否相等，相等返回成功，否则返回失败
//@EXECUTIONFLOW: 6、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVTIMEO,&timeout, sizeof(timeout))设置socket套接字属性，设置recv的超时时间为3s,成功返回为0;timeout类型为timeval类型
//@EXECUTIONFLOW: 7、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_IP, IP_ADD_MEMBERSHIP,&mreq, sizeof(nLoop))设置加入组播组，成功返回为0;{mreq.imr_multiaddr.s_addr = inet_addr(serverIP)；mreq.imr_interface.s_addr = inet_addr(szEthernetIP/*INADDR_ANY*/);}
//@EXECUTIONFLOW: 8、调用CSUDISOCKRecv(nFd, nRecvBuf, 5000, 0);接收组播组数据，成功返回接收字节数
//@EXECUTIONFLOW: 9、调用CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_IP, CSUDI_IP_DROP_MEMBERSHIP,&mreq, sizeof(nLoop))设置离开组播组，成功返回为0;{mreq.imr_multiaddr.s_addr = inet_addr(serverIP)；mreq.imr_interface.s_addr = inet_addr(szEthernetIP/*INADDR_ANY*/);}
//@EXECUTIONFLOW: 10、调用CSUDISOCKRecv(nFd, nRecvBuf, 5000, 0);接收组播组数据，失败返回-1
//@EXECUTIONFLOW: 11、调用CSUDISOCKClose关闭socket
CSUDI_BOOL CSTC_SOCKET_IT_0003(void)
{
	int nFd = -1;
	int nRet = -1;
	int nLoopIn = 1,nLoopOut = 0;
	unsigned int nOptLen = 0;
	CSUDIIp_Mreq_S mreqIn;
	CSUDIIp_Mreq_S mreqOut;
	CSUDISockAddr_IN_S sockaddr;
	char acBuf[1000];
	CSUDITimeval_S sRecvTmValueIn;

	CSTCPrint("请确保配置文件中sock段存在CS_SOCK_MUTICAST_ADDR 多播地址的配置选项\n");
	CSTCPrint("请启动 WinSend 开始发包,WinSend的配置是:\n");
	CSTCPrint("1、WinSend interface中选择pc 用来与机顶盒通信的那个网卡的ip地址:\n");
	CSTCPrint("2、WinSend  ip address 填入:224.0.1.1,ip port 填入1234,其他的取默认值即可\n");
	CSTCPrint("3、WinSend 点击open 按钮，选择给定的码流 ASB.ts，单击send按钮，开始发包\n");
	CSTKWaitAnyKey();

	nFd = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_DGRAM, 0) ;
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd, "步骤1失败");

	sockaddr.sin_family = CSUDI_AF_INET;
	sockaddr.sin_addr.s_addr = CSUDISOCKInet_addr("224.0.1.1"); //指定从组播的224.0.1.1上1234端口接受数据
	sockaddr.sin_port = CSUDISOCKHtons(1234);

	nRet = CSUDISOCKBind(nFd, (CSUDISockAddr_S*)&sockaddr, sizeof(sockaddr));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet, "步骤2失败");

	memset(&mreqIn, 0, sizeof(mreqIn));
	memset(&mreqOut, 0, sizeof(mreqOut));
	mreqIn.imr_multiaddr.s_addr = CSUDISOCKInet_addr("224.0.1.1");
	mreqIn.imr_interface.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_IP, CSUDI_IP_MULTICAST_LOOP, &nLoopIn, sizeof(nLoopIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet, "步骤3失败");

	nOptLen = sizeof(nLoopOut);
	nRet = CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_IP, CSUDI_IP_MULTICAST_LOOP, &nLoopOut, &nOptLen);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet, "步骤4失败");
	CSTK_ASSERT_TRUE_FATAL(nLoopIn == nLoopOut, "步骤5失败");

	memset(&sRecvTmValueIn, 0, sizeof(sRecvTmValueIn));
	sRecvTmValueIn.tv_sec = 3;
	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_RCVTIMEO, &sRecvTmValueIn, sizeof(sRecvTmValueIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet, "步骤6失败");

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_IP, CSUDI_IP_ADD_MEMBERSHIP, &mreqIn, sizeof(mreqIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet, "步骤7失败");

	nRet = CSUDISOCKRecv(nFd, acBuf, sizeof(acBuf), 0);
	CSTK_ASSERT_TRUE_FATAL(nRet > 0, "步骤8失败");

	CSUDIOSThreadSleep(1000);

	nRet = CSUDISOCKSetSockOpt(nFd, CSUDI_SOL_IP, CSUDI_IP_DROP_MEMBERSHIP, &mreqIn, sizeof(mreqIn));
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet, "步骤9失败");

	while(1)
	{
		nRet = CSUDISOCKRecv(nFd, acBuf, sizeof(acBuf), 0);
		if (nRet==-1)
		{
			break;
		}
	}

	CSTK_ASSERT_TRUE_FATAL(nRet == -1, "步骤10失败");

	CSTK_FATAL_POINT   
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd), "步骤11关闭套接字失败");
	}

	CSTCPrint("!!!请关闭 WinSend 停止发包!!!\n");
	CSTKWaitAnyKey();

	return CSUDI_TRUE; 
}


//@CASEGROUP: socket测试
//@DESCRIPTION:拔掉网线，在客户端创建一个套接字，向服务端发起连接请求，服务与本地是可达的，服务器配置成与机顶盒同一端ip地址，但是未插上网线，返回失败
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端创建套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  connect失败返回CSUDI_FAILURE，错误码为CSUDI_EINPROGRESS或者CSUDI_EALREADY或者CSUDI_EWOULDBLOCK
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4流式套接字，成功返回0
//@EXECUTIONFLOW: 2、CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, nArg | CSUDI_O_NONBLOCK, 0)设置socket套接字属性为非阻塞模式，成功返回值不为-1;
//@EXECUTIONFLOW: 3、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sClientAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，connect失败返回-1，获取错误码
//@EXECUTIONFLOW: 4、调用CSUDISOCKGetLastError()获取错误号，错误号为CSUDI_EINPROGRESS、CSUDI_EALREADY或者CSUDI_EWOULDBLOCK返回成功
//@EXECUTIONFLOW: 5、调用CSUDISOCKSelect(nFd + 1, CSUDI_NULL, &fdset, CSUDI_NULL, &tTimeValue)，期望返回0
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_0005(void)
{
	int nFd = -1;
	int nRet = -1;
	int nArg = 0;
	CSUDISockAddr_IN_S sServerAddr;
	CSUDIFdSet_S fdset;
	CSUDITimeval_S tTimeValue;
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);

	CSTCPrint("请拔掉网线\n");
	CSTKWaitAnyKey();

	memset(&sServerAddr,0,sizeof(sServerAddr));
	nFd = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0);
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd,"步骤1失败");

	nArg = CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0);
	CSTK_ASSERT_TRUE_FATAL(nArg != -1,"步骤2失败");

	nRet = CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, nArg | CSUDI_O_NONBLOCK, 0);
	CSTK_ASSERT_TRUE_FATAL(nRet != -1,"步骤2失败");

	memset(&sServerAddr,0,sizeof(sServerAddr));
	sServerAddr.sin_family = CSUDI_AF_INET;
	sServerAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServerAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nRet = CSUDISOCKConnect(nFd, (CSUDISockAddr_S *)&sServerAddr, sizeof(sServerAddr));
	CSTK_ASSERT_TRUE_FATAL(nRet == -1,"步骤3失败");

	nRet = CSUDISOCKGetLastError();
	CSTK_ASSERT_TRUE_FATAL((nRet == CSUDI_EINPROGRESS)||(nRet == CSUDI_EALREADY)||(nRet == CSUDI_EWOULDBLOCK),"步骤4失败");

	CSUDI_FD_ZERO(&fdset);
	CSUDI_FD_SET(nFd, &fdset);
	tTimeValue.tv_sec = 3;
	tTimeValue.tv_usec = 0;
	nRet = CSUDISOCKSelect(nFd + 1, CSUDI_NULL, &fdset, CSUDI_NULL, &tTimeValue);
	CSTK_ASSERT_TRUE_FATAL((nRet == 0), "步骤5失败");

	CSTK_FATAL_POINT   
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd),"关闭套接字失败");
	}

	CSTCPrint("测试完成，请插上网线\n");

	CSTKWaitAnyKey();

	return CSUDI_TRUE; 
}


static int CSTC_iConnect(char * pIpaddr,int nPort,unsigned int unTimeout, int *pnSocket)
{
	CSUDISockAddr_IN_S tSockaddr;
	CSUDITimeval_S tTimeValue;
	CSUDIFdSet_S fdset;
	int nResult = 0;
	int nArg = 0;
	int nStatus = 0;
	int nErr    = 0;
	int nErrlen = 0;
	int nFd = -1;

	if(CSUDI_NULL == pIpaddr  || CSUDI_NULL == pnSocket)
	{
		CSTCPrint("[%s.%d] arguments illegal\n", __FUNCTION__, __LINE__);
		return CSUDI_FAILURE;
	}

	/*create socket*/
	nFd = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0);
	if (nFd < 0)
	{
		CSTCPrint("[%s.%d] CSUDISOCKSocket failed\n", __FUNCTION__, __LINE__);
		return CSUDI_FAILURE;
	}
	/* set socket non-block */

	nArg = CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0);
	if (CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, nArg | CSUDI_O_NONBLOCK, 0) < 0)
	{
		CSTCPrint("[%s.%d] CSUDISOCKFcntl failed\n", __FUNCTION__, __LINE__);
		goto ErrOut;
	}

	/*connect*/
	tSockaddr.sin_family = CSUDI_AF_INET;
	tSockaddr.sin_port = CSUDISOCKHtons(nPort);
	if (CSUDI_NULL == pIpaddr)
	{
		tSockaddr.sin_addr.s_addr = CSUDISOCKHtonl(CSUDI_INADDR_ANY);
	}
	else
	{
		tSockaddr.sin_addr.s_addr = (unsigned int)CSUDISOCKInet_addr((char *)pIpaddr);
	}

	nResult = CSUDISOCKConnect(nFd, (CSUDISockAddr_S *)&tSockaddr, sizeof(tSockaddr));
	if (nResult==-1)
	{	
		int nLasterror = CSUDISOCKGetLastError();
		if(nLasterror != CSUDI_EINPROGRESS && nLasterror != CSUDI_EALREADY && nLasterror != CSUDI_EWOULDBLOCK)
		{	
			CSTCPrint("[%s.%d] CSUDISOCKGetLastError failed, errno:%d\n", __FUNCTION__, __LINE__, nLasterror);
			goto ErrOut;
		}
	}
	else
	{
		nArg = CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0);
		if (CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, nArg & (~CSUDI_O_NONBLOCK), 0) < 0)
		{		
			CSTCPrint("[%s.%d] CSUDISOCKFcntl failed\n", __FUNCTION__, __LINE__);
			goto ErrOut;
		}
		return CSUDI_SUCCESS;
	}

	/*wait by unTimeout*/
	CSUDI_FD_ZERO(&fdset);
	CSUDI_FD_SET((unsigned int)nFd, &fdset);
	tTimeValue.tv_sec = (unsigned long)unTimeout / 1000;
	tTimeValue.tv_usec = (unsigned long)((int)(unTimeout % 1000)) * 1000;
	nStatus = CSUDISOCKSelect(nFd + 1, CSUDI_NULL, &fdset, CSUDI_NULL, &tTimeValue);

	switch (nStatus)
	{
		case -1:  /* select error */
		{
			CSTCPrint("[%s.%d] CSUDISOCKSelect failed\n", __FUNCTION__, __LINE__);
			goto ErrOut;
		}
		case 0:   /* timeout */
		{
			CSTCPrint("[%s.%d] CSUDISOCKSelect timeout\n", __FUNCTION__, __LINE__);
			goto ErrOut;
		}
		default:  /* connect complete */
		{
			if (CSUDI_FD_ISSET(nFd, &fdset))
			{
				nErrlen = sizeof(nErr);
				CSUDISOCKGetSockOpt(nFd, CSUDI_SOL_SOCKET, CSUDI_SO_ERROR, (void*)&nErr, (unsigned int*)&nErrlen);

				if (nErr != 0)
				{      
					CSTCPrint("[%s.%d] CSUDISOCKGetSockOpt CSUDI_SO_ERROR failed\n", __FUNCTION__, __LINE__);
					goto ErrOut;
				}
			}
			break;
		}
	} /*end switch*/

	/* set socket block */
	nArg = CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0);
	if (CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, nArg & (~CSUDI_O_NONBLOCK), 0) < 0)
	{
		CSTCPrint("[%s.%d] CSUDISOCKFcntl failed\n", __FUNCTION__, __LINE__);
		goto ErrOut;
	}

	*pnSocket = nFd;

	return CSUDI_SUCCESS;

ErrOut:
	if (nFd != -1)
	{
		nErr = CSUDISOCKClose(nFd);
		if (nErr != 0)
		{
			CSTCPrint("[%s.%d] CSUDISOCKClose failed\n", __FUNCTION__, __LINE__);
		}
	}

	return CSUDI_FAILURE;
}


//@CASEGROUP: socket测试
//@DESCRIPTION:  网络可达的情况下，在客户端创建一个套接字，向服务端发起连接请求，收发数据正常
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端创建套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  connect失败返回0，或者返回-1但是错误码为CSUDI_EINPROGRESS或者CSUDI_EALREADY或者CSUDI_EWOULDBLOCK，能收发数据
//@EXECUTIONFLOW: 1、创建socket，与服务器建立非阻塞方式连接
//@EXECUTIONFLOW: 2、调用CSUDISOCKSend(nFd,acSendbuf,sizeof(acSendbuf),0)向服务器发送数据，返回实际发送的数据量;
//@EXECUTIONFLOW: 3、调用CSUDISOCKSelect(nFd+1, psReadnFds, psWritenFds, psExceptnFds, psTimeOut)检测是否有套接字可读，成功返回值不为-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKRecv(nFd, pcBuffer, *pnLen, 0);接收服务器发回来的数据，成功返回接收到的数据
//@EXECUTIONFLOW: 5、比较接受的数据和发送的数据是否相同，相同则返回成功
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_0006(void)
{
	int nFd = -1;
	int nRet = -1;
	int nTimeOut = 1000;
	char acSendbuf[1024] = {0};
	char acRecvBuf[1024] = {0};
	CSUDIFdSet_S tReadSet;
	CSUDIFdSet_S tErrorSet;
	int  tTimeout = 1000;
	CSUDITimeval_S sTime ={0};
	int nRecvLen = 0;
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	sConfig.bDualDataTransport = CSUDI_TRUE;
	SOCKET_iInitWintcpip(&sConfig);

	while (nTimeOut >= 0)
	{	
		nRet = CSTC_iConnect(g_szServIp,g_nServPort,200,&nFd);
		if (nRet == CSUDI_SUCCESS)
		{
			break;					
		}
		nTimeOut -= 200;
	}

	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd,"步骤1失败");

	memset(acSendbuf, 'a', sizeof(acSendbuf));
	memset(acRecvBuf,0,sizeof(acRecvBuf));

	nRet = CSUDISOCKSend(nFd,acSendbuf,sizeof(acSendbuf),0); 
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤2失败");

	CSUDI_FD_ZERO(&tReadSet);
	CSUDI_FD_ZERO(&tErrorSet);

	CSUDI_FD_SET((unsigned int) nFd, &tReadSet);
	CSUDI_FD_SET((unsigned int) nFd, &tErrorSet);

	sTime.tv_sec = tTimeout / 1000;
	nRet = CSUDISOCKSelect(nFd + 1, &tReadSet, CSUDI_NULL, &tErrorSet, &sTime);
	CSTK_ASSERT_TRUE_FATAL(nRet > 0,"步骤3，select失败");

	switch ( nRet )
	{
		case -1:       /* select error */
		{            
			break;
		}
		case 0:       /* timeout */
		{                        
			break;
		}
		default:       /* start */
		{
			nRecvLen = CSUDISOCKRecv(nFd, acRecvBuf, sizeof(acRecvBuf), 0);
			CSTK_ASSERT_TRUE_FATAL(nRet > 0,"步骤4，接收数据失败");
			break;
		}
	}
	CSTK_ASSERT_TRUE_FATAL(nRecvLen == sizeof(acSendbuf),"步骤5，接收到的数据长度错误");
	nRet = memcmp(acSendbuf,acRecvBuf,sizeof(acSendbuf));

	CSTK_ASSERT_TRUE_FATAL(nRet == 0,"步骤5，接收数据错误与发送的数据部匹配");

	CSTK_FATAL_POINT   
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}


//@CASEGROUP: socket测试
//@DESCRIPTION:  网络可达的情况下，但是所连接的服务器无响应
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端创建套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  connect失败返回失败，select一直返回超时，如果返回成功，查出来的是socket异常
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4流式套接字，成功返回0
//@EXECUTIONFLOW: 2、CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, nArg | CSUDI_O_NONBLOCK, 0)设置socket套接字属性为非阻塞模式，成功返回值不为-1;
//@EXECUTIONFLOW: 3、调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sClientAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求,返回-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKSelect(nFd+1, psReadnFds, psWritenFds, psExceptnFds, psTimeOut)检测是否有套接字状态，发现有异常。
//@EXECUTIONFLOW: 5、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_0007(void)
{
	int nFd = -1;
	int nRet = -1;
	int nArg = 0;
	CSUDISockAddr_IN_S sServerAddr;

	nFd = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nFd,"步骤1失败");

	nArg = CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0);
	CSTK_ASSERT_TRUE_FATAL(nArg >= 0,"步骤3失败");

	nRet = CSUDISOCKFcntl(nFd, CSUDI_F_SETFL, nArg | CSUDI_O_NONBLOCK, 0);
	CSTK_ASSERT_TRUE_FATAL(nRet >= 0,"步骤4失败");

	memset(&sServerAddr,0,sizeof(sServerAddr));
	sServerAddr.sin_family = CSUDI_AF_INET;
	sServerAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServerAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nRet = CSUDISOCKConnect(nFd, (CSUDISockAddr_S *)&sServerAddr, sizeof(sServerAddr));
	CSTK_ASSERT_TRUE_FATAL(nRet == -1,"步骤4失败");
	nRet = CSUDISOCKGetLastError();
	CSTK_ASSERT_TRUE_FATAL((nRet ==CSUDI_EINPROGRESS)||(nRet == CSUDI_EALREADY)||(nRet == CSUDI_EWOULDBLOCK),"步骤4失败");

	CSTK_FATAL_POINT   
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}


//@CASEGROUP: socket测试
//@DESCRIPTION:  网络可达的情况下，服务器开启，连接成功后，如果服务器不主动断开，检测网络可读量
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端创建套接字成功
//@INPUT:1、nFd 为创建IPv4流式套接字的返回值
//@INPUT:2、sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}
//@INPUT:3、uLen = sizeof(CSUDISockAddr_S)
//@EXPECTATION:  调用CSUDISOCKIoctl 设置CSUDI_FIONREAD可以确定套接口自动读入的数据量，在有数据的情况下，输出值不能小于等于0
//@EXECUTIONFLOW: 1、创建socket，与服务器建立非阻塞方式TCP连接
//@EXECUTIONFLOW: 2、调用CSUDISOCKSend(nFd,acSendbuf,sizeof(acSendbuf),0)向服务器发送数据，返回实际发送的数据量;
//@EXECUTIONFLOW: 3、调用CSUDISOCKSelect(nFd+1, psReadnFds, psWritenFds, psExceptnFds, psTimeOut)检测是否有套接字可读，成功返回值不为-1
//@EXECUTIONFLOW: 4、调用CSUDISOCKIoctl(nFd, CSUDI_FIONREAD,&nReadSize, NULL)有网络连接的可读量 
//@EXECUTIONFLOW: 5、调用CSUDISOCKRecv(nFd, pcBuffer, *pnLen, 0);接收服务器发回来的数据，成功返回接收到的数据
//@EXECUTIONFLOW: 6、比较接受的数据和发送的数据是否相同，相同则返回成功，比较可读量和接受的数据是否相等，相等则返回成功
//@EXECUTIONFLOW: 7、调用CSUDISOCKClose(nFd)关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_0008(void)
{
	int nFd = -1;
	int nRet = -1;
	int nReadSize = -1;
	char acSendbuf[1024] = {0}; // 保证能一次性接收完成
	char acRecvBuf[1024] = {0};
	int nTimeOut = 1000;
	int nRecvLen = -1;
	CSUDITimeval_S sTime ={0};
	CSUDIFdSet_S tReadSet;
	CSUDIFdSet_S tErrorSet;
	WintcpipConfig_S sConfig;

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	sConfig.bDualDataTransport = CSUDI_TRUE;
	SOCKET_iInitWintcpip(&sConfig);

	while (nTimeOut >= 0)
	{	
		nRet = CSTC_iConnect(g_szServIp,g_nServPort,200,&nFd);
		if (nRet == CSUDI_SUCCESS)
		{
			break;					
		}
		nTimeOut -= 200;
	}

	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd,"步骤1失败");

	memset(acSendbuf,'c',sizeof(acSendbuf));

	nRet = CSUDISOCKSend(nFd,acSendbuf,sizeof(acSendbuf),0); 
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤2失败");

	CSUDI_FD_ZERO(&tReadSet);
	CSUDI_FD_ZERO(&tErrorSet);

	CSUDI_FD_SET((unsigned int) nFd, &tReadSet);
	CSUDI_FD_SET((unsigned int) nFd, &tErrorSet);

	sTime.tv_sec = nTimeOut/1000;

	nRet = CSUDISOCKSelect(nFd + 1, &tReadSet, CSUDI_NULL, &tErrorSet, &sTime);
	CSTK_ASSERT_TRUE_FATAL(nRet > 0,"步骤3失败");

	switch ( nRet )
	{
		case -1:       /* select error */
		{            
			break;
		}
		case 0:       /* timeout */
		{                        
			break;
		}
		default:       /* start */
		{
			nRet = CSUDISOCKIoctl(nFd, CSUDI_FIONREAD,&nReadSize,NULL);
			CSTK_ASSERT_TRUE_FATAL(nRet >= 0,"步骤4失败");

			CSTK_ASSERT_TRUE_FATAL(nReadSize > 0,"步骤4失败,对方连接已经断开");

			nRecvLen = CSUDISOCKRecv(nFd, acRecvBuf, sizeof(acRecvBuf), 0);
			CSTK_ASSERT_TRUE_FATAL(nRecvLen > 0,"步骤5，接收数据失败");
			break;
		}
	}

	CSTK_ASSERT_TRUE_FATAL(nRecvLen == sizeof(acSendbuf),"步骤6，接收到的数据长度错误");
	nRet = memcmp(acSendbuf,acRecvBuf,sizeof(acSendbuf));

	CSTK_ASSERT_TRUE_FATAL(nRet == 0,"步骤6，接收数据错误与发送的数据不匹配");
	CSTK_ASSERT_TRUE_FATAL(nRecvLen == nReadSize,"步骤6，接收数据与ioctl读取数据不相等");

	CSTK_FATAL_POINT   
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd),"关闭套接字失败");
	}

	return CSUDI_TRUE;   
}


//@CASEGROUP: socket测试
//@DESCRIPTION:  测试固定长度丢包情况，包长从0-1464，循环ping
//@PRECONDITION: 协议栈初始化成功
//@INPUT:1、无
//@EXPECTATION:  循环ping服务器，包长从0-1464，每次都能ping通
CSUDI_BOOL CSTC_SOCKET_IT_0009(void)
{
	char acCmd[254] = {0};
	int i = 0;
	char acBackStr[1024] = {0};
	int nRet = -1;

	memset(acBackStr, 0, sizeof(acBackStr));

	for(i=0;i<1464;i++)
	{
		memset(acCmd,0,sizeof(acCmd));
		sprintf((char*)acCmd, "%s %s %s %d", "ping",g_szServIp,"-l", i);
		CSTCPrint("acCmd is %s\n", acCmd);

		nRet = CSTC_iPing(acCmd, acBackStr, sizeof(acBackStr), 1000);
		CSTK_ASSERT_TRUE_FATAL(nRet == CSUDI_SUCCESS, "步骤4失败");
	}

	CSTK_FATAL_POINT   
	if(nRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == nRet, "步骤5失败，ping 不通");
	}

	return CSUDI_TRUE; 
}

static int CSTC_iPing_cmd( int argc, char **argv,char * ip)
{
	char *optarg;
	int  i, ipset;

	ipset = 0;

	/* Parse the arguments. See Usage for description */
	for (i = 0; i < argc; i++) 
	{
		if (argv[i][0] == '-')
		{ /* parameters */
			optarg = argv[i+1];
			switch(argv[i][1]) 
			{
				case 't': 
				break; /* infinite */
				case 'f': 
				break;  /* don't fragment */
				case 'n':
				i++; 
				break;
				case 'l':
				i++; 
				break;
				case 'i':
				i++; 
				break;
				case 'w':
				i++; 
				break;
			}
		}
		else 
		{
		/* get host address */
			if((argv[i][0] != 'p')&&(argv[i][0] != 'P'))
			{
				strcpy(ip,argv[i]);
				ipset = 1;
			}
		}      
	}

	if (!ipset) 
	{
		CSTCPrint("[%s.%d] failed\n", __FUNCTION__, __LINE__);
		return -1;
	}

	return 0;
}

static int CSTC_iParsePingCmd(char* input,char* ip) 
{
	int parm_n = 0;
	char *parm_p[32] ;
	int nRet;
	int nIndex = 0;
	char  string_p[300];
	char * begin_p = string_p;
	char * end_p = 0;
	int str_len =  strlen(input);

	memcpy(string_p, input, str_len+1);

	begin_p = string_p;

	while(*begin_p != '\0')
	{
		//走掉开始的空格
		while(*begin_p == ' ')
		{
			begin_p++;
		}

		if(*begin_p == '\0')
		{
			//结束符处理
			break;
		}

		end_p = begin_p;

		while(*end_p != ' ' && *end_p != 0)
		{
			end_p++;
		}

		if(*end_p != 0)
		{
			*end_p = 0;
			parm_p[nIndex++] = begin_p;
			begin_p = end_p+1;
		}
		else
		{
			parm_p[nIndex++] = begin_p;
			break;
		}
	}
	parm_n = nIndex;

	nRet = CSTC_iPing_cmd( parm_n, parm_p,ip);

	return nRet;
}

static unsigned short CSTC_iChksum(unsigned short *addr, int len)
{
	int nleft=len;
	int sum=0;
	unsigned short *w=addr;
	unsigned short answer=0;

	while(nleft > 1)
	{
		sum += *w++;
		nleft -= 2;
	}

	if( nleft == 1)
	{       
		*(unsigned char *)(&answer) = *(unsigned char *)w;
		sum += answer;
	}

	sum = (sum >> 16) + (sum & 0xffff);
	sum += (sum >> 16);
	answer = ~sum;

	return answer;
}

static int CSTC_iPing(char *pPingStr, char*pBackStr,unsigned int backstrlen,unsigned int timeout)
{    
	CSUDITimeval_S timeo;
	int sockfd;
	CSUDISockAddr_IN_S addr;
	CSUDIProtoent_S *protocol;
	SIpHeaderTest *iph;
	SIcmpHeaderTest *icmp;
	char sendpacket[PACKET_SIZE];
	char recvpacket[PACKET_SIZE];
	char cIpAddr[16];
	int n;
	int nRet;
	int maxfds = 0;
	CSUDIFdSet_S readfds;
	unsigned int packsize;
	unsigned int dwStart;
	unsigned int dwAddLen=0;
	unsigned short g_pid = 0xbeef;

	if((pBackStr==CSUDI_NULL)||(pPingStr==CSUDI_NULL)||(backstrlen<512))
	{
		CSTCPrint("[%s.%d] arguments illegal\n", __FUNCTION__, __LINE__);
		return CSUDI_FAILURE;
	}

	/*add by zch 080911 begin,为了和NG的参数(如:ping -n 8 -t ip)兼容,也便于以后扩展*/
	nRet = CSTC_iParsePingCmd(pPingStr,cIpAddr) ;
	if (nRet!=0)
	{
		CSTCPrint("[%s.%d] CSTC_iParsePingCmd failed\n", __FUNCTION__, __LINE__);
		return CSUDI_FAILURE;
	}
	/*add by zch 080911 end*/
	memset(&addr,0,sizeof(addr));

	addr.sin_family = CSUDI_AF_INET;
	addr.sin_addr.s_addr = CSUDISOCKInet_addr(cIpAddr);    
	if( (protocol=CSUDISOCKGetProtoByName("icmp") )==CSUDI_NULL)
	{	
		CSTCPrint("[%s.%d] CSUDISOCKGetProtoByName failed\n", __FUNCTION__, __LINE__);
		return CSUDI_FAILURE;
	}

	sockfd = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_RAW, protocol->p_proto);
	if (sockfd < 0) 
	{
		CSTCPrint("[%s.%d] CSUDISOCKSocket falied\n", __FUNCTION__, __LINE__);
		return CSUDI_FAILURE;
	}

	timeo.tv_sec = timeout / 1000;
	timeo.tv_usec = timeout % 1000;

	if (CSUDISOCKSetSockOpt(sockfd, CSUDI_SOL_SOCKET, CSUDI_SO_SNDTIMEO, &timeo, sizeof(timeo)) == -1)
	{	
		CSTCPrint("[%s.%d] CSUDISOCKSetSockOpt CSUDI_SO_SNDTIMEO failed\n", __FUNCTION__, __LINE__);
		goto ErrOut;
	}

	memset(sendpacket, 0, sizeof(sendpacket));

	icmp=( SIcmpHeaderTest*)sendpacket;
	icmp->type=CSICMP_ECHO;
	icmp->code=0;
	icmp->cksum=0;
	icmp->seq=0;
	icmp->id=g_pid;
	packsize=8+56;
	icmp->tstart = CSUDIPlusOSGetTickCount();
	icmp->cksum=CSTC_iChksum((unsigned short *)icmp,packsize);

	dwStart = CSUDIPlusOSGetTickCount(); //start time
	dwAddLen = sizeof(addr);
	n = CSUDISOCKSendTo(sockfd, (const void *)&sendpacket, packsize, 0, (const CSUDISockAddr_S * )&addr, dwAddLen);
	if (n < 1)
	{
		CSTCPrint("[%s.%d] CSUDISOCKSendTo failed\n", __FUNCTION__, __LINE__);
		goto ErrOut;
	}

	while(1)
	{
		CSUDI_FD_ZERO(&readfds);
		CSUDI_FD_SET(sockfd, &readfds);
		maxfds = sockfd + 1;
		n = CSUDISOCKSelect(maxfds, &readfds, CSUDI_NULL, CSUDI_NULL, &timeo);
		
		if (n <= 0)
		{
			CSTCPrint("[%s.%d] CSUDISOCKSelect failed or timeout\n", __FUNCTION__, __LINE__);
			goto ErrOut;
		}
		memset(recvpacket, 0, sizeof(recvpacket));
		dwAddLen = sizeof(CSUDISockAddr_IN_S); //ng下如果fromlen传空会死机

		n = CSUDISOCKRecvFrom(sockfd, recvpacket, sizeof(recvpacket), 0, CSUDI_NULL, &dwAddLen);
		if (n < 1) 
		{
			CSTCPrint("[%s.%d] CSUDISOCKRecvFrom failed ret < 1\n", __FUNCTION__, __LINE__);
			goto ErrOut;
		}
		dwStart = CSUDIPlusOSGetTickCount() - dwStart;

		iph = (SIpHeaderTest *)recvpacket;

		icmp=(SIcmpHeaderTest *)(recvpacket + ((iph->ip_hlv&CS_IPHDRLEN_MASK)<<2));

		if (icmp->type == CSICMP_ECHOREPLY && icmp->id == g_pid)
		{
			sprintf(pBackStr,"Reply from %s:  time<%dms \n",cIpAddr, dwStart);

			break;
		} 
		else
		{
			continue;
		}
	}

	if (sockfd != -1)
	{
		nRet = CSUDISOCKClose(sockfd);
		if (nRet != 0)
		{
			CSTCPrint("[%s.%d] CSUDISOCKClose failed\n", __FUNCTION__, __LINE__);
			return CSUDI_FAILURE;
		}
	}

	return CSUDI_SUCCESS;

ErrOut:
	if (sockfd != -1)
	{
		nRet = CSUDISOCKClose(sockfd);
		if (nRet != 0)
		{
			CSTCPrint("[%s.%d] CSUDISOCKClose failed\n", __FUNCTION__, __LINE__);
		}
	}

	return CSUDI_FAILURE;
}


//@CASEGROUP: socket测试
//@DESCRIPTION:  循环接收数据，机顶盒作为服务器接收pc发起的连接请求
//@PRECONDITION:1、协议栈初始化成功
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))绑定本机地址
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd,10)启动监听
//@EXECUTIONFLOW: 4、调用CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,&nAccpetLen);接受连接
//@EXECUTIONFLOW: 5、调用CSUDISOCKRecv(nRetAcceptFd, nRecvBuf, sizeof(nRecvBuf), 0);开始循环接受数据，返回值大于0
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose关闭socket
CSUDI_BOOL CSTC_SOCKET_IT_0012(void)
{
	int nFd = -1;
	int nRet = -1;
	int nRetAcceptFd = -1;
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	char acRecvBuf[5000] = {0};
	unsigned int nAccpetLen = 0;
	WintcpipConfig_S sConfig;

	memset(&sServAddr,0,sizeof(sServAddr));
	memset(&sClientAddr,0,sizeof(sClientAddr));

	nFd = CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nFd,"步骤1失败");

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nStbPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)),"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKListen(nFd,10),"步骤3失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_CLIENT;
	sConfig.uBufLen = 1460;
	sConfig.wServerPortForClient = 51000;
	sConfig.bDualDataTransport = CSUDI_TRUE;
	SOCKET_iInitWintcpip(&sConfig);

	nAccpetLen = sizeof(sClientAddr);
	nRetAcceptFd = CSUDISOCKAccept(nFd,(CSUDISockAddr_S*)&sClientAddr,&nAccpetLen);

	CSUDIOSThreadSleep(1000);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRetAcceptFd,"步骤4失败");
	nRet = CSUDISOCKRecv(nRetAcceptFd, acRecvBuf, sizeof(acRecvBuf), 0);
	CSTCPrint("nRet:%d\n", nRet);
	CSTK_ASSERT_TRUE_FATAL(nRet > 0,"步骤5失败");  //设置pc端软件发送字节为1460个

	nRet = CSUDISOCKClose(nRetAcceptFd);
	CSTK_ASSERT_TRUE_FATAL(-1 != nRet,"步骤6失败");

	CSTK_FATAL_POINT   
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}

//@CASEGROUP: socket测试
//@DESCRIPTION:  机顶盒作为服务器启动监听，先select是否有客户端连接，再去创建连接
//@PRECONDITION:1、协议栈初始化成功
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_PF_INET, CSUDI_SOCK_STREAM, 0) 创建一个流式套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKBind (nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S))绑定本机地址
//@EXECUTIONFLOW: 3、调用CSUDISOCKListen(nFd, 10)启动监听
//@EXECUTIONFLOW: 4、调用CSUDISOCKSelect(nFd + 1, &sReadnFds, NULL, NULL, &tv)，检测是否有套接字可读
//@EXECUTIONFLOW: 5、调用CSUDI_FD_ISSET(nFd, &sReadnFds)，检查nFd是否在sReadnFds中
//@EXECUTIONFLOW: 6、调用CSUDISOCKAccept(nFd, (CSUDISockAddr_S*)&sClientAddr, &uAddrLen)，启动连接
//@EXECUTIONFLOW: 7、调用CSUDISOCKClose关闭监听socket
//@EXECUTIONFLOW: 8、调用CSUDISOCKClose关闭连接socket
CSUDI_BOOL CSTC_SOCKET_IT_0025(void)
{
	int nFd = -1;
	int nRet = -1;
	int nAcceptRet = -1;
	CSUDITimeval_S tv;
	CSUDIFdSet_S sReadnFds;
	CSUDISockAddr_IN_S sServAddr;
	CSUDISockAddr_IN_S sClientAddr;
	unsigned int uAddrLen = sizeof(sClientAddr);
	WintcpipConfig_S sConfig;

	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nStbPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szStbIp);

	nFd = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0);
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd, "步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKBind(nFd, (CSUDISockAddr_S*)&sServAddr, sizeof(CSUDISockAddr_S)), "步骤2失败");	
	CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKListen(nFd, 10), "步骤3失败");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_CLIENT;
	sConfig.uBufLen = 1460;
	sConfig.wServerPortForClient = 51000;
	SOCKET_iInitWintcpip(&sConfig);

	tv.tv_sec = 0;
	tv.tv_usec = 200 * 1000;

	CSUDI_FD_ZERO(&sReadnFds);
	CSUDI_FD_SET(nFd, &sReadnFds);

	nRet = CSUDISOCKSelect(nFd + 1, &sReadnFds, NULL, NULL, &tv);
	CSTK_ASSERT_TRUE_FATAL(nRet > 0, "步骤4失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FD_ISSET(nFd, &sReadnFds), "步骤5失败");

	nAcceptRet = CSUDISOCKAccept(nFd, (CSUDISockAddr_S*)&sClientAddr, &uAddrLen);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nAcceptRet,"步骤6失败");

	CSTK_FATAL_POINT
	if (nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nFd), "关闭监听套接字失败");
	}
	if (nAcceptRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(0 == CSUDISOCKClose(nAcceptRet), "关闭连接套接字失败");
	}

	return CSUDI_TRUE;
}


//@CASEGROUP:1、socket测试  
//@DESCRIPTION: 成功设置和获取套接字选项CSUDI_IP_TOS 的值
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以成功创建IPv4数据报套接字
//@INPUT:1、CSUDISOCKSetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_IPPROTO_IP
//@INPUT:nOptname = CSUDI_IP_TOS
//@INPUT:pnOptval = &nSetSendTimeOut，其中  nSetSendTimeOut=1000,单位毫秒  
//@INPUT:uOptlen = sizeof(nSetSendTimeOut)
//@INPUT:2、CSUDISOCKGetSockOpt 函数的参数说明:
//@INPUT:nFd 为创建成功的套接字返回值
//@INPUT:nLevel = CSUDI_IPPROTO_IP
//@INPUT:nOptname = CSUDI_IP_TOS
//@INPUT:pnOptval = &nGetSendTimeOut
//@INPUT:uOptlen = sizeof(nGetSendTimeOut)
//@EXPECTATION:成功返回CSUDI_SUCCESS 
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKSetSockOpt(nFd, nLevel, nOptname,pnOptval, uOptlen),设置CSUDI_IP_TOS选项值，成功返回0
//@EXECUTIONFLOW: 3、调用CSUDISOCKGetSockOpt(nFd, nLevel, nOptname,pnOptval, &uOptlen),获取CSUDI_IP_TOS选项值，成功返回0
//@EXECUTIONFLOW: 4、比较获取的和设置的是否相等
//@EXECUTIONFLOW: 4、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_0026(void)
{   
	int nSockRet = -1;
	unsigned char ucSetServiceType = CS_IPTOS_LOWDELAY | CS_IPTOS_THROUGHPUT | CS_IPTOS_RELIABILITY; // see struct SIpHeaderTest
	unsigned char ucGetServiceType = 0;
	int nLen = sizeof(ucGetServiceType);

	nSockRet = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet, "步骤1失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKSetSockOpt(nSockRet, CSUDI_IPPROTO_IP, CSUDI_IP_TOS, &ucSetServiceType, sizeof(ucSetServiceType)), "步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKGetSockOpt(nSockRet, CSUDI_IPPROTO_IP, CSUDI_IP_TOS, (void*)&ucGetServiceType, (unsigned int*)&nLen), "步骤3失败");
	CSTK_ASSERT_TRUE_FATAL(ucGetServiceType == ucSetServiceType, "获取的和设置的选项不符");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"关闭套接字失败");
	}

	return CSUDI_TRUE; 
}

//@CASEGROUP:1、CSUDISOCKIoctl测试  
//@DESCRIPTION: 成功设置CSUDI_FIONBIO
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、可以成功创建IPv4数据报套接字
//@INPUT:1、nFd 为创建成功的套接字返回值
//@INPUT:2、CSUDI_FIONBIO
//@INPUT:3、nArg = 1
//@EXPECTATION:设置CSUDI_FIONBIO生效
//@EXECUTIONFLOW: 1、调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0) 创建一个IPv4流式的套接字,返回值为nFd
//@EXECUTIONFLOW: 2、调用CSUDISOCKIoctl(nFd, CSUDI_FIONBIO, &nArg, CSUDI_NULL),设置CSUDI_FIONBIO，成功返回非-1
//@EXECUTIONFLOW: 3、调用CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0),获取套接字属性，成功返回非-1
//@EXECUTIONFLOW: 4、判断获取的属性值是否包含CSUDI_O_NONBLOCK
//@EXECUTIONFLOW: 5、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_Ioctl_0001(void)
{   
	int nFd = -1;
	int nArg = 1;

	nFd = CSUDISOCKSocket(CSUDI_AF_INET, CSUDI_SOCK_STREAM, 0);
	CSTK_ASSERT_TRUE_FATAL(-1 != nFd, "步骤1失败");

	CSTK_ASSERT_TRUE_FATAL(-1 != CSUDISOCKIoctl(nFd, CSUDI_FIONBIO, &nArg, CSUDI_NULL), "步骤2失败");

	nArg = CSUDISOCKFcntl(nFd, CSUDI_F_GETFL, 0, 0);
	CSTK_ASSERT_TRUE_FATAL(nArg != -1, "步骤3失败");
	CSTK_ASSERT_TRUE_FATAL((nArg & CSUDI_O_NONBLOCK) != 0, "步骤4失败");

	CSTK_FATAL_POINT
	if(nFd != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nFd), "关闭套接字失败");
	}

	return CSUDI_TRUE; 
}

//@CASEGROUP: 集成测试  
//@DESCRIPTION: 服务器端进程异常终止，客户端仍然发送数据不会出现死机
//@PRECONDITION:1、协议栈初始化成功
//@PRECONDITION:2、客户端可以创建IPv4流式套接字成功
//@PRECONDITION:3、客户端与服务端可以连接成功
//@INPUT:1、nFd 创建基于IPv4流式套接字的返回值
//@INPUT:2、szBuf[16]="hello world"
//@INPUT:3、uNum = 8
//@INPUT:4、nFlags =0
//@EXPECTATION: 测试用例正常结束，不死机
//@EXECUTIONFLOW: 1、确认是否执行该用例
//@EXECUTIONFLOW: 2、客户端调用CSUDISOCKSocket(CSUDI_AF_INET,CSUDI_SOCK_STREAM,0)创建一个IPv4流式套接字,成功返回nFd
//@EXECUTIONFLOW: 3、客户端调用CSUDISOCKConnect(nFd,(CSUDISockAddr_S*)&sServAddr,sizeof(CSUDISockAddr_S))本地主机向服务器发起连接请求，sServAddr:{sin_family = CSUDI_AF_INET;sin_port = CSUDISOCKHtons(g_nServPort);sin_addr = CSUDISOCKInet_addr(g_szServIp)}，成功返回0
//@EXECUTIONFLOW: 4、客户端调用CSUDISOCKSend(nFd, szBuf, uNum, nFlags)向服务器端发送数据，成功返回8
//@EXECUTIONFLOW: 5、提示关闭Win_tcpip工具，并调用CSUDISOCKSend(nFd, szBuf, uNum, nFlags)向服务器端发送数据，期望返回-1
//@EXECUTIONFLOW: 6、调用CSUDISOCKClose(nFd) 关闭套接字，成功返回0
CSUDI_BOOL CSTC_SOCKET_IT_00027(void)
{
	int i = 0;
	int nRet = 0;
	int nLoopCnt = 100;
	int nSockRet = -1;
	int nDomain = CSUDI_AF_INET;
	int nType = CSUDI_SOCK_STREAM;
	int nProtocol = 0;
	char szBuf[]="hello world";
	WintcpipConfig_S sConfig;

	CSTCPrint("运行本测试用例可能会出现死机，确定是否继续执行?\n");
	CSTK_ASSERT_TRUE_FATAL(CSTKWaitYes(), "步骤1失败，选择跳过执行");

	memset(&sConfig, 0x00, sizeof(WintcpipConfig_S));
	sConfig.eProtocolType = SOCKET_PROTOCOL_TCP;
	sConfig.eWintcpipMode = WINTCPIP_MODE_SERVER;
	sConfig.uBufLen = 1460;
	sConfig.wServerPort = 26000;
	SOCKET_iInitWintcpip(&sConfig);
	
	CSUDISockAddr_IN_S sServAddr;
	sServAddr.sin_family = CSUDI_AF_INET;
	sServAddr.sin_port = CSUDISOCKHtons(g_nServPort);
	sServAddr.sin_addr.s_addr = CSUDISOCKInet_addr(g_szServIp);

	nSockRet = CSUDISOCKSocket(nDomain,nType,nProtocol);
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != nSockRet,"步骤2失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKConnect(nSockRet,(CSUDISockAddr_S*)&sServAddr, sizeof( CSUDISockAddr_S)),"步骤3失败");
	CSTK_ASSERT_TRUE_FATAL(CSUDI_FAILURE != CSUDISOCKSend(nSockRet, szBuf, sizeof(szBuf), 0),"步骤4失败");

	CSTCPrint("10s内请关闭Win_Tcpip工具，如果出现测试用例异常终止(死机)，则该用例执行失败\n");
	for (i=0; i<nLoopCnt; i++)
	{
		CSUDIOSThreadSleep(100);
		nRet = CSUDISOCKSend(nSockRet, szBuf, sizeof(szBuf), 0);
	}

	CSTK_ASSERT_TRUE_FATAL(nRet == -1, "步骤5失败，10s内没有关闭Win_Tcpip工具");

	CSTK_FATAL_POINT
	if(nSockRet != -1 )
	{
		CSTK_ASSERT_TRUE_FATAL(CSUDI_SUCCESS == CSUDISOCKClose(nSockRet),"步骤6失败");
	}

	return CSUDI_TRUE;	
}


